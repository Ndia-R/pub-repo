２０ファイル

------------------------------------------------------------
book_content_pages.csv

afcIMuetDuzj,6,4,「なら……試してみる？」\n\nルカは深く頷いた。\n\n「どんな試練でも、僕は乗り越える。君と一緒にいるためなら」\n\nその瞬間、湖の光が大きく揺らぎ、二人を包み込んだ。世界が眩しい光に満たされ、すべてが溶け合うような感覚に襲われた。\n\n気が付くと、ルカは湖のほとりに倒れていた。\n\n「ルカ？」\n\n優しい声が聞こえた。顔を上げると、そこには変わらぬ姿のセレナがいた。\n\n「セレナ……？」\n\n「私、まだ覚えてる……！」\n\nルカの胸に喜びが広がった。彼はセレナを抱きしめた。\n\n「やった……！」\n\n湖の水面には、二匹のワニが寄り添う影が映っていた。月は穏やかに輝き、二人の未来を祝福するように照らしていた。\n\n彼らの愛は、月の掟すら超えたのだ。\n\n──ワニと月の舞踏会は、終わりを迎えた。\n\nしかし、それは二人の新たな物語の始まりでもあった。

------------------------------------------------------------
init.sql

DROP DATABASE IF EXISTS `my-books-db`;
CREATE DATABASE `my-books-db`;

USE `my-books-db`;

DROP TABLE IF EXISTS `books`;
DROP TABLE IF EXISTS `genres`;
DROP TABLE IF EXISTS `book_genres`;
DROP TABLE IF EXISTS `users`;
DROP TABLE IF EXISTS `roles`;
DROP TABLE IF EXISTS `user_roles`;
DROP TABLE IF EXISTS `reviews`;
DROP TABLE IF EXISTS `favorites`;
DROP TABLE IF EXISTS `bookmarks`;
DROP TABLE IF EXISTS `book_chapters`;
DROP TABLE IF EXISTS `book_content_pages`;


CREATE TABLE `books` (
  `id` VARCHAR(255) NOT NULL PRIMARY KEY,
  `title` VARCHAR(255) NOT NULL DEFAULT '',
  `description` TEXT NOT NULL,
  `authors` VARCHAR(255) NOT NULL DEFAULT '',
  `publisher` VARCHAR(255) NOT NULL DEFAULT '',
  `published_date` DATE NOT NULL,
  `price` INT NOT NULL DEFAULT 0,
  `page_count` INT NOT NULL DEFAULT 0,
  `isbn` VARCHAR(255) NOT NULL DEFAULT '',
  `image_url` VARCHAR(255) DEFAULT NULL,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_deleted` BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE TABLE `genres` (
  `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  `name` VARCHAR(255) NOT NULL DEFAULT '',
  `description` VARCHAR(255) NOT NULL DEFAULT '',
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_deleted` BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE TABLE `book_genres` (
  `book_id` VARCHAR(255) NOT NULL,
  `genre_id` BIGINT NOT NULL,
  PRIMARY KEY (`book_id`, `genre_id`),
  FOREIGN KEY (`book_id`) REFERENCES `books`(`id`) ON DELETE CASCADE,
  FOREIGN KEY (`genre_id`) REFERENCES `genres`(`id`) ON DELETE CASCADE
);

CREATE TABLE `users` (
  `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  `email` VARCHAR(255) NOT NULL UNIQUE,
  `password` VARCHAR(255) NOT NULL DEFAULT '',
  `name` VARCHAR(255) NOT NULL DEFAULT '',
  `avatar_url` VARCHAR(255) DEFAULT NULL,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_deleted` BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE TABLE `roles` (
  `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  `name` VARCHAR(255) NOT NULL DEFAULT '',
  `description` VARCHAR(255) NOT NULL DEFAULT '',
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_deleted` BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE TABLE `user_roles` (
  `user_id` BIGINT NOT NULL,
  `role_id` BIGINT NOT NULL,
  PRIMARY KEY (`user_id`, `role_id`),
  FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE CASCADE,
  FOREIGN KEY (`role_id`) REFERENCES `roles`(`id`) ON DELETE CASCADE
);

CREATE TABLE `reviews` (
  `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  `user_id` BIGINT NOT NULL,
  `book_id` VARCHAR(255) NOT NULL,
  `comment` VARCHAR(1000) NOT NULL DEFAULT '',
  `rating` DECIMAL(2, 1) NOT NULL DEFAULT 0.0 CHECK (`rating` >= 0 AND `rating` <= 5),
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_deleted` BOOLEAN NOT NULL DEFAULT FALSE,
  UNIQUE (`user_id`, `book_id`),
  FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE CASCADE,
  FOREIGN KEY (`book_id`) REFERENCES `books`(`id`) ON DELETE CASCADE
);

CREATE TABLE `favorites` (
  `user_id` BIGINT NOT NULL,
  `book_id` VARCHAR(255) NOT NULL,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_deleted` BOOLEAN NOT NULL DEFAULT FALSE,
  PRIMARY KEY (`user_id`, `book_id`),
  FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE CASCADE,
  FOREIGN KEY (`book_id`) REFERENCES `books`(`id`) ON DELETE CASCADE
);

CREATE TABLE `bookmarks` (
  `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  `user_id` BIGINT NOT NULL,
  `book_id` VARCHAR(255) NOT NULL,
  `chapter_number` INT NOT NULL,
  `page_number` INT NOT NULL,
  `note` VARCHAR(1000) NOT NULL DEFAULT '',
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_deleted` BOOLEAN NOT NULL DEFAULT FALSE,
  UNIQUE (`user_id`, `book_id`, `chapter_number`, `page_number`),
  FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE CASCADE,
  FOREIGN KEY (`book_id`) REFERENCES `books`(`id`) ON DELETE CASCADE
);

CREATE TABLE `book_chapters` (
  `book_id` VARCHAR(255) NOT NULL,
  `chapter_number` INT NOT NULL,
  `title` VARCHAR(255) NOT NULL,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_deleted` BOOLEAN NOT NULL DEFAULT FALSE,
  PRIMARY KEY (`book_id`, `chapter_number`),
  FOREIGN KEY (`book_id`) REFERENCES `books`(`id`) ON DELETE CASCADE
);

CREATE TABLE `book_content_pages` (
  `book_id` VARCHAR(255) NOT NULL,
  `chapter_number` INT NOT NULL,
  `page_number` INT NOT NULL,
  `content` TEXT NOT NULL,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_deleted` BOOLEAN NOT NULL DEFAULT FALSE,
  PRIMARY KEY (`book_id`, `chapter_number`, `page_number`),
  FOREIGN KEY (`book_id`, `chapter_number`) REFERENCES `book_chapters`(`book_id`, `chapter_number`) ON DELETE CASCADE
);

-- データのロード
LOAD DATA INFILE '/docker-entrypoint-initdb.d/books.csv'
INTO TABLE books
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n'
(`id`, `title`, `description`, `authors`, `publisher`, `published_date`, `price`, `page_count`, `isbn`, `image_url`);

INSERT INTO `genres` (`name`, `description`) VALUES
('ミステリー', '謎解きや推理をテーマにした作品'),
('サスペンス', '緊張感や驚きを伴う作品'),
('ロマンス', '恋愛をテーマにした作品'),
('ファンタジー', '魔法や異世界を舞台にした作品'),
('SF', '科学技術や未来をテーマにした作品'),
('ホラー', '恐怖をテーマにした作品'),
('歴史', '歴史的な出来事や人物をテーマにした作品'),
('絵本', '子供向けのイラストが多い本'),
('教科書', '教育機関で使用される教材'),
('専門書', '特定の分野に特化した書籍'),
('研究書', '学術的な研究をまとめた書籍'),
('環境', '自然や環境問題をテーマにした作品'),
('冒険', '冒険や探検をテーマにした作品'),
('図鑑', '特定のテーマに関する情報を集めた書籍'),
('音楽', '音楽に関する書籍'),
('ドラマ', '人間関係や感情を描いた作品'),
('教育', '教育に関する書籍');

LOAD DATA INFILE '/docker-entrypoint-initdb.d/book_genres.csv'
INTO TABLE book_genres
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n'
(`book_id`, `genre_id`);

INSERT INTO `users` (`name`, `email`, `password`, `avatar_url`) VALUES
('Lars', 'lars@gmail.com', '$2a$10$E7FzFP73ImXXFHUmUUmXtuDrJnp0gZ3Zb3XJluLEW7tfnVmh5FLwC', 'https://localhost/images/avatars/avatar01.png'),
('Nina', 'nina@gmail.com', '$2a$10$E7FzFP73ImXXFHUmUUmXtuDrJnp0gZ3Zb3XJluLEW7tfnVmh5FLwC', 'https://localhost/images/avatars/avatar02.png'),
('Paul', 'paul@gmail.com', '$2a$10$E7FzFP73ImXXFHUmUUmXtuDrJnp0gZ3Zb3XJluLEW7tfnVmh5FLwC', 'https://localhost/images/avatars/avatar03.png'),
('Julia', 'julia@gmail.com', '$2a$10$E7FzFP73ImXXFHUmUUmXtuDrJnp0gZ3Zb3XJluLEW7tfnVmh5FLwC', 'https://localhost/images/avatars/avatar04.png'),
('Lee', 'lee@gmail.com', '$2a$10$E7FzFP73ImXXFHUmUUmXtuDrJnp0gZ3Zb3XJluLEW7tfnVmh5FLwC', 'https://localhost/images/avatars/avatar05.png'),
('Lili', 'lili@gmail.com', '$2a$10$E7FzFP73ImXXFHUmUUmXtuDrJnp0gZ3Zb3XJluLEW7tfnVmh5FLwC', 'https://localhost/images/avatars/avatar06.png'),
('Steve', 'steve@gmail.com', '$2a$10$E7FzFP73ImXXFHUmUUmXtuDrJnp0gZ3Zb3XJluLEW7tfnVmh5FLwC', 'https://localhost/images/avatars/avatar07.png'),
('Anna', 'anna@gmail.com', '$2a$10$E7FzFP73ImXXFHUmUUmXtuDrJnp0gZ3Zb3XJluLEW7tfnVmh5FLwC', 'https://localhost/images/avatars/avatar08.png'),
('Law', 'law@gmail.com', '$2a$10$E7FzFP73ImXXFHUmUUmXtuDrJnp0gZ3Zb3XJluLEW7tfnVmh5FLwC', 'https://localhost/images/avatars/avatar09.png'),
('Alisa', 'alisa@gmail.com', '$2a$10$E7FzFP73ImXXFHUmUUmXtuDrJnp0gZ3Zb3XJluLEW7tfnVmh5FLwC', 'https://localhost/images/avatars/avatar10.png');

INSERT INTO `roles` (`name`, `description`) VALUES
('ROLE_ADMIN', '管理者権限'),
('ROLE_USER', 'ユーザー権限');

INSERT INTO `user_roles` (`user_id`, `role_id`) VALUES
(1, 2),
(2, 2),
(3, 2),
(4, 2),
(5, 2),
(6, 2),
(7, 2),
(8, 2),
(9, 2),
(10, 2),
(3, 1),
(4, 1);

INSERT INTO `reviews` (`user_id`, `book_id`, `comment`, `rating`) VALUES
(1, 'afcIMuetDuzj', '知識の宝庫で、読み終える頃には少し賢くなった気がした。', 4.5),
(2, 'afcIMuetDuzj', '人生観が変わるほどの深い洞察が詰まっていました。', 3.0),
(3, 'afcIMuetDuzj', '読む手が止まらないほど引き込まれた。', 3.5),
(4, 'afcIMuetDuzj', '心に響く言葉が何度も胸を打った。', 5.0),
(5, 'afcIMuetDuzj', '言葉の美しさに何度もページをめくり直した。', 4.0),
(6, 'afcIMuetDuzj', '想像力をかき立てられる素晴らしいストーリーだった。', 4.5),
(7, 'afcIMuetDuzj', '感動しました。何度も読み直したいと思いました。', 3.0),
(8, 'afcIMuetDuzj', '登場人物に感情移入しすぎて泣いてしまった。', 5.0),
(9, 'afcIMuetDuzj', '終わるのが惜しいほど楽しかった。', 4.5),
(10, 'afcIMuetDuzj', '感動的な結末に、読後の余韻が心地よかった。', 3.5),
(1, '9UizZw491wye', '読み進むにつれドンドン引き込まれていきました。', 3.5),
(2, '9UizZw491wye', '首を長くして待っていました。非常に楽しかったです。', 3.0),
(3, '9UizZw491wye', '読んでいる間、時間を忘れるほど夢中になれました。', 3.0),
(4, '9UizZw491wye', '物語の展開が巧妙で、予想を超える展開が続いて面白かったです。', 3.0),
(1, 'pDYIwtdahwkp', '私もこんな経験をしたいと思いました。', 5.0);

INSERT INTO `favorites` (`user_id`, `book_id`) VALUES
(1, 'afcIMuetDuzj'),
(2, 'afcIMuetDuzj'),
(3, 'afcIMuetDuzj'),
(4, 'afcIMuetDuzj'),
(4, 'pDYIwtdahwkp'),
(5, 'pDYIwtdahwkp'),
(6, 'pDYIwtdahwkp'),
(3, '9UizZw491wye'),
(3, 'ln5NiMJq02V7');

INSERT INTO `bookmarks` (`user_id`, `book_id`, `chapter_number`, `page_number`, `note`) VALUES
(1, 'afcIMuetDuzj', 1, 1, 'もう一度読み直す'),
(3, 'afcIMuetDuzj', 3, 3, 'このページのフレーズが好き'),
(4, 'afcIMuetDuzj', 6, 4, 'この感動を誰かに伝える');

INSERT INTO `book_chapters` (`book_id`, `chapter_number`, `title`) VALUES
('afcIMuetDuzj', 1, 'プロローグ'),
('afcIMuetDuzj', 2, '湖畔の招待状'),
('afcIMuetDuzj', 3, '運命の出会い'),
('afcIMuetDuzj', 4, '舞踏会の奇跡'),
('afcIMuetDuzj', 5, '消えゆく光'),
('afcIMuetDuzj', 6, '新たな誓い'),
('aBcDeFgHiJkL', 1, 'ドラゴンとは何か？'),
('aBcDeFgHiJkL', 2, '世界のドラゴン伝承'),
('aBcDeFgHiJkL', 3, 'ドラゴンと人類の歴史'),
('aBcDeFgHiJkL', 4, 'ドラゴンの姿と能力'),
('aBcDeFgHiJkL', 5, 'ドラゴンと文化・信仰'),
('aBcDeFgHiJkL', 6, 'ドラゴンの科学的解釈と実在の可能性'),
('aBcDeFgHiJkL', 7, '現代社会におけるドラゴンの影響');

LOAD DATA INFILE '/docker-entrypoint-initdb.d/book_content_pages.csv'
INTO TABLE book_content_pages
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n'
(`book_id`, `chapter_number`, `page_number`, `content`);
------------------------------------------------------------
SecurityEndpointsConfig.java

package com.example.my_books_backend.config;

import java.util.List;
import java.util.Arrays;
import org.springframework.stereotype.Component;

@Component
public class SecurityEndpointsConfig {

    public List<String> getFullyPublicEndpoints() {
        return Arrays.asList("/api/v1/login", "/api/v1/signup", "/api/v1/logout",
                "/api/v1/refresh-token", "/v3/api-docs/**", "/swagger-ui/**", "/swagger-ui.html");
    }

    public List<String> getPublicGetEndpoints() {
        return Arrays.asList("/api/v1/genres/**", "/api/v1/books/**");
    }
}

------------------------------------------------------------
AuthController.java

package com.example.my_books_backend.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import com.example.my_books_backend.dto.auth.LoginRequest;
import com.example.my_books_backend.dto.auth.SignupRequest;
import com.example.my_books_backend.dto.auth.AccessTokenResponse;
import com.example.my_books_backend.service.AuthService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class AuthController {
    private final AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<AccessTokenResponse> login(@Valid @RequestBody LoginRequest request,
            HttpServletResponse response) {
        AccessTokenResponse loginResponse = authService.login(request, response);
        return ResponseEntity.ok(loginResponse);
    }

    @PostMapping("/signup")
    public ResponseEntity<AccessTokenResponse> signup(@Valid @RequestBody SignupRequest request,
            HttpServletResponse response) {
        AccessTokenResponse userResponse = authService.signup(request, response);
        return ResponseEntity.ok(userResponse);
    }

    @PostMapping("/logout")
    public ResponseEntity<Void> logout(HttpServletResponse response) {
        authService.logout(response);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<AccessTokenResponse> refreshToken(HttpServletRequest request) {
        AccessTokenResponse accessTokenResponse = authService.refreshAccessToken(request);
        return ResponseEntity.ok(accessTokenResponse);
    }
}

------------------------------------------------------------
BookController.java

package com.example.my_books_backend.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import com.example.my_books_backend.dto.book.BookDetailsResponse;
import com.example.my_books_backend.dto.book.BookPageResponse;
import com.example.my_books_backend.service.BookService;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class BookController {
    private final BookService bookService;

    @GetMapping("/books/{bookId}")
    public ResponseEntity<BookDetailsResponse> getBookDetailsById(@PathVariable String bookId) {
        BookDetailsResponse bookDetailsResponse = bookService.getBookDetailsById(bookId);
        return ResponseEntity.ok(bookDetailsResponse);
    }

    @GetMapping("/books/new-books")
    public ResponseEntity<BookPageResponse> getNewBooks(
            @RequestParam(required = false) Integer page,
            @RequestParam(required = false) Integer maxResults) {
        BookPageResponse bookPageResponse = bookService.getNewBooks(page, maxResults);
        return ResponseEntity.ok(bookPageResponse);
    }

    @GetMapping("/books/search")
    public ResponseEntity<BookPageResponse> getBookPageByTitle(@RequestParam String q,
            @RequestParam(required = false) Integer page,
            @RequestParam(required = false) Integer maxResults) {
        BookPageResponse bookPageResponse = bookService.getBookPageByTitle(q, page, maxResults);
        return ResponseEntity.ok(bookPageResponse);
    }

    @GetMapping("/books/discover")
    public ResponseEntity<BookPageResponse> getBookPageByGenreId(@RequestParam String genreIds,
            @RequestParam String condition, @RequestParam(required = false) Integer page,
            @RequestParam(required = false) Integer maxResults) {
        BookPageResponse bookPageResponse =
                bookService.getBookPageByGenreId(genreIds, condition, page, maxResults);
        return ResponseEntity.ok(bookPageResponse);
    }
}

------------------------------------------------------------
ReviewController.java

package com.example.my_books_backend.controller;

import java.net.URI;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;
import com.example.my_books_backend.dto.review.ReviewPageResponse;
import com.example.my_books_backend.dto.review.ReviewSummaryResponse;
import com.example.my_books_backend.entity.User;
import com.example.my_books_backend.dto.review.ReviewRequest;
import com.example.my_books_backend.dto.review.ReviewResponse;
import com.example.my_books_backend.dto.review.SelfReviewExistsResponse;
import com.example.my_books_backend.service.ReviewService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class ReviewController {
    private final ReviewService reviewService;

    @GetMapping("/books/{bookId}/reviews")
    public ResponseEntity<ReviewPageResponse> getReviewPage(@PathVariable String bookId,
            @RequestParam(required = false) Integer page,
            @RequestParam(required = false) Integer maxResults) {
        ReviewPageResponse reviewPageResponse =
                reviewService.getReviewPage(bookId, page, maxResults);
        return ResponseEntity.ok(reviewPageResponse);
    }

    @GetMapping("/books/{bookId}/reviews/summary")
    public ResponseEntity<ReviewSummaryResponse> getReviewSummary(@PathVariable String bookId) {
        ReviewSummaryResponse reviewSummaryResponse = reviewService.getReviewSummary(bookId);
        return ResponseEntity.ok(reviewSummaryResponse);
    }

    @GetMapping("/reviews/self-review-exists/{bookId}")
    public ResponseEntity<SelfReviewExistsResponse> getSelfReviewExistsByBookId(
            @PathVariable String bookId, @AuthenticationPrincipal User user) {
        Boolean exists = reviewService.getSelfReviewExistsByBookId(bookId, user);
        return ResponseEntity.ok(new SelfReviewExistsResponse(exists));
    }

    @GetMapping("/reviews/{bookId}")
    public ResponseEntity<ReviewResponse> getReviewByBookId(@PathVariable String bookId,
            @AuthenticationPrincipal User user) {
        ReviewResponse reviewResponse = reviewService.getReviewByBookId(bookId, user);
        return ResponseEntity.ok(reviewResponse);
    }

    @GetMapping("/reviews")
    public ResponseEntity<ReviewPageResponse> getReviewPageByUser(
            @RequestParam(required = false) Integer page,
            @RequestParam(required = false) Integer maxResults,
            @AuthenticationPrincipal User user) {
        ReviewPageResponse reviewPageResponse =
                reviewService.getReviewPageByUser(page, maxResults, user);
        return ResponseEntity.ok(reviewPageResponse);
    }

    @PostMapping("/reviews")
    public ResponseEntity<ReviewResponse> createReview(@Valid @RequestBody ReviewRequest request,
            @AuthenticationPrincipal User user) {
        ReviewResponse reviewResponse = reviewService.createReview(request, user);
        URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{bookId}")
                .buildAndExpand(reviewResponse.getBookId()).toUri();
        return ResponseEntity.created(location).body(reviewResponse);
    }

    @PutMapping("/reviews/{id}")
    public ResponseEntity<ReviewResponse> updateReview(@PathVariable Long id,
            @Valid @RequestBody ReviewRequest request, @AuthenticationPrincipal User user) {
        ReviewResponse reviewResponse = reviewService.updateReview(id, request, user);
        return ResponseEntity.ok(reviewResponse);
    }

    @DeleteMapping("/reviews/{id}")
    public ResponseEntity<Void> deleteReview(@PathVariable Long id,
            @AuthenticationPrincipal User user) {
        reviewService.deleteReview(id, user);
        return ResponseEntity.noContent().build();
    }
}

------------------------------------------------------------
BookmarkResponse.java

package com.example.my_books_backend.dto.bookmark;

import java.time.LocalDateTime;
import com.example.my_books_backend.dto.book.BookResponse;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BookmarkResponse {
    private Long id;
    private Long userId;
    private String bookId;
    private Integer chapterNumber;
    private Integer pageNumber;
    private String note;
    private String chapterTitle;
    private LocalDateTime updatedAt;
    private BookResponse book;
}

------------------------------------------------------------
SelfReviewExistsResponse.java

package com.example.my_books_backend.dto.review;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SelfReviewExistsResponse {
    private Boolean exists;
}

------------------------------------------------------------
ChangePasswordRequest.java

package com.example.my_books_backend.dto.user;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;

@Getter
public class ChangePasswordRequest {
    @NotBlank(message = "現在のパスワードは必須です")
    private String currentPassword;

    @NotBlank(message = "新しいパスワードは必須です")
    @Size(min = 4, message = "パスワードは4文字以上で入力してください")
    private String newPassword;

    @NotBlank(message = "確認用パスワードは必須です")
    private String confirmPassword;
}

------------------------------------------------------------
BookmarkRepository.java

package com.example.my_books_backend.repository;

import java.util.List;
import java.util.Optional;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.example.my_books_backend.entity.Book;
import com.example.my_books_backend.entity.Bookmark;
import com.example.my_books_backend.entity.User;

@Repository
public interface BookmarkRepository extends JpaRepository<Bookmark, Long> {
    Page<Bookmark> findByUserAndIsDeletedFalse(User user, Pageable pageable);

    List<Bookmark> findByBookIdAndUserAndIsDeletedFalse(String bookId, User user);

    Optional<Bookmark> findByUserAndBookAndChapterNumberAndPageNumber(User user, Book book,
            Integer chapterNumber, Integer pageNumber);

    Integer countByUserIdAndIsDeletedFalse(Long userId);
}

------------------------------------------------------------
BookRepository.java

package com.example.my_books_backend.repository;

import java.util.List;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import com.example.my_books_backend.entity.Book;

@Repository
public interface BookRepository extends JpaRepository<Book, String> {
        Page<Book> findTop10ByOrderByPublishedDateDesc(Pageable pageable);

        Page<Book> findByTitleContaining(String q, Pageable pageable);

        @Query("SELECT DISTINCT b FROM Book b JOIN b.genres g WHERE g.id IN :genreIds")
        Page<Book> findByGenreIds(@Param("genreIds") List<Long> genreIds, Pageable pageable);

        @Query("""
                        SELECT b FROM Book b
                        JOIN b.genres bg
                        WHERE bg.id IN :genreIds
                        GROUP BY b.id
                        HAVING COUNT(DISTINCT bg.id) = :size
                        """)
        Page<Book> findByAllGenreIds(@Param("genreIds") List<Long> genreIds,
                        @Param("size") long size, Pageable pageable);
}

------------------------------------------------------------
UserRepository.java

package com.example.my_books_backend.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.example.my_books_backend.entity.User;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);

    Boolean existsByEmail(String email);
}

------------------------------------------------------------
BookmarkServiceImpl.java

package com.example.my_books_backend.service.impl;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.example.my_books_backend.dto.bookmark.BookmarkPageResponse;
import com.example.my_books_backend.dto.bookmark.BookmarkRequest;
import com.example.my_books_backend.dto.bookmark.BookmarkResponse;
import com.example.my_books_backend.entity.Book;
import com.example.my_books_backend.entity.BookChapter;
import com.example.my_books_backend.entity.Bookmark;
import com.example.my_books_backend.entity.User;
import com.example.my_books_backend.exception.ConflictException;
import com.example.my_books_backend.exception.ForbiddenException;
import com.example.my_books_backend.exception.NotFoundException;
import com.example.my_books_backend.mapper.BookmarkMapper;
import com.example.my_books_backend.repository.BookChapterRepository;
import com.example.my_books_backend.repository.BookRepository;
import com.example.my_books_backend.repository.BookmarkRepository;
import com.example.my_books_backend.service.BookmarkService;
import com.example.my_books_backend.util.PaginationUtil;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class BookmarkServiceImpl implements BookmarkService {
    private final BookmarkRepository bookmarkRepository;
    private final BookmarkMapper bookmarkMapper;

    private final BookRepository bookRepository;
    private final BookChapterRepository bookChapterRepository;
    private final PaginationUtil paginationUtil;

    private static final Sort DEFAULT_SORT = Sort.by(Sort.Direction.DESC, "updatedAt");

    @Override
    public List<BookmarkResponse> getBookmarksByBookId(String bookId, User user) {
        List<Bookmark> bookmarks =
                bookmarkRepository.findByBookIdAndUserAndIsDeletedFalse(bookId, user);
        List<BookmarkResponse> bookmarkResponses = bookmarkMapper.toBookmarkResponseList(bookmarks);

        // 書籍の目次のタイトルを取得し、章番号とタイトルのマップを作成する
        Map<Integer, String> chapterTitleMap = getChapterTitleMap(bookId);

        // 章番号に対応するタイトルをレスポンスに追加する
        bookmarkResponses.forEach(bookmarkResponse -> {
            String chapterTitle = chapterTitleMap.get(bookmarkResponse.getChapterNumber());
            if (chapterTitle != null) {
                bookmarkResponse.setChapterTitle(chapterTitle);
            }
        });

        return bookmarkResponses;
    }

    // getBookmarksByBookId()で使用するprivateメソッド
    private Map<Integer, String> getChapterTitleMap(String bookId) {
        List<BookChapter> bookChapters = bookChapterRepository.findByBookId(bookId);
        return bookChapters.stream().collect(Collectors.toMap(
                bookChapter -> bookChapter.getId().getChapterNumber(), BookChapter::getTitle));
    }

    @Override
    public BookmarkPageResponse getBookmarkPageByUser(Integer page, Integer maxResults, User user) {
        Pageable pageable = paginationUtil.createPageable(page, maxResults, DEFAULT_SORT);
        Page<Bookmark> bookmarkPage =
                bookmarkRepository.findByUserAndIsDeletedFalse(user, pageable);
        BookmarkPageResponse bookmarkPageResponse =
                bookmarkMapper.toBookmarkPageResponse(bookmarkPage);

        // 書籍の目次のタイトルを取得し、章番号とタイトルのマップを作成する
        Map<String, Map<Integer, String>> bookChapterTitleMaps =
                getBookChapterTitleMaps(bookmarkPage.getContent());

        // 章番号に対応するタイトルをレスポンスに追加する
        bookmarkPageResponse.getBookmarks().forEach(bookmarkResponse -> {
            Map<Integer, String> chapterTitleMap =
                    bookChapterTitleMaps.get(bookmarkResponse.getBook().getId());
            if (chapterTitleMap != null) {
                String chapterTitle = chapterTitleMap.get(bookmarkResponse.getChapterNumber());
                if (chapterTitle != null) {
                    bookmarkResponse.setChapterTitle(chapterTitle);
                }
            }
        });

        return bookmarkPageResponse;
    }

    // getBookmarkPageByUser()で使用するprivateメソッド
    private Map<String, Map<Integer, String>> getBookChapterTitleMaps(List<Bookmark> bookmarks) {
        Set<String> bookIds = bookmarks.stream().map(bookmark -> bookmark.getBook().getId())
                .collect(Collectors.toSet());

        Map<String, Map<Integer, String>> bookChapterTitleMaps = new HashMap<>();
        for (String bookId : bookIds) {
            List<BookChapter> bookChapters = bookChapterRepository.findByBookId(bookId);
            Map<Integer, String> chapterTitleMap = bookChapters.stream().collect(Collectors.toMap(
                    bookChapter -> bookChapter.getId().getChapterNumber(), BookChapter::getTitle));
            bookChapterTitleMaps.put(bookId, chapterTitleMap);
        }

        return bookChapterTitleMaps;
    }

    @Override
    @Transactional
    public BookmarkResponse createBookmark(BookmarkRequest request, User user) {
        Book book = bookRepository.findById(request.getBookId())
                .orElseThrow(() -> new NotFoundException("Book not found"));

        Optional<Bookmark> existingBookmark =
                bookmarkRepository.findByUserAndBookAndChapterNumberAndPageNumber(user, book,
                        request.getChapterNumber(), request.getPageNumber());

        Bookmark bookmark = new Bookmark();
        if (existingBookmark.isPresent()) {
            bookmark = existingBookmark.get();
            if (bookmark.getIsDeleted()) {
                bookmark.setIsDeleted(false);
            } else {
                throw new ConflictException("すでにこのページにはブックマークが登録されています。");
            }
        }
        bookmark.setUser(user);
        bookmark.setBook(book);
        bookmark.setChapterNumber(request.getChapterNumber());
        bookmark.setPageNumber(request.getPageNumber());
        bookmark.setNote(request.getNote());

        Bookmark savedBookmark = bookmarkRepository.save(bookmark);
        return bookmarkMapper.toBookmarkResponse(savedBookmark);
    }

    @Override
    @Transactional
    public BookmarkResponse updateBookmark(Long id, BookmarkRequest request, User user) {
        Bookmark bookmark = bookmarkRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Bookmark not found"));

        if (!bookmark.getUser().getId().equals(user.getId())) {
            throw new ForbiddenException("このブックマークを編集する権限がありません。");
        }

        String note = request.getNote();

        if (note != null) {
            bookmark.setNote(note);
        }

        Bookmark savedBookmark = bookmarkRepository.save(bookmark);
        return bookmarkMapper.toBookmarkResponse(savedBookmark);
    }

    @Override
    @Transactional
    public void deleteBookmark(Long id, User user) {
        Bookmark bookmark = bookmarkRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Bookmark not found"));

        if (!bookmark.getUser().getId().equals(user.getId())) {
            throw new ForbiddenException("このブックマークを削除する権限がありません");
        }

        bookmark.setIsDeleted(true);
        bookmarkRepository.save(bookmark);
    }
}

------------------------------------------------------------
BookServiceImpl.java

package com.example.my_books_backend.service.impl;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import com.example.my_books_backend.dto.genre.GenreResponse;
import com.example.my_books_backend.dto.book.BookDetailsResponse;
import com.example.my_books_backend.dto.book.BookPageResponse;
import com.example.my_books_backend.entity.Book;
import com.example.my_books_backend.entity.Genre;
import com.example.my_books_backend.exception.BadRequestException;
import com.example.my_books_backend.exception.NotFoundException;
import com.example.my_books_backend.mapper.BookMapper;
import com.example.my_books_backend.repository.BookRepository;
import com.example.my_books_backend.service.BookService;
import com.example.my_books_backend.service.GenreService;
import com.example.my_books_backend.util.PaginationUtil;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class BookServiceImpl implements BookService {
    private final BookRepository bookRepository;
    private final BookMapper bookMapper;

    private final PaginationUtil paginationUtil;
    private final GenreService genreService;

    private static final Sort DEFAULT_SORT = Sort.by(Sort.Direction.DESC, "publishedDate");

    @Override
    public BookDetailsResponse getBookDetailsById(String id) {
        Book book = bookRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Book not found"));

        List<GenreResponse> genreResponses = genreService.getAllGenres();

        List<Long> bookGenreIds =
                book.getGenres().stream().map(Genre::getId).collect(Collectors.toList());

        List<GenreResponse> filteredGenres = genreResponses.stream()
                .filter(genreResponse -> bookGenreIds.contains(genreResponse.getId()))
                .collect(Collectors.toList());

        BookDetailsResponse bookDetailsResponse = bookMapper.toBookDetailsResponse(book);

        bookDetailsResponse.setGenres(filteredGenres);

        return bookDetailsResponse;
    }

    @Override
    public BookPageResponse getNewBooks(Integer page, Integer maxResults) {
        Pageable pageable = paginationUtil.createPageable(page, maxResults, DEFAULT_SORT);
        Page<Book> bookPage = bookRepository.findTop10ByOrderByPublishedDateDesc(pageable);
        return bookMapper.toBookPageResponse(bookPage);
    }

    @Override
    public BookPageResponse getBookPageByTitle(String query, Integer page, Integer maxResults) {
        Pageable pageable = paginationUtil.createPageable(page, maxResults, DEFAULT_SORT);
        Page<Book> bookPage = bookRepository.findByTitleContaining(query, pageable);
        return bookMapper.toBookPageResponse(bookPage);
    }

    @Override
    public BookPageResponse getBookPageByGenreId(String genreIdsQuery, String conditionQuery,
            Integer page, Integer maxResults) {
        if (!(conditionQuery.equals("SINGLE") || conditionQuery.equals("AND")
                || conditionQuery.equals("OR"))) {
            throw new BadRequestException("検索条件が不正です。");
        }

        Pageable pageable = paginationUtil.createPageable(page, maxResults, DEFAULT_SORT);

        List<Long> genreIds = Arrays.stream(genreIdsQuery.split(",")).map(Long::parseLong)
                .collect(Collectors.toList());

        Boolean isAndSearch = conditionQuery.equals("AND");

        Page<Book> bookPage =
                isAndSearch ? bookRepository.findByAllGenreIds(genreIds, genreIds.size(), pageable)
                        : bookRepository.findByGenreIds(genreIds, pageable);

        return bookMapper.toBookPageResponse(bookPage);
    }
}

------------------------------------------------------------
ReviewServiceImpl.java

package com.example.my_books_backend.service.impl;

import java.util.List;
import java.util.Optional;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.example.my_books_backend.dto.review.ReviewPageResponse;
import com.example.my_books_backend.dto.review.ReviewSummaryResponse;
import com.example.my_books_backend.dto.review.ReviewRequest;
import com.example.my_books_backend.dto.review.ReviewResponse;
import com.example.my_books_backend.entity.Book;
import com.example.my_books_backend.entity.Review;
import com.example.my_books_backend.entity.User;
import com.example.my_books_backend.exception.ConflictException;
import com.example.my_books_backend.exception.ForbiddenException;
import com.example.my_books_backend.exception.NotFoundException;
import com.example.my_books_backend.mapper.ReviewMapper;
import com.example.my_books_backend.repository.BookRepository;
import com.example.my_books_backend.repository.ReviewRepository;
import com.example.my_books_backend.service.ReviewService;
import com.example.my_books_backend.util.PaginationUtil;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ReviewServiceImpl implements ReviewService {
    private final ReviewRepository reviewRepository;
    private final ReviewMapper reviewMapper;

    private final BookRepository bookRepository;
    private final PaginationUtil paginationUtil;

    private static final Sort DEFAULT_SORT = Sort.by(Sort.Direction.DESC, "updatedAt");

    @Override
    public ReviewPageResponse getReviewPage(String bookId, Integer page, Integer maxResults) {
        Pageable pageable = paginationUtil.createPageable(page, maxResults, DEFAULT_SORT);
        Page<Review> reviewPage = reviewRepository.findByBookIdAndIsDeletedFalse(bookId, pageable);
        return reviewMapper.toReviewPageResponse(reviewPage);
    }

    @Override
    public ReviewSummaryResponse getReviewSummary(String bookId) {
        List<Review> reviews = reviewRepository.findByBookIdAndIsDeletedFalse(bookId);
        Double averageRating =
                reviews.stream().mapToDouble(Review::getRating).average().orElse(0.0);

        ReviewSummaryResponse reviewSummaryResponse = new ReviewSummaryResponse();
        reviewSummaryResponse.setBookId(bookId);
        reviewSummaryResponse.setReviewCount(reviews.size());
        reviewSummaryResponse.setAverageRating(averageRating);

        return reviewSummaryResponse;
    }

    @Override
    public Boolean getSelfReviewExistsByBookId(String bookId, User user) {
        Optional<Review> review =
                reviewRepository.findByBookIdAndUserAndIsDeletedFalse(bookId, user);
        return review.isPresent();
    }

    @Override
    public ReviewResponse getReviewByBookId(String bookId, User user) {
        Review review = reviewRepository.findByBookIdAndUserAndIsDeletedFalse(bookId, user)
                .orElseThrow(() -> new NotFoundException("Review not found"));
        return reviewMapper.toReviewResponse(review);
    }

    @Override
    public ReviewPageResponse getReviewPageByUser(Integer page, Integer maxResults, User user) {
        Pageable pageable = paginationUtil.createPageable(page, maxResults, DEFAULT_SORT);
        Page<Review> reviewPage = reviewRepository.findByUserAndIsDeletedFalse(user, pageable);
        return reviewMapper.toReviewPageResponse(reviewPage);
    }

    @Override
    @Transactional
    public ReviewResponse createReview(ReviewRequest request, User user) {
        Book book = bookRepository.findById(request.getBookId())
                .orElseThrow(() -> new NotFoundException("Book not found"));

        Optional<Review> existingReview = reviewRepository.findByUserAndBook(user, book);

        Review review = new Review();
        if (existingReview.isPresent()) {
            review = existingReview.get();
            if (review.getIsDeleted()) {
                review.setIsDeleted(false);
            } else {
                throw new ConflictException("すでにこの書籍にはレビューが登録されています。");
            }
        }
        review.setUser(user);
        review.setBook(book);
        review.setRating(request.getRating());
        review.setComment(request.getComment());

        Review savedReview = reviewRepository.save(review);
        return reviewMapper.toReviewResponse(savedReview);
    }

    @Override
    @Transactional
    public ReviewResponse updateReview(Long id, ReviewRequest request, User user) {
        Review review = reviewRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Review not found"));

        if (!review.getUser().getId().equals(user.getId())) {
            throw new ForbiddenException("このレビューを編集する権限がありません。");
        }

        String comment = request.getComment();
        Double rating = request.getRating();

        if (comment != null) {
            review.setComment(comment);
        }

        if (rating != null) {
            review.setRating(rating);
        }
        Review savedReview = reviewRepository.save(review);
        return reviewMapper.toReviewResponse(savedReview);
    }

    @Override
    @Transactional
    public void deleteReview(Long id, User user) {
        Review review = reviewRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Review not found"));

        if (!review.getUser().getId().equals(user.getId())) {
            throw new ForbiddenException("このレビューを削除する権限がありません");
        }

        review.setIsDeleted(true);
        reviewRepository.save(review);
    }
}

------------------------------------------------------------
UserServiceImpl.java

package com.example.my_books_backend.service.impl;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.example.my_books_backend.dto.user.ChangeEmailRequest;
import com.example.my_books_backend.dto.user.ChangePasswordRequest;
import com.example.my_books_backend.dto.user.CreateUserRequest;
import com.example.my_books_backend.dto.user.ProfileCountsResponse;
import com.example.my_books_backend.dto.user.UserResponse;
import com.example.my_books_backend.dto.user.UpdateUserRequest;
import com.example.my_books_backend.entity.Role;
import com.example.my_books_backend.entity.RoleName;
import com.example.my_books_backend.entity.User;
import com.example.my_books_backend.exception.ConflictException;
import com.example.my_books_backend.exception.NotFoundException;
import com.example.my_books_backend.exception.UnauthorizedException;
import com.example.my_books_backend.exception.ValidationException;
import com.example.my_books_backend.mapper.UserMapper;
import com.example.my_books_backend.repository.BookmarkRepository;
import com.example.my_books_backend.repository.FavoriteRepository;
import com.example.my_books_backend.repository.ReviewRepository;
import com.example.my_books_backend.repository.RoleRepository;
import com.example.my_books_backend.repository.UserRepository;
import com.example.my_books_backend.service.UserService;
import com.example.my_books_backend.util.RandomStringUtil;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final FavoriteRepository favoriteRepository;
    private final BookmarkRepository bookmarkRepository;
    private final ReviewRepository reviewRepository;

    private final PasswordEncoder passwordEncoder;
    private final UserMapper userMapper;
    private final RandomStringUtil randomStringUtil;

    @Value("${spring.app.defaultAvatarUrl}")
    private String DEFAULT_AVATAR_URL;

    @Override
    public Optional<User> findByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    @Override
    public List<UserResponse> getAllUsers() {
        List<User> users = userRepository.findAll();
        return userMapper.toUserResponseList(users);
    }

    @Override
    public UserResponse getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("User not found"));
        return userMapper.toUserResponse(user);
    }

    @Override
    @Transactional
    public User createUser(CreateUserRequest request) {
        User user = new User();
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        user.setName(request.getName());
        user.setAvatarUrl(request.getAvatarUrl());

        if (user.getRoles() == null) {
            Role role = roleRepository.findByName(RoleName.ROLE_USER);
            user.setRoles(Collections.singletonList(role));
        }

        if (user.getName() == null) {
            String name = "USER_" + randomStringUtil.generateRandomString();
            user.setName(name);
        }

        if (user.getAvatarUrl() == null) {
            String avatarUrl = DEFAULT_AVATAR_URL;
            user.setAvatarUrl(avatarUrl);
        }

        User savedUser = userRepository.save(user);
        return savedUser;
    }

    @Override
    @Transactional
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }

    @Override
    public UserResponse getCurrentUser(User user) {
        return userMapper.toUserResponse(user);
    }

    @Override
    public ProfileCountsResponse getProfileCounts(User user) {
        Integer favoriteCount = favoriteRepository.countByUserId(user.getId());
        Integer bookmarkCount = bookmarkRepository.countByUserIdAndIsDeletedFalse(user.getId());
        Integer reviewCount = reviewRepository.countByUserIdAndIsDeletedFalse(user.getId());

        return new ProfileCountsResponse(favoriteCount, bookmarkCount, reviewCount);
    }

    @Override
    @Transactional
    public void updateCurrentUser(UpdateUserRequest request, User user) {
        String name = request.getName();
        String avatarUrl = request.getAvatarUrl();

        if (name != null) {
            user.setName(name);
        }
        if (avatarUrl != null) {
            user.setAvatarUrl(avatarUrl);
        }
        userRepository.save(user);
    }

    @Override
    @Transactional
    public void changeEmail(ChangeEmailRequest request, User user) {
        String email = request.getEmail();
        String password = request.getPassword();

        if (!passwordEncoder.matches(password, user.getPassword())) {
            throw new UnauthorizedException("パスワードが間違っています。");
        }

        if (userRepository.existsByEmail(email)) {
            throw new ConflictException("このメールアドレスは既に登録されています。: " + email);
        }

        // 本来はここで新しいメールアドレスにメールを送ってメール内のリンクを
        // クリックしてもらうなどで、新しいメールアドレスが本人のものであるか
        // 確認してから、メールアドレスを更新する

        user.setEmail(email);
        userRepository.save(user);
    }

    @Override
    @Transactional
    public void changePassword(ChangePasswordRequest request, User user) {
        String currentPassword = request.getCurrentPassword();
        String newPassword = request.getNewPassword();
        String confirmPassword = request.getConfirmPassword();

        if (!newPassword.equals(confirmPassword)) {
            throw new ValidationException("新しいパスワードと確認用パスワードが一致していません。");
        }

        if (!passwordEncoder.matches(currentPassword, user.getPassword())) {
            throw new UnauthorizedException("現在のパスワードが間違っています。");
        }

        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
    }
}

------------------------------------------------------------
AuthService.java

package com.example.my_books_backend.service;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Service;
import com.example.my_books_backend.dto.auth.LoginRequest;
import com.example.my_books_backend.dto.auth.SignupRequest;
import com.example.my_books_backend.dto.auth.AccessTokenResponse;
import com.example.my_books_backend.dto.user.CreateUserRequest;
import com.example.my_books_backend.entity.User;
import com.example.my_books_backend.exception.ConflictException;
import com.example.my_books_backend.exception.UnauthorizedException;
import com.example.my_books_backend.exception.ValidationException;
import com.example.my_books_backend.repository.UserRepository;
import com.example.my_books_backend.service.impl.UserDetailsServiceImpl;
import com.example.my_books_backend.util.JwtUtil;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AuthService {
    private final AuthenticationManager authenticationManager;
    private final UserRepository userRepository;
    private final UserService userService;
    private final UserDetailsServiceImpl userDetailsService;
    private final JwtUtil jwtUtil;

    public AccessTokenResponse login(LoginRequest request, HttpServletResponse response) {
        Authentication authentication;
        try {
            authentication =
                    authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(
                            request.getEmail(), request.getPassword()));
        } catch (AuthenticationException e) {
            throw new UnauthorizedException("ログインに失敗しました。メールアドレスまたはパスワードが無効です。");
        }

        SecurityContextHolder.getContext().setAuthentication(authentication);
        User user = (User) authentication.getPrincipal();

        String accessToken = jwtUtil.generateAccessToken(user);
        String refreshToken = jwtUtil.generateRefreshToken(user);

        Cookie refreshTokenCookie = jwtUtil.createRefreshTokenCookie(refreshToken);
        response.addCookie(refreshTokenCookie);

        return new AccessTokenResponse(accessToken);
    }

    public AccessTokenResponse signup(SignupRequest request, HttpServletResponse response) {
        String email = request.getEmail();
        String password = request.getPassword();
        String name = request.getName();
        String avatarUrl = request.getAvatarUrl();

        if (userRepository.existsByEmail(email)) {
            throw new ConflictException("サインアップに失敗しました。このメールアドレスは既に登録されています。: " + email);
        }

        CreateUserRequest createUserRequest = new CreateUserRequest();
        createUserRequest.setEmail(email);
        createUserRequest.setPassword(password);
        createUserRequest.setName(name);
        createUserRequest.setAvatarUrl(avatarUrl);

        User user = userService.createUser(createUserRequest);

        String accessToken = jwtUtil.generateAccessToken(user);
        String refreshToken = jwtUtil.generateRefreshToken(user);

        Cookie refreshTokenCookie = jwtUtil.createRefreshTokenCookie(refreshToken);
        response.addCookie(refreshTokenCookie);

        return new AccessTokenResponse(accessToken);
    }

    public void logout(HttpServletResponse response) {
        Cookie cookie = jwtUtil.getInvalidateRefreshTokenCookie();
        response.addCookie(cookie);
    }

    public AccessTokenResponse refreshAccessToken(HttpServletRequest request) {
        String refreshToken = jwtUtil.getRefreshTokenFromCookie(request);

        if (refreshToken == null || !jwtUtil.validateToken(refreshToken)) {
            throw new ValidationException("リフレッシュトークンが無効です。");
        }

        String email = jwtUtil.getSubjectFromToken(refreshToken);
        User user = (User) userDetailsService.loadUserByUsername(email);

        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
        SecurityContextHolder.getContext().setAuthentication(authentication);

        String accessToken = jwtUtil.generateAccessToken(user);
        return new AccessTokenResponse(accessToken);
    }
}

------------------------------------------------------------
BookService.java

package com.example.my_books_backend.service;

import com.example.my_books_backend.dto.book.BookDetailsResponse;
import com.example.my_books_backend.dto.book.BookPageResponse;

public interface BookService {
    BookDetailsResponse getBookDetailsById(String id);

    BookPageResponse getNewBooks(Integer page, Integer maxResults);

    BookPageResponse getBookPageByTitle(String query, Integer page, Integer maxResults);

    BookPageResponse getBookPageByGenreId(String genreIdsQuery, String conditionQuery, Integer page,
            Integer maxResults);
}

------------------------------------------------------------
ReviewService.java

package com.example.my_books_backend.service;

import com.example.my_books_backend.dto.review.ReviewPageResponse;
import com.example.my_books_backend.dto.review.ReviewSummaryResponse;
import com.example.my_books_backend.entity.User;
import com.example.my_books_backend.dto.review.ReviewRequest;
import com.example.my_books_backend.dto.review.ReviewResponse;

public interface ReviewService {
    ReviewPageResponse getReviewPage(String bookId, Integer page, Integer maxResults);

    ReviewSummaryResponse getReviewSummary(String bookId);

    Boolean getSelfReviewExistsByBookId(String bookId, User user);

    ReviewResponse getReviewByBookId(String bookId, User user);

    ReviewPageResponse getReviewPageByUser(Integer page, Integer maxResults, User user);

    ReviewResponse createReview(ReviewRequest request, User user);

    ReviewResponse updateReview(Long id, ReviewRequest request, User user);

    void deleteReview(Long id, User user);
}

------------------------------------------------------------
application.properties

spring.application.name=my-books-backend

spring.jpa.properties.hibernate.hbm2dll.create_namespaces=true
spring.jpa.hibernate.ddl-auto=update
# spring.jpa.show-sql=true
spring.jpa.open-in-view=false

# X-Forwarded-Protoヘッダーを使用して元のプロトコルを認識する
# （リバースプロキシ元がHTTPS通信ならHTTPS通信と認識するため）
server.forward-headers-strategy = native

# DB
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}

# JWT
spring.app.jwtSecret=${SPRING_APP_JWT_SECRET}
# spring.app.jwtAccessExpiration=${SPRING_APP_JWT_ACCESS_EXPIRATION}
# spring.app.jwtRefreshExpiration=${SPRING_APP_JWT_REFRESH_EXPIRATION}
spring.app.jwtAccessExpiration=120
spring.app.jwtRefreshExpiration=180

# ユーザーのデフォルトアバター
spring.app.defaultAvatarUrl=https://localhost/images/avatars/avatar00.png
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------

