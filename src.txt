------------------------------------------------------------
auth-provider

import { sleep } from '@/lib/util';
import { UserInfo } from '@/types/user';
import { createContext, useState } from 'react';

type LoginType = {
  email: string;
  password: string;
};

type AuthContextType = {
  isAuthenticated: boolean;
  isLoading: boolean;
  user: UserInfo | null;
  login: ({ email, password }: LoginType) => Promise<void>;
  logout: () => Promise<void>;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [user, setUser] = useState<UserInfo | null>(null);

  const login = async ({ email, password }: LoginType) => {
    setIsLoading(true);

    console.log('ログイン処理');
    console.log(email, password);

    await sleep(500);

    setUser({
      id: 'xxx',
      name: 'User_xxx',
      email,
      avatarUrl: '/images/avatar00.png',
    });

    setIsAuthenticated(true);
    setIsLoading(false);
  };

  const logout = async () => {
    console.log('ログアウト処理');
    setUser(null);
    setIsAuthenticated(false);
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, isLoading, user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export { AuthContext, AuthProvider };

------------------------------------------------------------
book-detail

import { useAuth } from '@/auth/use-auth';
import ReviewDialog from '@/components/book-detail/review-dialog';
import FavoriteButton from '@/components/favorite-button';
import GenreList from '@/components/genre-list/genre-list';
import MyListButton from '@/components/my-list-button';
import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { formatDate, formatIsbn, priceToString } from '@/lib/util';
import { Book, Genre } from '@/types/book';

type Props = {
  book: Book;
  genres: Genre[];
};

export default function BookDetail({ book, genres }: Props) {
  const { isAuthenticated } = useAuth();
  const genreList = genres.filter((genre) => book.genreIds.includes(genre.id));

  return (
    <>
      <div className="flex flex-col justify-center p-6 pt-10 lg:flex-row">
        <div className="flex flex-col items-center justify-center lg:w-1/2">
          <img
            className="h-[360px] rounded object-cover sm:h-[480px]"
            src={book.imageUrl}
            alt={book.title}
          />
          <div className="my-4 flex items-center">
            <div className="w-20"></div>
            <Button className="w-32 rounded-full" size="lg">
              読む
            </Button>

            <div className="flex w-20 items-center justify-center">
              <Tooltip>
                <TooltipTrigger asChild>
                  <MyListButton />
                </TooltipTrigger>
                {isAuthenticated ? (
                  <TooltipContent>マイリストに追加</TooltipContent>
                ) : (
                  <TooltipContent>
                    ログインしてこの本を「マイリスト」に加えましょう
                  </TooltipContent>
                )}
              </Tooltip>

              <Tooltip>
                <TooltipTrigger asChild>
                  <FavoriteButton book={book} />
                </TooltipTrigger>
                {isAuthenticated ? (
                  <TooltipContent>お気に入りに追加</TooltipContent>
                ) : (
                  <TooltipContent>
                    ログインしてこの本を「お気に入り」に加えましょう
                  </TooltipContent>
                )}
              </Tooltip>
            </div>
          </div>
        </div>

        <div className="p-4 lg:w-1/2">
          <p className="text-3xl font-bold sm:text-4xl">{book.title}</p>
          <div className="my-4 flex w-full flex-wrap items-center justify-end gap-x-3">
            <p>著者</p>
            {book.authors.map((author) => (
              <p className="text-lg font-bold sm:text-2xl" key={author}>
                {author}
              </p>
            ))}
          </div>

          <GenreList className="gap-2" genres={genreList} variant="outline" />

          <div className="my-6 md:my-10">{book.description}</div>

          <div className="flex flex-col justify-between gap-y-4 lg:flex-row">
            <div className="flex flex-col gap-y-1 text-muted-foreground">
              <div className="flex">
                <p className="min-w-20">ISBN</p>
                <p>{formatIsbn(book.isbn)}</p>
              </div>
              <div className="flex">
                <p className="min-w-20">出版社</p>
                <p>{book.publisher}</p>
              </div>
              <div className="flex">
                <p className="min-w-20">発売日</p>
                <p>{formatDate(book.publishedDate)}</p>
              </div>
              <div className="flex">
                <p className="min-w-20">ページ数</p>
                <p>{`${book.pageCount}ページ`}</p>
              </div>
              <div className="flex">
                <p className="min-w-20">価格</p>
                <p>{priceToString(book.price)}</p>
              </div>
            </div>

            <div className="flex flex-col items-center justify-end gap-y-4 sm:items-end">
              <Rating rating={4.5} readOnly />
              <ReviewDialog />
            </div>
          </div>
        </div>
      </div>
    </>
  );
}

------------------------------------------------------------
review-dialog

import { useAuth } from '@/auth/use-auth';
import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import React, { useEffect, useRef, useState } from 'react';

export default function ReviewDialog() {
  const [isOpen, setIsOpen] = useState(false);
  const [rating, setRating] = useState(0);
  const [text, setText] = useState('');
  const ref = useRef<HTMLTextAreaElement | null>(null);
  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();
  const { isAuthenticated } = useAuth();

  useEffect(() => {
    if (isOpen) {
      setRating(0);
    }
  }, [isOpen]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      setText('');
      ref.current?.focus();
    }
  };

  const handlePost = async () => {
    if (rating === 0) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: 'このまま投稿しますか？',
        message: '星の数が「0」のままです。',
      });
      if (isCancel) return;
    }

    toast({ description: 'レビューを投稿しました' });
    setIsOpen(false);
  };

  const handleCloseDialog = async () => {
    if (text) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: '本当に閉じますか？',
        message: '入力されているコメントはまだ投稿していません。',
        persistent: true,
      });
      if (isCancel) return;
    }
    setIsOpen(false);
  };

  return (
    <>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className="rounded-full"
            variant="outline"
            onClick={() => isAuthenticated && setIsOpen(true)}
          >
            レビューを書く
          </Button>
        </TooltipTrigger>
        {!isAuthenticated && (
          <TooltipContent>ログインしてこの本の「レビュー」を書きましょう</TooltipContent>
        )}
      </Tooltip>

      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogContent
          className="w-1/2 min-w-[360px] max-w-[600px] p-4 md:p-6"
          onEscapeKeyDown={handleCloseDialog}
          onPointerDownOutside={handleCloseDialog}
          onAnimationStart={handleAnimationStart}
        >
          <div className="flex items-start justify-between">
            <div>
              <p className="font-semibold leading-10">レビュー</p>
              <p className="text-xs text-muted-foreground md:text-sm">
                素敵な感想を伝えましょう！
              </p>
            </div>
            <div>
              <Rating rating={rating} onChange={setRating} />
              <p className="text-center text-xs text-muted-foreground md:text-sm">
                {rating === 0 ? '星をクリックして決定' : ''}
              </p>
            </div>
          </div>

          <Textarea ref={ref} onChange={(e) => setText(e.currentTarget.value)} />

          <DialogFooter>
            <Button className="rounded-full" variant="ghost" onClick={handleCloseDialog}>
              閉じる
            </Button>
            <Button
              className="rounded-full"
              disabled={text === '' ? true : false}
              onClick={handlePost}
            >
              投稿する
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}

------------------------------------------------------------
book-card

import { useAuth } from '@/auth/use-auth';
import FavoriteButton from '@/components/favorite-button';
import MyListButton from '@/components/my-list-button';
import { Card, CardContent } from '@/components/ui/card';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { Book } from '@/types/book';
import { Link } from 'react-router-dom';

type Props = {
  book: Book;
};

export default function BookCard({ book }: Props) {
  const { isAuthenticated } = useAuth();
  return (
    <>
      <Card>
        <CardContent className="relative flex w-40 flex-col items-center px-3 pb-2 pt-6 sm:w-48 sm:px-4">
          <Link className="flex justify-center" to={`/book/${book.id}`}>
            <img
              className="h-44 rounded object-cover sm:h-52"
              src={book.imageUrl}
              alt={book.title}
            />
          </Link>
          <div className="mt-1 flex w-full items-center justify-between">
            <p className="text-xs text-muted-foreground">{book.publishedDate}</p>
            {isAuthenticated && (
              <div className="flex">
                <Tooltip>
                  <TooltipTrigger asChild>
                    <MyListButton size="sm" />
                  </TooltipTrigger>
                  <TooltipContent>マイリストに追加</TooltipContent>
                </Tooltip>

                <Tooltip>
                  <TooltipTrigger asChild>
                    <FavoriteButton size="sm" book={book} />
                  </TooltipTrigger>
                  <TooltipContent>お気に入りに追加</TooltipContent>
                </Tooltip>
              </div>
            )}
          </div>
          <Link
            className="flex h-8 w-full items-center justify-center text-xs hover:text-primary sm:h-10 sm:text-sm"
            to={`/book/${book.id}`}
          >
            <p className="line-clamp-2 text-center">{book.title}</p>
          </Link>
        </CardContent>
      </Card>
    </>
  );
}

------------------------------------------------------------
hero

import imgUrl from '@/assets/main-visual.png';
import SearchBar from '@/components/search-bar';

export default function Hero() {
  const HERO_MESSAGE =
    '本の探索サイトへようこそ。多様なコレクションから、新しい知識を発見しましょう。厳選された書籍で、あなたの次の読書を見つけてください。知識の旅に一緒に出かけましょう。';

  return (
    <div className="relative mb-8 flex h-[460px] w-full items-center gap-3 sm:mb-0 sm:gap-4 lg:h-[500px]">
      <div className="flex w-3/4 flex-col justify-between lg:w-3/5">
        <div>
          <h1 className="w-fit text-5xl font-bold sm:text-6xl xl:text-7xl">
            Let’s search for <span className="text-primary">Books</span> to discover new
            knowledge.
          </h1>
          <p className="my-6 w-full break-words text-sm text-muted-foreground">
            {HERO_MESSAGE}
          </p>
        </div>
        <div className="flex h-full max-w-96 items-center">
          <SearchBar />
        </div>
      </div>
      <div className="absolute right-0 top-10 -z-10 w-[400px] opacity-40 sm:right-5 sm:w-[400px] lg:w-[450px] lg:opacity-100">
        <img src={imgUrl} alt="main-visual-image" />
      </div>
    </div>
  );
}

------------------------------------------------------------
login-button

import { useAuth } from '@/auth/use-auth';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { MENU_LIST } from '@/constants/constants';
import { useState } from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';

export default function LoginButton() {
  const { isAuthenticated, user, logout } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();

  const [isOpen, setIsOpen] = useState(false);

  const handleClickAvatar = () => {
    setIsOpen(true);
  };

  const handleClickLogin = () => {
    if (!isAuthenticated) {
      console.log(location);

      navigate('/login', { state: { from: location } });
    }
  };

  const handleClickLogout = async () => {
    await logout();
    setIsOpen(false);
    navigate('/login', { state: { from: location } });
  };

  return (
    <>
      {user ? (
        <>
          {isOpen ? (
            <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
              <DropdownMenuTrigger asChild>
                <Avatar className="ml-2 cursor-pointer">
                  <AvatarImage
                    src={user.avatarUrl || '/images/avatar01.png'}
                    alt="avatar-image"
                  />
                  <AvatarFallback>P</AvatarFallback>
                </Avatar>
              </DropdownMenuTrigger>
              <DropdownMenuContent className="w-40 p-2" side="bottom">
                <DropdownMenuLabel>{user.name}</DropdownMenuLabel>
                <DropdownMenuSeparator />
                {MENU_LIST.map((item) => (
                  <Link to={item.href} key={item.href}>
                    <DropdownMenuItem
                      className="my-1 cursor-pointer rounded-full px-4 hover:bg-primary/20 hover:text-primary"
                      onClick={() => setIsOpen(false)}
                    >
                      <span className="text-xs">{item.title}</span>
                    </DropdownMenuItem>
                  </Link>
                ))}
                <DropdownMenuSeparator />
                <DropdownMenuItem
                  className="cursor-pointer rounded-full px-4 hover:bg-primary/20 hover:text-primary"
                  onClick={handleClickLogout}
                >
                  <span className="text-xs">ログアウト</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          ) : (
            <Tooltip>
              <TooltipTrigger asChild>
                <Avatar className="ml-2 cursor-pointer" onClick={handleClickAvatar}>
                  <AvatarImage
                    src={user.avatarUrl || '/images/avatar01.png'}
                    alt="avatar-image"
                  />
                  <AvatarFallback>P</AvatarFallback>
                </Avatar>
              </TooltipTrigger>
              <TooltipContent side="bottom">プロフィールと一般設定</TooltipContent>
            </Tooltip>
          )}
        </>
      ) : (
        <Button className="rounded-full" variant="ghost" onClick={handleClickLogin}>
          ログイン
        </Button>
      )}
    </>
  );
}

------------------------------------------------------------
logo

import { LOGO_TITLE } from '@/constants/constants';
import { cn } from '@/lib/util';
import { Link } from 'react-router-dom';

type Props = {
  size?: 'sm' | 'md' | 'lg';
};

export default function Logo({ size = 'md' }: Props) {
  return (
    <div className="text-primary hover:bg-transparent hover:text-primary/80">
      <Link to="/">
        <h1
          className={cn(
            "font-['Alfa_Slab_One'] tracking-tighter whitespace-nowrap",
            size === 'sm' ? 'text-xl' : size === 'md' ? 'text-3xl' : 'text-5xl'
          )}
        >
          {LOGO_TITLE}
        </h1>
      </Link>
    </div>
  );
}

------------------------------------------------------------
menu-list

import { Button } from '@/components/ui/button';
import { MENU_LIST } from '@/constants/constants';
import { cn } from '@/lib/util';
import { Link, useLocation } from 'react-router-dom';

type Props = {
  onClick?: () => void;
};

export default function MenuList({ onClick }: Props) {
  const location = useLocation();
  const pathname = location.pathname;

  return (
    <ul className="flex flex-col gap-x-0 gap-y-2 md:flex-row">
      {MENU_LIST.map((item) => (
        <li key={item.href}>
          <Link to={item.href}>
            <Button
              className={cn(
                'rounded-full w-full justify-center hover:bg-primary/20 hover:text-primary text-muted-foreground',
                pathname === item.href && 'text-primary underline hover:text-primary'
              )}
              variant="ghost"
              onClick={onClick}
            >
              {item.title}
            </Button>
          </Link>
        </li>
      ))}
    </ul>
  );
}

------------------------------------------------------------
nav-list

import Logo from '@/components/layout/logo';
import MenuList from '@/components/layout/menu-list';
import { Button } from '@/components/ui/button';
import { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet';
import { useWindowSize } from '@/hooks/use-window-size';
import { MenuIcon } from 'lucide-react';
import { useState } from 'react';

export default function NavList() {
  const [isOpen, setIsOpen] = useState(false);
  const { width } = useWindowSize(100);

  if (isOpen && width >= 768) {
    setIsOpen(false);
  }

  return (
    <div>
      <div className="hidden md:flex md:items-center md:gap-x-8">
        <Logo />
        <MenuList />
      </div>

      <Sheet open={isOpen} onOpenChange={setIsOpen}>
        <SheetTrigger asChild>
          <Button className="rounded-full md:hidden" variant="ghost" size="icon">
            <MenuIcon className="size-5" />
          </Button>
        </SheetTrigger>
        <SheetContent className="w-fit p-8" side="left">
          <div className="mb-8" onClick={() => setIsOpen(false)}>
            <Logo />
          </div>
          <MenuList onClick={() => setIsOpen(false)} />
        </SheetContent>
      </Sheet>
    </div>
  );
}

------------------------------------------------------------
review-item

import Rating from '@/components/rating';
import { formatDate } from '@/lib/util';
import { Review } from '@/types/review';

type Props = {
  review: Review;
};

export default function ReviewItem({ review }: Props) {
  return (
    <div>
      <div className="flex flex-col items-center justify-between gap-y-4 p-4 pb-0 sm:flex-row">
        <div className="flex items-center gap-x-4">
          <img
            className="w-16 rounded-full"
            src={review.user.avatarUrl}
            alt="avatar-image"
          />
          <div>
            <p className="text-lg font-semibold">{review.user.name}</p>
            <p className="text-sm text-muted-foreground">
              {formatDate(review.updatedAt)}
            </p>
          </div>
        </div>
        <Rating rating={review.rating} readOnly />
      </div>
      <p className="p-4 text-muted-foreground">{review.comment}</p>
    </div>
  );
}

------------------------------------------------------------
review-list

import ReviewItem from '@/components/review-list/review-item';
import { Review } from '@/types/review';

type Props = {
  reviews: Review[];
};

export default function ReviewList({ reviews }: Props) {
  return (
    <ul className="flex flex-col p-6">
      {reviews.map((review) => (
        <li className="border-t border-t-muted" key={review.id}>
          <ReviewItem review={review} />
        </li>
      ))}
    </ul>
  );
}

------------------------------------------------------------
dialog

import { cn } from '@/lib/util';
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';
import ReactDOM from 'react-dom';

interface DialogContextType {
  isOpen: boolean;
  openDialog: () => void;
  closeDialog: () => void;
}

const DialogContext = React.createContext<DialogContextType | undefined>(undefined);

// ----------------------------------------------------------------------------
// Dialog
// ----------------------------------------------------------------------------
interface DialogProps extends React.DialogHTMLAttributes<HTMLDialogElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const Dialog = ({ children, open, onOpenChange }: DialogProps) => {
  // 外部からのopen状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsのopenが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openDialog = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeDialog = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  return (
    <DialogContext.Provider value={{ isOpen, openDialog, closeDialog }}>
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case DialogTrigger:
            case DialogContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </DialogContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// DialogTrigger
// ----------------------------------------------------------------------------
interface DialogTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const DialogTrigger = React.forwardRef<HTMLButtonElement, DialogTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    const context = useContext(DialogContext);

    if (!context) {
      throw new Error('DialogTrigger must be used within Dialog');
    }

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
        onClick: (e: React.MouseEvent) => {
          if (children.props.onClick) {
            children.props.onClick(e);
          }
          context.openDialog();
        },
      };
      return React.cloneElement(children, { ...mergeChildProps, ref });
    }

    const mergeProps = {
      ...props,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        if (props.onClick) {
          props.onClick(e);
        }
        context.openDialog();
      },
    };

    return (
      <button ref={ref} {...mergeProps}>
        {children}
      </button>
    );
  }
);

// ----------------------------------------------------------------------------
// DialogOverlay
// ----------------------------------------------------------------------------
type DialogOverlayProps = React.HTMLAttributes<HTMLDivElement>;

const DialogOverlay = ({ className, ...props }: DialogOverlayProps) => {
  const context = useContext(DialogContext);

  if (!context) {
    throw new Error('DialogOverlay must be used within Dialog');
  }

  // 閉じるアニメーションが終わった時にopacity:0にする
  // data-[state=closed]でopacity:0へのアニメーションはするが、
  // それが終わるとopacity:1へリセットされてしまい、ちらつくので
  // これを防ぐためにdisplay:'none'にする
  const ref = useRef<HTMLDivElement | null>(null);
  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit' && ref.current) {
      ref.current.style.display = 'none';
    }
  };

  return (
    <div
      ref={ref}
      className={cn(
        'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
        className
      )}
      data-state={context.isOpen ? 'open' : 'closed'}
      {...props}
      onAnimationEnd={handleAnimationEnd}
    ></div>
  );
};

// ----------------------------------------------------------------------------
// DialogContent
// ----------------------------------------------------------------------------
interface DialogContentProps extends React.HTMLAttributes<HTMLDivElement> {
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
}
const DialogContent = ({
  className,
  children,
  onEscapeKeyDown,
  onPointerDownOutside,
  ...props
}: DialogContentProps) => {
  const context = useContext(DialogContext);

  if (!context) {
    throw new Error('DialogContent must be used within Dialog');
  }

  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (context.isOpen) {
      setIsVisible(true);
    }
  }, [context.isOpen]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && context.isOpen) {
        if (onEscapeKeyDown) {
          onEscapeKeyDown();
        } else {
          context.closeDialog();
        }
      }
    };
    const handlePointerDownOutside = (e: MouseEvent) => {
      if (ref.current && !ref.current.contains(e.target as Node)) {
        if (onPointerDownOutside) {
          onPointerDownOutside();
        } else {
          context.closeDialog();
        }
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handlePointerDownOutside);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handlePointerDownOutside);
    };
  }, [context, onEscapeKeyDown, onPointerDownOutside]);

  // 閉じるアニメーションが終わった時にopacity:0にする
  // data-[state=closed]でopacity:0へのアニメーションはするが、
  // それが終わるとopacity:1へリセットされてしまい、ちらつくので
  // これを防ぐためにdisplay:'none'にする
  const ref = useRef<HTMLDivElement | null>(null);
  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit' && ref.current) {
      ref.current.style.display = 'none';
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      if (props.onAnimationEnd) {
        props.onAnimationEnd(e);
      }
      handleAnimationEnd(e);
    },
  };

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <DialogOverlay />
          <div
            ref={ref}
            className={cn(
              'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
              className
            )}
            data-state={context.isOpen ? 'open' : 'closed'}
            {...mergeProps}
          >
            {children}
          </div>
        </>
      )}
    </>,
    document.body
  );
};

// ----------------------------------------------------------------------------
// DialogHeader
// ----------------------------------------------------------------------------
const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col space-y-1.5 text-center sm:text-left', className)}
    {...props}
  />
);

// ----------------------------------------------------------------------------
// DialogFooter
// ----------------------------------------------------------------------------
const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);

// ----------------------------------------------------------------------------
// DialogTitle
// ----------------------------------------------------------------------------
type DialogTitleProps = React.HTMLAttributes<HTMLDivElement>;
const DialogTitle = React.forwardRef<HTMLDivElement, DialogTitleProps>(
  ({ className, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn('text-lg font-semibold leading-none tracking-tight', className)}
        {...props}
      />
    );
  }
);

// ----------------------------------------------------------------------------
// DialogDescription
// ----------------------------------------------------------------------------
type DialogDescriptionProps = React.HTMLAttributes<HTMLDivElement>;
const DialogDescription = React.forwardRef<HTMLDivElement, DialogDescriptionProps>(
  ({ className, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn('text-sm text-muted-foreground', className)}
        {...props}
      />
    );
  }
);

export {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogTitle,
  DialogTrigger,
};

------------------------------------------------------------
dropdown-menu

import { cn } from '@/lib/util';
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';
import ReactDOM from 'react-dom';

type DropdownMenuSideType = 'top' | 'right' | 'bottom' | 'left';

const DEFAULT_SIDE: DropdownMenuSideType = 'top';
const DEFAULT_SIDE_OFFSET = 8;

interface DropdownMenuContextType {
  isOpen: boolean;
  openDropdownMenu: () => void;
  closeDropdownMenu: () => void;
  triggerRef: React.MutableRefObject<HTMLDivElement | null>;
}

const DropdownMenuContext = React.createContext<DropdownMenuContextType | undefined>(
  undefined
);

// ----------------------------------------------------------------------------
// DropdownMenu
// ----------------------------------------------------------------------------
interface DropdownMenuProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const DropdownMenu = ({ children, open, onOpenChange }: DropdownMenuProps) => {
  // 外部からのopen状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsのopenが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openDropdownMenu = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeDropdownMenu = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  const triggerRef = useRef<HTMLDivElement | null>(null);

  return (
    <DropdownMenuContext.Provider
      value={{ isOpen, openDropdownMenu, closeDropdownMenu, triggerRef }}
    >
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case DropdownMenuTrigger:
            case DropdownMenuContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </DropdownMenuContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// DropdownMenuTrigger
// ----------------------------------------------------------------------------
interface DropdownMenuTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const DropdownMenuTrigger = React.forwardRef<HTMLButtonElement, DropdownMenuTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    const context = useContext(DropdownMenuContext);

    if (!context) {
      throw new Error('DropdownMenuContent must be used within DropdownMenu');
    }

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
      };
      return (
        <div ref={context.triggerRef} onPointerDown={context.openDropdownMenu}>
          {React.cloneElement(children, { ...mergeChildProps, ref })}
        </div>
      );
    }

    return (
      <div ref={context.triggerRef} onPointerDown={context.openDropdownMenu}>
        <button ref={ref} {...props}>
          {children}
        </button>
      </div>
    );
  }
);

// ----------------------------------------------------------------------------
// DropdownMenuContent
// ----------------------------------------------------------------------------
interface DropdownMenuContentProps extends React.HTMLAttributes<HTMLDivElement> {
  side?: DropdownMenuSideType;
  sideOffset?: number;
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
}

const DropdownMenuContent = ({
  children,
  className,
  side = DEFAULT_SIDE,
  sideOffset = DEFAULT_SIDE_OFFSET,
  onEscapeKeyDown,
  onPointerDownOutside,
  ...props
}: DropdownMenuContentProps) => {
  const context = useContext(DropdownMenuContext);

  if (!context) {
    throw new Error('DropdownMenuContent must be used within DropdownMenu');
  }

  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (context.isOpen) {
      setIsVisible(true);
    }
  }, [context.isOpen]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && context.isOpen) {
        if (onEscapeKeyDown) {
          onEscapeKeyDown();
        } else {
          context.closeDropdownMenu();
        }
      }
    };
    const handlePointerDownOutside = (e: MouseEvent) => {
      if (ref.current && !ref.current.contains(e.target as Node)) {
        if (onPointerDownOutside) {
          onPointerDownOutside();
        } else {
          context.closeDropdownMenu();
        }
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handlePointerDownOutside);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handlePointerDownOutside);
    };
  }, [context, onEscapeKeyDown, onPointerDownOutside]);

  // 閉じるアニメーションが終わった時にopacity:0にする
  // data-[state=closed]でopacity:0へのアニメーションはするが、
  // それが終わるとopacity:1へリセットされてしまい、ちらつくので
  // これを防ぐためにdisplay:'none'にする
  const ref = useRef<HTMLDivElement | null>(null);
  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit' && ref.current) {
      ref.current.style.display = 'none';
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      if (props.onAnimationEnd) {
        props.onAnimationEnd(e);
      }
      handleAnimationEnd(e);
    },
  };

  const [transformStyle, setTransformStyle] = useState('');

  useEffect(() => {
    // triggerとなる要素からDropdownMenuを表示する座標を計算する
    // （style属性に指定する文字列作成）
    if (context.triggerRef.current) {
      const { left, top, right, bottom, width, height } =
        context.triggerRef.current.getBoundingClientRect();
      const positions = {
        top: {
          x: left + width / 2,
          y: top,
          offset: { x: '-50%', y: `-100% - ${sideOffset}px` },
        },
        bottom: {
          x: left + width / 2,
          y: bottom,
          offset: { x: '-50%', y: `0% + ${sideOffset}px` },
        },
        left: {
          x: left,
          y: top + height / 2,
          offset: { x: `-100% - ${sideOffset}px`, y: '-50%' },
        },
        right: {
          x: right,
          y: top + height / 2,
          offset: { x: `0% + ${sideOffset}px`, y: '-50%' },
        },
      };
      const pos = positions[side];

      setTransformStyle(
        `translate(calc(${pos.x}px + ${pos.offset.x}), calc(${pos.y}px + ${pos.offset.y}))`
      );
    }
  }, [context, context.triggerRef, side, sideOffset]);

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <div className="fixed left-0 top-0 z-50" style={{ transform: transformStyle }}>
            <div
              ref={ref}
              className={cn(
                'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
                className
              )}
              data-state={context.isOpen ? 'open' : 'closed'}
              data-side={side}
              {...mergeProps}
            >
              {children}
            </div>
          </div>
        </>
      )}
    </>,
    document.body
  );
};

// ----------------------------------------------------------------------------
// DropdownMenuItem
// ----------------------------------------------------------------------------
interface DropdownMenuItemProps extends React.HTMLAttributes<HTMLDivElement> {
  inset?: boolean;
}
const DropdownMenuItem = React.forwardRef<HTMLDivElement, DropdownMenuItemProps>(
  ({ className, inset, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        'relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0',
        inset && 'pl-8',
        className
      )}
      {...props}
    />
  )
);

// ----------------------------------------------------------------------------
// DropdownMenuSeparator
// ----------------------------------------------------------------------------
type DropdownMenuSeparatorProps = React.HTMLAttributes<HTMLDivElement>;
const DropdownMenuSeparator = React.forwardRef<
  HTMLDivElement,
  DropdownMenuSeparatorProps
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('-mx-1 my-1 h-px bg-muted', className)} {...props} />
));

// ----------------------------------------------------------------------------
// DropdownMenuLabel
// ----------------------------------------------------------------------------
interface DropdownMenuLabelProps extends React.HTMLAttributes<HTMLDivElement> {
  inset?: boolean;
}
const DropdownMenuLabel = React.forwardRef<
  HTMLDivElement,
  DropdownMenuLabelProps & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold', inset && 'pl-8', className)}
    {...props}
  />
));

export {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
};

------------------------------------------------------------
popover

import { cn } from '@/lib/util';
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';
import ReactDOM from 'react-dom';

type PopoverSideType = 'top' | 'right' | 'bottom' | 'left';

const DEFAULT_SIDE: PopoverSideType = 'top';
const DEFAULT_SIDE_OFFSET = 8;

interface PopoverContextType {
  isOpen: boolean;
  openPopover: () => void;
  closePopover: () => void;
  triggerRef: React.MutableRefObject<HTMLDivElement | null>;
}

const PopoverContext = React.createContext<PopoverContextType | undefined>(undefined);

// ----------------------------------------------------------------------------
// Popover
// ----------------------------------------------------------------------------
interface PopoverProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const Popover = ({ children, open, onOpenChange }: PopoverProps) => {
  // 外部からのopen状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsのopenが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openPopover = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closePopover = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  const triggerRef = useRef<HTMLDivElement | null>(null);

  return (
    <PopoverContext.Provider value={{ isOpen, openPopover, closePopover, triggerRef }}>
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case PopoverTrigger:
            case PopoverContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </PopoverContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// PopoverTrigger
// ----------------------------------------------------------------------------
interface PopoverTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const PopoverTrigger = React.forwardRef<HTMLButtonElement, PopoverTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    const context = useContext(PopoverContext);

    if (!context) {
      throw new Error('PopoverContent must be used within Popover');
    }

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
      };
      return (
        <div ref={context.triggerRef} onPointerDown={context.openPopover}>
          {React.cloneElement(children, { ...mergeChildProps, ref })}
        </div>
      );
    }

    return (
      <div ref={context.triggerRef} onPointerDown={context.openPopover}>
        <button ref={ref} {...props}>
          {children}
        </button>
      </div>
    );
  }
);

// ----------------------------------------------------------------------------
// PopoverContent
// ----------------------------------------------------------------------------
interface PopoverContentProps extends React.HTMLAttributes<HTMLDivElement> {
  side?: PopoverSideType;
  sideOffset?: number;
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
}

const PopoverContent = ({
  children,
  className,
  side = DEFAULT_SIDE,
  sideOffset = DEFAULT_SIDE_OFFSET,
  onEscapeKeyDown,
  onPointerDownOutside,
  ...props
}: PopoverContentProps) => {
  const context = useContext(PopoverContext);

  if (!context) {
    throw new Error('PopoverContent must be used within Popover');
  }

  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (context.isOpen) {
      setIsVisible(true);
    }
  }, [context.isOpen]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && context.isOpen) {
        if (onEscapeKeyDown) {
          onEscapeKeyDown();
        } else {
          context.closePopover();
        }
      }
    };
    const handlePointerDownOutside = (e: MouseEvent) => {
      if (ref.current && !ref.current.contains(e.target as Node)) {
        if (onPointerDownOutside) {
          onPointerDownOutside();
        } else {
          context.closePopover();
        }
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handlePointerDownOutside);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handlePointerDownOutside);
    };
  }, [context, onEscapeKeyDown, onPointerDownOutside]);

  // 閉じるアニメーションが終わった時にopacity:0にする
  // data-[state=closed]でopacity:0へのアニメーションはするが、
  // それが終わるとopacity:1へリセットされてしまい、ちらつくので
  // これを防ぐためにdisplay:'none'にする
  const ref = useRef<HTMLDivElement | null>(null);
  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit' && ref.current) {
      ref.current.style.display = 'none';
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      if (props.onAnimationEnd) {
        props.onAnimationEnd(e);
      }
      handleAnimationEnd(e);
    },
  };

  const [transformStyle, setTransformStyle] = useState('');

  useEffect(() => {
    // triggerとなる要素からPopoverを表示する座標を計算する
    // （style属性に指定する文字列作成）
    if (context.triggerRef.current) {
      const { left, top, right, bottom, width, height } =
        context.triggerRef.current.getBoundingClientRect();
      const positions = {
        top: {
          x: left + width / 2,
          y: top,
          offset: { x: '-50%', y: `-100% - ${sideOffset}px` },
        },
        bottom: {
          x: left + width / 2,
          y: bottom,
          offset: { x: '-50%', y: `0% + ${sideOffset}px` },
        },
        left: {
          x: left,
          y: top + height / 2,
          offset: { x: `-100% - ${sideOffset}px`, y: '-50%' },
        },
        right: {
          x: right,
          y: top + height / 2,
          offset: { x: `0% + ${sideOffset}px`, y: '-50%' },
        },
      };
      const pos = positions[side];

      setTransformStyle(
        `translate(calc(${pos.x}px + ${pos.offset.x}), calc(${pos.y}px + ${pos.offset.y}))`
      );
    }
  }, [context, context.triggerRef, side, sideOffset]);

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <div className="fixed left-0 top-0 z-50" style={{ transform: transformStyle }}>
            <div
              ref={ref}
              className={cn(
                'z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
                className
              )}
              data-state={context.isOpen ? 'open' : 'closed'}
              data-side={side}
              {...mergeProps}
            >
              {children}
            </div>
          </div>
        </>
      )}
    </>,
    document.body
  );
};

export { Popover, PopoverContent, PopoverTrigger };

------------------------------------------------------------
sheet

import { cn } from '@/lib/util';
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';
import ReactDOM from 'react-dom';

type SheetSideType = 'top' | 'right' | 'bottom' | 'left';

const DEFAULT_SIDE: SheetSideType = 'right';

interface SheetContextType {
  isOpen: boolean;
  openSheet: () => void;
  closeSheet: () => void;
}

const SheetContext = React.createContext<SheetContextType | undefined>(undefined);

// ----------------------------------------------------------------------------
// Sheet
// ----------------------------------------------------------------------------
interface SheetProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const Sheet = ({ children, open, onOpenChange }: SheetProps) => {
  // 外部からのopen状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsのopenが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openSheet = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeSheet = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  return (
    <SheetContext.Provider value={{ isOpen, openSheet, closeSheet }}>
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case SheetTrigger:
            case SheetContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </SheetContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// SheetTrigger
// ----------------------------------------------------------------------------
interface SheetTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}
const SheetTrigger = React.forwardRef<HTMLButtonElement, SheetTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    const context = useContext(SheetContext);

    if (!context) {
      throw new Error('SheetTrigger must be used within Sheet');
    }

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
        onClick: (e: React.MouseEvent) => {
          if (children.props.onClick) {
            children.props.onClick(e);
          }
          context.openSheet();
        },
      };
      return React.cloneElement(children, { ...mergeChildProps, ref });
    }

    const mergeProps = {
      ...props,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        if (props.onClick) {
          props.onClick(e);
        }
        context.openSheet();
      },
    };

    return (
      <button ref={ref} {...mergeProps}>
        {children}
      </button>
    );
  }
);

// ----------------------------------------------------------------------------
// SheetOverlay
// ----------------------------------------------------------------------------
type SheetOverlayProps = React.HTMLAttributes<HTMLDivElement>;

const SheetOverlay = ({ className, ...props }: SheetOverlayProps) => {
  const context = useContext(SheetContext);

  if (!context) {
    throw new Error('SheetOverlay must be used within Sheet');
  }

  // 閉じるアニメーションが終わった時にopacity:0にする
  // data-[state=closed]でopacity:0へのアニメーションはするが、
  // それが終わるとopacity:1へリセットされてしまい、ちらつくので
  // これを防ぐためにdisplay:'none'にする
  const ref = useRef<HTMLDivElement | null>(null);
  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit' && ref.current) {
      ref.current.style.display = 'none';
    }
  };

  return (
    <div
      ref={ref}
      className={cn(
        'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
        className
      )}
      data-state={context.isOpen ? 'open' : 'closed'}
      {...props}
      onAnimationEnd={handleAnimationEnd}
    ></div>
  );
};
// ----------------------------------------------------------------------------
// SheetContent
// ----------------------------------------------------------------------------
interface SheetContentProps extends React.HTMLAttributes<HTMLDivElement> {
  side?: SheetSideType;
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
}

const POSITION_LIST = {
  top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
  bottom:
    'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
  left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
  right:
    'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
};

const SheetContent = ({
  className,
  children,
  side = DEFAULT_SIDE,
  onEscapeKeyDown,
  onPointerDownOutside,
  ...props
}: SheetContentProps) => {
  const context = useContext(SheetContext);

  if (!context) {
    throw new Error('SheetContent must be used within Sheet');
  }

  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (context.isOpen) {
      setIsVisible(true);
    }
  }, [context.isOpen]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && context.isOpen) {
        if (onEscapeKeyDown) {
          onEscapeKeyDown();
        } else {
          context.closeSheet();
        }
      }
    };
    const handlePointerDownOutside = (e: MouseEvent) => {
      if (ref.current && !ref.current.contains(e.target as Node)) {
        if (onPointerDownOutside) {
          onPointerDownOutside();
        } else {
          context.closeSheet();
        }
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handlePointerDownOutside);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handlePointerDownOutside);
    };
  }, [context, onEscapeKeyDown, onPointerDownOutside]);

  // 閉じるアニメーションが終わった時にopacity:0にする
  // data-[state=closed]でopacity:0へのアニメーションはするが、
  // それが終わるとopacity:1へリセットされてしまい、ちらつくので
  // これを防ぐためにdisplay:'none'にする
  const ref = useRef<HTMLDivElement | null>(null);
  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit' && ref.current) {
      ref.current.style.display = 'none';
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      if (props.onAnimationEnd) {
        props.onAnimationEnd(e);
      }
      handleAnimationEnd(e);
    },
  };

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <SheetOverlay />
          <div
            ref={ref}
            className={cn(
              'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
              POSITION_LIST[side],
              className
            )}
            data-state={context.isOpen ? 'open' : 'closed'}
            {...mergeProps}
          >
            {children}
          </div>
        </>
      )}
    </>,
    document.body
  );
};

export { Sheet, SheetContent, SheetOverlay, SheetTrigger };

------------------------------------------------------------
tooltip

import { cn } from '@/lib/util';
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';

type TooltipSideType = 'top' | 'right' | 'bottom' | 'left';

const DEFAULT_SIDE: TooltipSideType = 'top';
const DEFAULT_SIDE_OFFSET = 8;

interface TooltipContextType {
  isOpen: boolean;
  openTooltip: () => void;
  closeTooltip: () => void;
  triggerRef: React.MutableRefObject<HTMLDivElement | null>;
}

const TooltipContext = React.createContext<TooltipContextType | undefined>(undefined);

// ----------------------------------------------------------------------------
// Tooltip
// ----------------------------------------------------------------------------
interface TooltipProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const Tooltip = ({ children, open, onOpenChange }: TooltipProps) => {
  // 外部からのopen状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsのopenが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openTooltip = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeTooltip = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  const triggerRef = useRef<HTMLDivElement | null>(null);

  return (
    <TooltipContext.Provider value={{ isOpen, openTooltip, closeTooltip, triggerRef }}>
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case TooltipTrigger:
            case TooltipContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </TooltipContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// TooltipTrigger
// ----------------------------------------------------------------------------
interface TooltipTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const TooltipTrigger = React.forwardRef<HTMLButtonElement, TooltipTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    const context = useContext(TooltipContext);

    if (!context) {
      throw new Error('TooltipContent must be used within Tooltip');
    }

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
      };
      return (
        <div
          ref={context.triggerRef}
          onPointerEnter={context.openTooltip}
          onPointerLeave={context.closeTooltip}
          onPointerDown={context.closeTooltip}
        >
          {React.cloneElement(children, { ...mergeChildProps, ref })}
        </div>
      );
    }

    return (
      <div
        ref={context.triggerRef}
        onPointerEnter={context.openTooltip}
        onPointerLeave={context.closeTooltip}
        onPointerDown={context.closeTooltip}
      >
        <button ref={ref} {...props}>
          {children}
        </button>
      </div>
    );
  }
);

// ----------------------------------------------------------------------------
// TooltipContent
// ----------------------------------------------------------------------------
interface TooltipContentProps extends React.HTMLAttributes<HTMLDivElement> {
  side?: TooltipSideType;
  sideOffset?: number;
}

const TooltipContent = React.forwardRef<HTMLDivElement, TooltipContentProps>(
  (
    {
      children,
      className,
      side = DEFAULT_SIDE,
      sideOffset = DEFAULT_SIDE_OFFSET,
      ...props
    },
    ref
  ) => {
    const context = useContext(TooltipContext);

    if (!context) {
      throw new Error('TooltipContent must be used within Tooltip');
    }

    const [transformStyle, setTransformStyle] = useState('');

    useEffect(() => {
      // triggerとなる要素からTooltipを表示する座標を計算する
      // （style属性に指定する文字列作成）
      if (context.triggerRef.current) {
        const { left, top, right, bottom, width, height } =
          context.triggerRef.current.getBoundingClientRect();
        const positions = {
          top: {
            x: left + width / 2,
            y: top,
            offset: { x: '-50%', y: `-100% - ${sideOffset}px` },
          },
          bottom: {
            x: left + width / 2,
            y: bottom,
            offset: { x: '-50%', y: `0% + ${sideOffset}px` },
          },
          left: {
            x: left,
            y: top + height / 2,
            offset: { x: `-100% - ${sideOffset}px`, y: '-50%' },
          },
          right: {
            x: right,
            y: top + height / 2,
            offset: { x: `0% + ${sideOffset}px`, y: '-50%' },
          },
        };
        const pos = positions[side];

        setTransformStyle(
          `translate(calc(${pos.x}px + ${pos.offset.x}), calc(${pos.y}px + ${pos.offset.y}))`
        );
      }
    }, [context, context.triggerRef, side, sideOffset]);

    return (
      <>
        {context.isOpen && (
          <div className="fixed left-0 top-0 z-50" style={{ transform: transformStyle }}>
            <div
              ref={ref}
              className={cn(
                'z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
                className
              )}
              data-state={context.isOpen ? 'open' : 'closed'}
              data-side={side}
              {...props}
            >
              {children}
            </div>
          </div>
        )}
      </>
    );
  }
);

export { Tooltip, TooltipContent, TooltipTrigger };

------------------------------------------------------------
favorite-button

import { Button } from '@/components/ui/button';
import { cn } from '@/lib/util';
import { Book } from '@/types/book';
import { HeartIcon } from 'lucide-react';

type Props = {
  className?: string;
  size?: 'sm' | 'md' | 'lg';
  book: Book;
};

export default function FavoriteButton({ className, size = 'md', book }: Props) {
  const buttonSize = size === 'sm' ? 'size-6' : size === 'md' ? 'size-8' : '';
  const iconSize = size === 'sm' ? 'size-3' : size === 'md' ? 'size-4' : '';

  // const isFavorite = !book.isFavorite;
  const isFavorite = false;
  return (
    <div className={className}>
      <Button
        className={cn(
          buttonSize,
          'rounded-full text-muted-foreground',
          isFavorite && 'text-primary bg-primary/20'
        )}
        variant="ghost"
        size="icon"
      >
        <HeartIcon
          className={iconSize}
          style={{ fill: isFavorite ? 'hsl(var(--primary))' : '' }}
        />
      </Button>
    </div>
  );
}

------------------------------------------------------------
my-list-button

import { Button } from '@/components/ui/button';
import { cn } from '@/lib/util';
import { ListIcon } from 'lucide-react';

type Props = {
  className?: string;
  size?: 'sm' | 'md' | 'lg';
};

export default function MyListButton({ className, size = 'md' }: Props) {
  const buttonSize = size === 'sm' ? 'size-6' : size === 'md' ? 'size-8' : '';
  const iconSize = size === 'sm' ? 'size-3' : size === 'md' ? 'size-4' : '';
  return (
    <div className={className}>
      <Button
        className={cn(buttonSize, 'rounded-full text-muted-foreground')}
        variant="ghost"
        size="icon"
      >
        <ListIcon className={iconSize} />
      </Button>
    </div>
  );
}

------------------------------------------------------------
constants/constants

// ロゴ
export const LOGO_TITLE = 'My Books';

// メニュー一覧
export const MENU_LIST = [
  { href: '/favorites', title: 'お気に入り' },
  { href: '/my-list', title: 'マイリスト' },
  { href: '/settings', title: '設定' },
];

// API Endpoits
export const BOOKS_API_ENDPOINT = 'http://vsv-emerald/my-books';
// export const BOOKS_API_ENDPOINT = 'http://localhost:18080/my-books';

------------------------------------------------------------
data

// import { getUser } from '@/lib/auth';
// import prisma from '@/lib/db';
import { BOOKS_API_ENDPOINT } from '@/constants/constants';
import { Book, BookResponse, Genre } from '@/types/book';

export const FETCH_BOOKS_MAX_RESULTS = 20;

/**
 * 書籍の検索
 * @param q クエリ文字列
 * @param page? ページ番号のインデックス（0 から開始）
 * @return Promise<BookResponse | undefined>
 */
export const getBooksByQuery = async (q: string | undefined | null, page: number = 0) => {
  if (!q) return undefined;

  const url = `${BOOKS_API_ENDPOINT}/books/search?q=${q}&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
  const res = await fetch(url);

  if (!res.ok) {
    throw new Error(
      `Failed to fetch data from ${url}. HTTP error! status: ${res.status}`
    );
  }

  const bookResponse = (await res.json()) as BookResponse;

  return convertBookResponse(bookResponse);
};

/**
 * １冊分の本の情報を取得
 * @param bookId 取得する書籍のID
 * @return Promise<Book | undefined>
 */
export const getBookById = async (bookId: string | undefined) => {
  if (!bookId) return undefined;

  const url = `${BOOKS_API_ENDPOINT}/books/${bookId}`;
  const res = await fetch(url);

  if (!res.ok) {
    throw new Error(
      `Failed to fetch data from ${url}. HTTP error! status: ${res.status}`
    );
  }

  const book = (await res.json()) as Book;

  return convertBook(book);
};

/**
 * ジャンル一覧の取得
 * @return Promise<Genre[]>
 */
export const getGenres = async () => {
  const url = `${BOOKS_API_ENDPOINT}/genres`;
  const res = await fetch(url);

  if (!res.ok) {
    throw new Error(
      `Failed to fetch data from ${url}. HTTP error! status: ${res.status}`
    );
  }

  const genres = (await res.json()) as Genre[];

  return genres;
};

/**
 * ジャンル検索
 * @param genreIds ジャンルID
 * @param page? ページ番号のインデックス（0 から開始）
 * @return Promise<BookResponse | undefined>
 */
export const getBooksByGenreId = async (
  genreIds: number[] | undefined | null,
  page: number = 0
) => {
  if (!genreIds?.length) return undefined;

  const ids = genreIds.join(',');
  const url = `${BOOKS_API_ENDPOINT}/books/discover?genreId=${ids}&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
  const res = await fetch(url);

  if (!res.ok) {
    throw new Error(
      `Failed to fetch data from ${url}. HTTP error! status: ${res.status}`
    );
  }

  const bookResponse = (await res.json()) as BookResponse;

  return convertBookResponse(bookResponse);
};

/**
 * 最近リリースされた本の情報を取得（１０冊分）
 * @return Promise<Book>
 */
export const getNewReleases = async () => {
  const url = `${BOOKS_API_ENDPOINT}/books/new-releases`;
  const res = await fetch(url);

  if (!res.ok) {
    throw new Error(
      `Failed to fetch data from ${url}. HTTP error! status: ${res.status}`
    );
  }

  const book = (await res.json()) as Book;

  return convertBook(book);
};

/**
 * お気に入り一覧取得
 * @return Book[]
 */
export const fetchFavorites = async () => {
  // const user = getUser();
  // const favorites = await prisma.favoriteBook.findMany({
  //   where: {
  //     userId: user.id,
  //   },
  //   orderBy: {
  //     createdAt: 'desc',
  //   },
  // });
  // const books = favorites.map((favorite) => ({
  //   id: favorite.bookId,
  //   title: favorite.title,
  //   imageUrl: favorite.imageUrl,
  //   authors: [],
  //   publisher: '',
  //   publishedDate: '',
  //   description: '',
  //   webReaderLink: '',
  //   pageCount: 0,
  //   price: 0,
  //   isFavorite: true,
  // }));
  // return books;
};

/**
 * 閲覧履歴一覧取得
 * @return Book[]
 */
export const getBrowsingHistory = async () => {
  // const user = getUser();
  // const histories = await prisma.bookBrowsingHistory.findMany({
  //   where: {
  //     userId: user.id,
  //   },
  //   orderBy: {
  //     createdAt: 'desc',
  //   },
  // });
  // const favorites = await prisma.favoriteBook.findMany({
  //   where: {
  //     userId: user.id,
  //   },
  //   select: {
  //     bookId: true,
  //   },
  // });
  // const books = histories.map((history) => ({
  //   id: history.bookId,
  //   title: history.title,
  //   imageUrl: history.imageUrl,
  //   authors: [],
  //   publisher: '',
  //   publishedDate: '',
  //   description: '',
  //   webReaderLink: '',
  //   pageCount: 0,
  //   price: 0,
  //   isFavorite: favorites.find((favorite) => favorite.bookId === history.bookId)
  //     ? true
  //     : false,
  // }));
  // return books;
};

const convertBook = (book: Book) => {
  book.imageUrl = book.imageUrl ?? '/images/no-image.png';
  return book;
};

const convertBookResponse = (bookResponse: BookResponse) => {
  bookResponse.books.forEach((book) => convertBook(book));
  return bookResponse;
};

------------------------------------------------------------
util

import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
/**
 * sleep関数
 * @param msec ミリ秒
 *
 * await sleep(3000);  // ３秒待つ
 */
export const sleep = (msec: number) =>
  new Promise((resolve) => setTimeout(resolve, msec));

/**
 * yyyy-MM-dd形式の文字列をyyyy年MM月dd日へ変換
 * @param dateString yyyy-MM-dd形式の文字列
 * @returns yyyy年MM月dd日の文字列
 */
export const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();

  let formattedDate = `${year}年`;
  if (month) formattedDate += `${month}月`;
  if (day) formattedDate += `${day}日`;

  return formattedDate;
};

/**
 * 価格をカンマ区切り数字文字列へ変換
 * @param price 価格
 * @returns カンマ区切り数字文字列
 */
export const priceToString = (price: number) => {
  return price === 0 ? '-' : `${Number(price).toLocaleString()}円`;
};

/**
 * ISBNの文字列をハイフンを含めたISBN文字列へ変換
 * @param isbn isbn文字列
 * @returns ハイフンを含めたISBN文字列
 */
export const formatIsbn = (isbnString: string) => {
  const country = isbnString.slice(0, 3);
  const area = isbnString.slice(3, 4);
  const publisher = isbnString.slice(4, 7);
  const book = isbnString.slice(7, 12);
  const check = isbnString.slice(12, 13);

  return country + '-' + area + '-' + publisher + '-' + book + '-' + check;
};

------------------------------------------------------------
routes/book/[bookId]

import BookDetail from '@/components/book-detail/book-detail';
import BookDetailSkeleton from '@/components/book-detail/book-detail-skeleton';
import ReviewList from '@/components/review-list/review-list';
import ReviewListSkeleton from '@/components/review-list/review-list-skeleton';
import { getBookById, getGenres } from '@/lib/data';
import ErrorElement from '@/routes/error-element';
import { Book, Genre } from '@/types/book';
import { Review } from '@/types/review';
import { Suspense } from 'react';
import {
  Await,
  LoaderFunctionArgs,
  ScrollRestoration,
  useLoaderData,
} from 'react-router-dom';

type LoaderFunctionReturnType = {
  genres: Genre[];
  book: Promise<Book>;
  reviews: Promise<Review[]>;
};

const loader = async ({ params }: LoaderFunctionArgs) => {
  const genres = await getGenres();
  const book = getBookById(params.bookId);

  const reviews: Review[] = [
    {
      id: 1,
      bookId: '',
      comment:
        'Lorem ipsum dolor sit amet consectetur adipisicing elit. Nisi velit harum facilis illo sint, est quos eveniet, sapiente dolor placeat tempore minus maxime laboriosam, aliquid eaque ad? Aut, quam corrupti.',
      rating: 4.5,
      updatedAt: '2024-12-24',
      user: {
        id: 'abc',
        name: 'Julia',
        email: 'xxx@example.jp',
        avatarUrl: '/images/avatar02.png',
      },
    },
    {
      id: 2,
      bookId: '',
      comment: 'すごく面白かったです',
      rating: 5.0,
      updatedAt: '2023-01-05',
      user: {
        id: 'def',
        name: '山田 太郎',
        email: 'xxx@example.jp',
        avatarUrl: '/images/avatar03.png',
      },
    },
    {
      id: 3,
      bookId: '',
      comment: 'まさかこんな展開になるとは。。最後までハラハラドキドキしました。',
      rating: 3.5,
      updatedAt: '2022-08-29',
      user: {
        id: 'xyz',
        name: 'Lili',
        email: 'xxx@example.jp',
        avatarUrl: '/images/avatar06.png',
      },
    },
  ];

  const ret = new Promise((resolve) => {
    setTimeout(() => {
      resolve(reviews);
    }, 2000);
  });

  return { book, genres, reviews: ret };
};

export default function Page() {
  const { book, genres, reviews } = useLoaderData() as LoaderFunctionReturnType;

  return (
    <>
      <Suspense fallback={<BookDetailSkeleton />}>
        <Await resolve={book} errorElement={<ErrorElement />}>
          {(book) => <BookDetail book={book} genres={genres} />}
        </Await>
      </Suspense>

      <div className="mx-auto w-full lg:w-3/4">
        <Suspense fallback={<ReviewListSkeleton />}>
          <Await resolve={reviews} errorElement={<ErrorElement />}>
            {(reviews) => <ReviewList reviews={reviews} />}
          </Await>
        </Suspense>
      </div>

      <ScrollRestoration />
    </>
  );
}

Page.loader = loader;

------------------------------------------------------------
discover

import BookList from '@/components/book-list/book-list';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import BookPagination from '@/components/book-list/book-pagination';
import { getBooksByGenreId, getGenres } from '@/lib/data';
import ErrorElement from '@/routes/error-element';
import { BookResponse, Genre } from '@/types/book';
import { Suspense } from 'react';
import {
  Await,
  defer,
  LoaderFunctionArgs,
  ScrollRestoration,
  useLoaderData,
} from 'react-router-dom';

type LoaderFunctionReturnType = {
  bookResponse: Promise<BookResponse>;
  genres: Genre[];
  genreIds: number[];
};

const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const ids = url.searchParams.get('genreId');

  const genreIds = ids?.split(',').map((id) => Number(id));
  const page = Number(url.searchParams.get('page') ?? '1');

  const bookResponse = getBooksByGenreId(genreIds, page - 1);
  const genres = await getGenres();

  return defer({ bookResponse, genres, genreIds });
};

export default function Page() {
  const { bookResponse, genres, genreIds } = useLoaderData() as LoaderFunctionReturnType;

  const genreString = genres
    .filter((genre) => genreIds.includes(genre.id))
    .map((genre) => genre.name)
    .join(' & ');

  return (
    <>
      <p className="my-2">
        {`「 ${genreString} 」`}
        <span className="text-sm text-muted-foreground">のジャンル</span>
      </p>

      <div className="flex flex-col gap-y-4 pb-4">
        <Suspense fallback={<BookListSkeleton />}>
          <Await resolve={bookResponse} errorElement={<ErrorElement />}>
            {(bookResponse: BookResponse) => (
              <>
                <BookPagination totalPages={bookResponse.totalPages} />
                <BookList books={bookResponse.books} />
                <BookPagination totalPages={bookResponse.totalPages} />
              </>
            )}
          </Await>
        </Suspense>
      </div>

      <ScrollRestoration />
    </>
  );
}

Page.loader = loader;

------------------------------------------------------------
login

import { useAuth } from '@/auth/use-auth';
import Logo from '@/components/layout/logo';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { EyeIcon, EyeOffIcon, Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';

export default function Page() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isShownPassword, setIsShownPassword] = useState(false);
  const ref = useRef<HTMLInputElement | null>(null);

  const location = useLocation();
  const navigate = useNavigate();
  const { isLoading, login } = useAuth();

  useEffect(() => {
    ref.current?.focus();
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    await login({ email, password });

    const pathname = location.state?.from?.pathname || '/';
    const query = location.state?.from?.search || '';
    navigate(pathname + query, { replace: true });
  };

  return (
    <div className="">
      <div className="mt-6 flex flex-col items-center justify-items-center gap-y-4 sm:mt-16">
        <Logo size="lg" />
        <p className="font-semibold">ログイン</p>
        <Card className="rounded-3xl">
          <CardContent className="p-6">
            <form className="flex w-72 flex-col gap-y-4" onSubmit={handleSubmit}>
              <div>
                <p className="text-xs">メールアドレス</p>
                <Input
                  className="my-2 rounded-full"
                  value={email}
                  ref={ref}
                  name="email"
                  autoComplete="off"
                  onChange={(e) => setEmail(e.target.value)}
                />
              </div>
              <div>
                <p className="text-xs">パスワード</p>
                <div className="relative">
                  <Input
                    className="my-2 rounded-full"
                    type={isShownPassword ? 'text' : 'password'}
                    value={password}
                    name="password"
                    onChange={(e) => setPassword(e.target.value)}
                  />
                  <Button
                    className="absolute right-0 top-0 rounded-full hover:bg-transparent hover:text-foreground"
                    variant="ghost"
                    size="icon"
                    type="button"
                    onClick={() => setIsShownPassword(!isShownPassword)}
                  >
                    {isShownPassword ? (
                      <EyeIcon className="size-4" />
                    ) : (
                      <EyeOffIcon className="size-4" />
                    )}
                  </Button>
                </div>
              </div>
              <Button
                className="mt-6 w-full rounded-full"
                type="submit"
                disabled={isLoading}
              >
                {isLoading ? <Loader2Icon className="animate-spin" /> : 'ログイン'}
              </Button>
            </form>

            <div className="mt-6 flex justify-center gap-x-1 text-xs">
              <p className="text-muted-foreground">アカウントをお持ちでない方はこちら</p>
              <Link to={'/sign-up'}>
                <p className="text-primary hover:underline">新規登録</p>
              </Link>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

------------------------------------------------------------
my-list
------------------------------------------------------------
search

import BookList from '@/components/book-list/book-list';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import BookPagination from '@/components/book-list/book-pagination';
import { getBooksByQuery } from '@/lib/data';
import ErrorElement from '@/routes/error-element';
import { BookResponse } from '@/types/book';
import { Suspense } from 'react';
import {
  Await,
  LoaderFunctionArgs,
  ScrollRestoration,
  useLoaderData,
} from 'react-router-dom';

type LoaderFunctionReturnType = {
  bookResponse: Promise<BookResponse>;
  query: string;
  page: number;
};

const loader = ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const query = url.searchParams.get('q');

  const page = Number(url.searchParams.get('page') ?? '1');
  const bookResponse = getBooksByQuery(query, page - 1);

  return { bookResponse, query, page };
};

export default function Page() {
  const { bookResponse, query } = useLoaderData() as LoaderFunctionReturnType;

  return (
    <>
      <p className="my-2">
        {`「 ${query} 」`}
        <span className="text-sm text-muted-foreground">の検索結果</span>
      </p>

      <div className="flex flex-col gap-y-4 pb-4">
        <Suspense fallback={<BookListSkeleton />}>
          <Await resolve={bookResponse} errorElement={<ErrorElement />}>
            {(bookResponse: BookResponse) => (
              <>
                <BookPagination totalPages={bookResponse.totalPages} />
                <BookList books={bookResponse.books} />
                <BookPagination totalPages={bookResponse.totalPages} />
              </>
            )}
          </Await>
        </Suspense>
      </div>

      <ScrollRestoration />
    </>
  );
}

Page.loader = loader;

------------------------------------------------------------
sign-up

import Logo from '@/components/layout/logo';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { EyeIcon, EyeOffIcon } from 'lucide-react';
import { useEffect, useRef, useState } from 'react';
import { Link } from 'react-router-dom';

export default function Page() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isShownPassword, setIsShownPassword] = useState(false);
  const ref = useRef<HTMLInputElement | null>(null);

  useEffect(() => {
    ref.current?.focus();
  }, []);

  return (
    <div className="">
      <div className="mt-6 flex flex-col items-center justify-items-center gap-y-4 sm:mt-16">
        <Logo size="lg" />
        <p className="font-semibold">アカウントの作成</p>
        <Card>
          <CardContent className="p-6">
            <form className="flex w-64 flex-col gap-y-4" action="">
              <div>
                <p className="text-xs">メールアドレス</p>
                <Input
                  className="my-2 rounded-full"
                  value={email}
                  ref={ref}
                  onChange={(e) => setEmail(e.target.value)}
                />
                {/* <p className="text-xs">error</p> */}
              </div>
              <div>
                <p className="text-xs">パスワード</p>
                <div className="relative">
                  <Input
                    className="my-2 rounded-full"
                    type={isShownPassword ? 'text' : 'password'}
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                  />
                  <Button
                    className="absolute right-0 top-0 rounded-full hover:bg-transparent hover:text-foreground"
                    variant="ghost"
                    size="icon"
                    type="button"
                    onClick={() => setIsShownPassword(!isShownPassword)}
                  >
                    {isShownPassword ? (
                      <EyeIcon className="size-4" />
                    ) : (
                      <EyeOffIcon className="size-4" />
                    )}
                  </Button>
                  {/* <p className="text-xs">error</p> */}
                </div>
              </div>
              <Button className="mt-6 w-full rounded-full" type="submit">
                新規登録
              </Button>
            </form>
            <div className="mt-6 flex justify-center gap-x-1 text-xs">
              <p className="text-muted-foreground">アカウントをお持ちですか？</p>
              <Link to={'/login'}>
                <p className="text-primary hover:underline">ログイン</p>
              </Link>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

------------------------------------------------------------
route

import { ProtectedRoute } from '@/auth/protected-route';
import BookIdPage from '@/routes/book/[bookId]/page';
import DiscoverPage from '@/routes/discover/page';
import FavoritesPage from '@/routes/favorite/page';
import RootLayout from '@/routes/layout';
import LoginPage from '@/routes/login/page';
import MyListPage from '@/routes/my-list/page';
import RootPage from '@/routes/page';
import SearchPage from '@/routes/search/page';
import SettingsPage from '@/routes/settings/page';
import SignUpPage from '@/routes/sign-up/page';
import { createBrowserRouter, createRoutesFromElements, Route } from 'react-router-dom';

export const router = createBrowserRouter(
  createRoutesFromElements(
    <Route>
      <Route path="/" element={<RootLayout />}>
        <Route index element={<RootPage />} loader={RootPage.loader} />

        <Route path="book">
          <Route path=":bookId" element={<BookIdPage />} loader={BookIdPage.loader} />
        </Route>

        <Route path="search">
          <Route index element={<SearchPage />} loader={SearchPage.loader} />
        </Route>

        <Route path="discover">
          <Route index element={<DiscoverPage />} loader={DiscoverPage.loader} />
        </Route>

        <Route path="login">
          <Route index element={<LoginPage />} />
        </Route>

        <Route path="sign-up">
          <Route index element={<SignUpPage />} />
        </Route>

        <Route element={<ProtectedRoute />}>
          <Route path="favorites">
            <Route index element={<FavoritesPage />} />
          </Route>

          <Route path="my-list">
            <Route index element={<MyListPage />} />
          </Route>

          <Route path="settings">
            <Route index element={<SettingsPage />} />
          </Route>
        </Route>
      </Route>
    </Route>
  )
);

------------------------------------------------------------
types/book

export interface Book {
  id: string;
  title: string;
  description: string;
  genreIds: number[];
  authors: string[];
  publisher: string;
  publishedDate: string;
  price: number;
  pageCount: number;
  isbn: string;
  imageUrl: string;
}

export interface BookResponse {
  page: number;
  totalPages: number;
  totalItems: number;
  books: Book[];
}

export interface Genre {
  id: number;
  name: string;
}

------------------------------------------------------------
review

import { UserInfo } from '@/types/user';

export interface Review {
  id: number;
  bookId: string;
  comment: string;
  rating: number;
  updatedAt: string;
  user: UserInfo;
}

------------------------------------------------------------
user

export interface UserInfo {
  id: string;
  name: string;
  email: string;
  avatarUrl: string;
}

------------------------------------------------------------
------------------------------------------------------------
