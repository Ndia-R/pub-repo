

# 要望内容

1. 書籍検索アプリのバックエンドをSpring Bootで実装している。
2. 書籍を評価点順に並び替えたい。
3. リポジトリのJPA的な記述ではうまくいかないため、どのように実装すればよいか。
4. エンドポイントの指定として以下のようなURLが動作することを確認したい

- https://xxx.com/api/v1/books/search?q=タイトル&sort=rating.DESC
- https://xxx.com/api/v1/books/search?q=タイトル&sort=title.ASC
- https://xxx.com/api/v1/books/search?q=タイトル&sort=updatedAt.DESC

5. 全体のデータをソートした後にページングを適用すること。

# 現在の実装

- リポジトリ：BookRepository.javaにカスタムクエリを追加している。
- サービス：BookService.javaでデータを取得し、DTOに変換している。
- コントローラー：BookController.javaでサービスを呼び出して結果を返している。
- ページネーションUtil：PageableUtil.javaで評価点順のソートをサポートしている。

# 目標

- 全体のデータをソートした後にページングを適用する。
- 評価点順のソートをサポートしつつ、他のフィールドでのソートも可能にする。


以下、実装内容です。


エンティティ
--------------------------------------------------------------------------------
package com.example.my_books_backend.entity;

import java.sql.Date;
import java.util.List;
import com.example.my_books_backend.entity.shared.EntityBase;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "books")
@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
public class Book extends EntityBase {
    @Id
    @Column(name = "id", nullable = false)
    private String id;

    @Column(name = "title", nullable = false)
    private String title;

    @Column(name = "description", nullable = false, columnDefinition = "TEXT")
    private String description;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "book_genres", joinColumns = @JoinColumn(name = "book_id"),
            inverseJoinColumns = @JoinColumn(name = "genre_id"))
    private List<Genre> genres;

    @Column(name = "authors", nullable = false)
    private String authors;

    @Column(name = "publisher", nullable = false)
    private String publisher;

    @Column(name = "publication_date", nullable = false)
    private Date publicationDate;

    @Column(name = "price", nullable = false)
    private Integer price;

    @Column(name = "page_count", nullable = false)
    private Integer pageCount;

    @Column(name = "isbn", nullable = false)
    private String isbn;

    @Column(name = "image_path")
    private String imagePath;

    @OneToMany(mappedBy = "book")
    private List<Review> reviews;

    @OneToMany(mappedBy = "book")
    private List<Favorite> favorites;

    @OneToMany(mappedBy = "book")
    private List<Bookmark> bookmarks;
}
```

DTO
--------------------------------------------------------------------------------
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BookResponse {
    private String id;
    private String title;
    private String description;
    private List<Long> genreIds;
    private List<String> authors;
    private Date publicationDate;
    private String imagePath;
    private Integer reviewCount;
    private Double averageRating;
}

リポジトリ
--------------------------------------------------------------------------------

@Repository
public interface BookRepository extends JpaRepository<Book, String> {
    @Query("SELECT b, AVG(r.rating) as avgRating, COUNT(r) as reviewCount " +
           "FROM Book b LEFT JOIN b.reviews r " +
           "WHERE b.title LIKE %:keyword% AND b.isDeleted = false " +
           "GROUP BY b.id " +
           "ORDER BY avgRating DESC")
    Page<Object[]> findByTitleContainingAndIsDeletedFalseOrderByRatingDesc(@Param("keyword") String keyword, Pageable pageable);
}

サービス
--------------------------------------------------------------------------------
@Service
@RequiredArgsConstructor
public class BookService {
    private final BookRepository bookRepository;

    public PageResponse<BookResponse> getBooksByTitleKeyword(String keyword, Pageable pageable) {
        Page<Object[]> booksPage = bookRepository.findByTitleContainingAndIsDeletedFalseOrderByRatingDesc(keyword, pageable);

        List<BookResponse> bookResponses = booksPage.getContent().stream()
                .map(this::convertToBookResponse)
                .collect(Collectors.toList());

        return new PageResponse<>(bookResponses, booksPage.getNumber(), booksPage.getSize(), booksPage.getTotalElements());
    }

    private BookResponse convertToBookResponse(Object[] result) {
        Book book = (Book) result[0];
        Double averageRating = (Double) result[1];
        Long reviewCount = (Long) result[2];

        return new BookResponse(
                book.getId(),
                book.getTitle(),
                book.getDescription(),
                book.getGenres().stream().map(Genre::getId).collect(Collectors.toList()),
                Arrays.asList(book.getAuthors().split(",")),
                book.getPublicationDate(),
                book.getImagePath(),
                reviewCount.intValue(),
                averageRating
        );
    }
}

コントローラー
--------------------------------------------------------------------------------
@RestController
@RequestMapping("/books")
@RequiredArgsConstructor
public class BookController {
    private final BookService bookService;
    private final ReviewService reviewService;
    private final FavoriteService favoriteService;
    
    private static final int DEFAULT_BOOKS_PAGE_SIZE = 20;

    // タイトル検索
    @GetMapping("/search")
    public ResponseEntity<PageResponse<BookResponse>> getBooksByTitleKeyword(
            @RequestParam String q,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = DEFAULT_BOOKS_PAGE_SIZE) int size,
            @RequestParam(defaultValue = "title.ASC") String sort) {
        
        Pageable pageable = PageableUtil.createPageable(page, size, sort);
        PageResponse<BookResponse> response = bookService.getBooksByTitleKeyword(q, pageable);
        return ResponseEntity.ok(response);
    }
}

ページネーションUtil
--------------------------------------------------------------------------------

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class PageableUtil {

    private static final List<String> ALLOWED_FIELDS = Arrays.asList("title", "updatedAt", "createdAt", "population", "rating");

    public static Pageable createPageable(int page, int size, String sort) {
        String[] sortParams = sort.split("\\.");
        if (sortParams.length != 2) {
            throw new IllegalArgumentException("Invalid sort parameter");
        }

        String sortField = sortParams[0];
        Sort.Direction sortDirection;
        try {
            sortDirection = Sort.Direction.fromString(sortParams[1]);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid sort direction");
        }

        if (!ALLOWED_FIELDS.contains(sortField)) {
            throw new IllegalArgumentException("Invalid sort field");
        }

        return PageRequest.of(page, size, Sort.by(sortDirection, sortField));
    }
}



# 1. Book.java - 評価点フィールド追加
package com.example.my_books_backend.entity;

import java.sql.Date;
import java.util.List;
import com.example.my_books_backend.entity.shared.EntityBase;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "books")
@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
public class Book extends EntityBase {
    @Id
    @Column(name = "id", nullable = false)
    private String id;

    @Column(name = "title", nullable = false)
    private String title;

    @Column(name = "description", nullable = false, columnDefinition = "TEXT")
    private String description;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "book_genres", joinColumns = @JoinColumn(name = "book_id"),
            inverseJoinColumns = @JoinColumn(name = "genre_id"))
    private List<Genre> genres;

    @Column(name = "authors", nullable = false)
    private String authors;

    @Column(name = "publisher", nullable = false)
    private String publisher;

    @Column(name = "publication_date", nullable = false)
    private Date publicationDate;

    @Column(name = "price", nullable = false)
    private Integer price;

    @Column(name = "page_count", nullable = false)
    private Integer pageCount;

    @Column(name = "isbn", nullable = false)
    private String isbn;

    @Column(name = "image_path")
    private String imagePath;

    // 事前計算された評価データ
    @Column(name = "average_rating", nullable = false, columnDefinition = "DECIMAL(3,2) DEFAULT 0.00")
    private Double averageRating = 0.0;

    @Column(name = "review_count", nullable = false, columnDefinition = "INT DEFAULT 0")
    private Integer reviewCount = 0;

    @Version
    @Column(name = "version")
    private Long version; // 楽観的ロック用

    @OneToMany(mappedBy = "book")
    private List<Review> reviews;

    @OneToMany(mappedBy = "book")
    private List<Favorite> favorites;

    @OneToMany(mappedBy = "book")
    private List<Bookmark> bookmarks;
}

# 2. BookRepository.java - シンプルなクエリ
package com.example.my_books_backend.repository;

import com.example.my_books_backend.entity.Book;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface BookRepository extends JpaRepository<Book, String> {
    
    // シンプルなクエリ - 事前計算された値を使用
    @Query("SELECT b FROM Book b " +
           "WHERE b.title LIKE %:keyword% AND b.isDeleted = false")
    Page<Book> findByTitleContainingAndIsDeletedFalse(@Param("keyword") String keyword, Pageable pageable);
    
    // 特定の書籍の楽観的ロック付き取得
    @Query("SELECT b FROM Book b WHERE b.id = :bookId")
    Book findByIdForUpdate(@Param("bookId") String bookId);
}

# 3. BookRatingService.java - 評価点更新専用サービス
package com.example.my_books_backend.service;

import com.example.my_books_backend.entity.Book;
import com.example.my_books_backend.entity.Review;
import com.example.my_books_backend.repository.BookRepository;
import com.example.my_books_backend.repository.ReviewRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class BookRatingService {
    
    private final BookRepository bookRepository;
    private final ReviewRepository reviewRepository;
    
    /**
     * 書籍の評価点を再計算して更新
     */
    @Transactional
    public void updateBookRating(String bookId) {
        try {
            Book book = bookRepository.findByIdForUpdate(bookId);
            if (book == null) {
                log.warn("Book not found for rating update: {}", bookId);
                return;
            }
            
            // レビューから評価を計算
            List<Review> reviews = reviewRepository.findByBookIdAndIsDeletedFalse(bookId);
            
            if (reviews.isEmpty()) {
                book.setAverageRating(0.0);
                book.setReviewCount(0);
            } else {
                double averageRating = reviews.stream()
                        .mapToDouble(Review::getRating)
                        .average()
                        .orElse(0.0);
                
                // 小数点以下2桁に丸める
                averageRating = Math.round(averageRating * 100.0) / 100.0;
                
                book.setAverageRating(averageRating);
                book.setReviewCount(reviews.size());
            }
            
            bookRepository.save(book);
            log.info("Updated rating for book {}: averageRating={}, reviewCount={}", 
                    bookId, book.getAverageRating(), book.getReviewCount());
            
        } catch (Exception e) {
            log.error("Failed to update book rating for bookId: {}", bookId, e);
            throw e;
        }
    }
    
    /**
     * 全書籍の評価点を再計算（バッチ処理用）
     */
    @Transactional
    public void recalculateAllBookRatings() {
        log.info("Starting recalculation of all book ratings");
        
        List<Book> allBooks = bookRepository.findAll();
        int updated = 0;
        
        for (Book book : allBooks) {
            try {
                updateBookRating(book.getId());
                updated++;
            } catch (Exception e) {
                log.error("Failed to update rating for book: {}", book.getId(), e);
            }
        }
        
        log.info("Completed recalculation. Updated {} books", updated);
    }
}

# 4. ReviewService.java - レビューCRUD時の評価更新
package com.example.my_books_backend.service;

import com.example.my_books_backend.dto.ReviewRequest;
import com.example.my_books_backend.dto.ReviewResponse;
import com.example.my_books_backend.entity.Review;
import com.example.my_books_backend.repository.ReviewRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Slf4j
public class ReviewService {
    
    private final ReviewRepository reviewRepository;
    private final BookRatingService bookRatingService;
    
    @Transactional
    public ReviewResponse createReview(ReviewRequest request) {
        try {
            Review review = new Review();
            review.setBookId(request.getBookId());
            review.setUserId(request.getUserId());
            review.setRating(request.getRating());
            review.setComment(request.getComment());
            
            Review savedReview = reviewRepository.save(review);
            
            // 書籍の評価点を更新
            bookRatingService.updateBookRating(request.getBookId());
            
            return convertToResponse(savedReview);
            
        } catch (Exception e) {
            log.error("Failed to create review", e);
            throw e;
        }
    }
    
    @Transactional
    public ReviewResponse updateReview(String reviewId, ReviewRequest request) {
        try {
            Review review = reviewRepository.findById(reviewId)
                    .orElseThrow(() -> new RuntimeException("Review not found"));
            
            String bookId = review.getBookId(); // 更新前のbookIdを保存
            
            review.setRating(request.getRating());
            review.setComment(request.getComment());
            
            Review savedReview = reviewRepository.save(review);
            
            // 書籍の評価点を更新
            bookRatingService.updateBookRating(bookId);
            
            return convertToResponse(savedReview);
            
        } catch (Exception e) {
            log.error("Failed to update review: {}", reviewId, e);
            throw e;
        }
    }
    
    @Transactional
    public void deleteReview(String reviewId) {
        try {
            Review review = reviewRepository.findById(reviewId)
                    .orElseThrow(() -> new RuntimeException("Review not found"));
            
            String bookId = review.getBookId(); // 削除前のbookIdを保存
            
            review.setIsDeleted(true);
            reviewRepository.save(review);
            
            // 書籍の評価点を更新
            bookRatingService.updateBookRating(bookId);
            
        } catch (Exception e) {
            log.error("Failed to delete review: {}", reviewId, e);
            throw e;
        }
    }
    
    private ReviewResponse convertToResponse(Review review) {
        // 変換ロジック
        return new ReviewResponse();
    }
}

# 5. BookService.java - シンプルな実装
package com.example.my_books_backend.service;

import com.example.my_books_backend.dto.BookResponse;
import com.example.my_books_backend.dto.PageResponse;
import com.example.my_books_backend.entity.Book;
import com.example.my_books_backend.entity.Genre;
import com.example.my_books_backend.repository.BookRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class BookService {
    private final BookRepository bookRepository;

    public PageResponse<BookResponse> getBooksByTitleKeyword(String keyword, Pageable pageable) {
        // シンプルなクエリ - ソートはPageableで処理される
        Page<Book> booksPage = bookRepository.findByTitleContainingAndIsDeletedFalse(keyword, pageable);

        List<BookResponse> bookResponses = booksPage.getContent().stream()
                .map(this::convertToBookResponse)
                .collect(Collectors.toList());

        return new PageResponse<>(bookResponses, booksPage.getNumber(), booksPage.getSize(), booksPage.getTotalElements());
    }

    private BookResponse convertToBookResponse(Book book) {
        return new BookResponse(
                book.getId(),
                book.getTitle(),
                book.getDescription(),
                book.getGenres().stream().map(Genre::getId).collect(Collectors.toList()),
                Arrays.asList(book.getAuthors().split(",")),
                book.getPublicationDate(),
                book.getImagePath(),
                book.getReviewCount(), // 事前計算された値を使用
                book.getAverageRating() // 事前計算された値を使用
        );
    }
}

# 6. PageableUtil.java - 通常のフィールドソート
package com.example.my_books_backend.util;

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import java.util.Arrays;
import java.util.List;

public class PageableUtil {

    private static final List<String> ALLOWED_FIELDS = Arrays.asList(
        "title", "updatedAt", "createdAt", "averageRating", "reviewCount", "price", "publicationDate"
    );

    public static Pageable createPageable(int page, int size, String sort) {
        String[] sortParams = sort.split("\\.");
        if (sortParams.length != 2) {
            throw new IllegalArgumentException("Invalid sort parameter. Expected format: field.direction");
        }

        String sortField = sortParams[0];
        
        // rating -> averageRating に変換
        if ("rating".equals(sortField)) {
            sortField = "averageRating";
        }
        
        Sort.Direction sortDirection;
        try {
            sortDirection = Sort.Direction.fromString(sortParams[1]);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid sort direction. Use ASC or DESC");
        }

        if (!ALLOWED_FIELDS.contains(sortField)) {
            throw new IllegalArgumentException("Invalid sort field. Allowed fields: " + ALLOWED_FIELDS);
        }

        return PageRequest.of(page, size, Sort.by(sortDirection, sortField));
    }
}

# 7. データベーススキーマ更新（SQL）
-- booksテーブルにカラム追加
ALTER TABLE books 
ADD COLUMN average_rating DECIMAL(3,2) DEFAULT 0.00 NOT NULL,
ADD COLUMN review_count INT DEFAULT 0 NOT NULL,
ADD COLUMN version BIGINT DEFAULT 0;

-- インデックス追加（パフォーマンス向上）
CREATE INDEX idx_books_average_rating ON books(average_rating);
CREATE INDEX idx_books_title_rating ON books(title, average_rating);

-- 既存データの初期化（既存のレビューから計算）
UPDATE books b
SET average_rating = (
    SELECT COALESCE(ROUND(AVG(r.rating), 2), 0.00)
    FROM reviews r 
    WHERE r.book_id = b.id AND r.is_deleted = false
),
review_count = (
    SELECT COUNT(*)
    FROM reviews r 
    WHERE r.book_id = b.id AND r.is_deleted = false
);

# 8. バッチ処理用コントローラー（管理者用）
package com.example.my_books_backend.controller.admin;

import com.example.my_books_backend.service.BookRatingService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/admin/books")
@RequiredArgsConstructor
public class BookAdminController {
    
    private final BookRatingService bookRatingService;
    
    /**
     * 全書籍の評価点を再計算
     */
    @PostMapping("/recalculate-ratings")
    public ResponseEntity<String> recalculateAllRatings() {
        try {
            bookRatingService.recalculateAllBookRatings();
            return ResponseEntity.ok("Rating recalculation completed successfully");
        } catch (Exception e) {
            return ResponseEntity.internalServerError()
                    .body("Failed to recalculate ratings: " + e.getMessage());
        }
    }
    
    /**
     * 特定書籍の評価点を再計算
     */
    @PostMapping("/{bookId}/recalculate-rating")
    public ResponseEntity<String> recalculateBookRating(@PathVariable String bookId) {
        try {
            bookRatingService.updateBookRating(bookId);
            return ResponseEntity.ok("Rating recalculation completed for book: " + bookId);
        } catch (Exception e) {
            return ResponseEntity.internalServerError()
                    .body("Failed to recalculate rating: " + e.getMessage());
        }
    }
}


＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

@Repository
public interface BookRepository extends JpaRepository<Book, String> {

    @Query(value = """
            SELECT * FROM books b
            WHERE (:cursor IS NULL OR
                   (CASE WHEN :sortField = 'publication_date' THEN
                       b.publication_date < (SELECT b2.publication_date FROM books b2 WHERE b2.id = :cursor) OR
                       (b.publication_date = (SELECT b2.publication_date FROM books b2 WHERE b2.id = :cursor) AND b.id < :cursor)
                   WHEN :sortField = 'title' THEN
                       b.title < (SELECT b2.title FROM books b2 WHERE b2.id = :cursor) OR
                       (b.title = (SELECT b2.title FROM books b2 WHERE b2.id = :cursor) AND b.id < :cursor)
                   WHEN :sortField = 'rating' THEN
                       b.average_rating < (SELECT b2.average_rating FROM books b2 WHERE b2.id = :cursor) OR
                       (b.average_rating = (SELECT b2.average_rating FROM books b2 WHERE b2.id = :cursor) AND b.id < :cursor)
                   WHEN :sortField = 'updatedAt' THEN
                       b.updated_at < (SELECT b2.updated_at FROM books b2 WHERE b2.id = :cursor) OR
                       (b.updated_at = (SELECT b2.updated_at FROM books b2 WHERE b2.id = :cursor) AND b.id < :cursor)
                   ELSE
                       b.publication_date < (SELECT b2.publication_date FROM books b2 WHERE b2.id = :cursor) OR
                       (b.publication_date = (SELECT b2.publication_date FROM books b2 WHERE b2.id = :cursor) AND b.id < :cursor)
                   END))
            AND b.title LIKE :keyword
            AND b.is_deleted = false
            ORDER BY
                CASE WHEN :sortField = 'publication_date' THEN b.publication_date END :sortDirection,
                CASE WHEN :sortField = 'title' THEN b.title END :sortDirection,
                CASE WHEN :sortField = 'rating' THEN b.average_rating END :sortDirection,
                CASE WHEN :sortField = 'updatedAt' THEN b.updated_at END :sortDirection,
                b.id DESC
            LIMIT :limit
            """,
            nativeQuery = true)
    List<Book> findBooksByTitleKeywordWithCursor(@Param("keyword") String keyword,
            @Param("cursor") String cursor, @Param("limit") int limit, @Param("sortField") String sortField, @Param("sortDirection") String sortDirection);
}
