８ファイル

------------------------------------------------------------
SecurityConfig

package com.example.my_books_backend.config;

import java.util.Arrays;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
    private final AuthTokenFilter authTokenFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable());

        http.cors(cors -> cors.configurationSource(corsConfigurationSource()));

        http.sessionManagement(
                session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        http.authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/api/v1/login", "/api/v1/signup", "/api/v1/logout").permitAll()
                .requestMatchers("/api/v1/refresh-token", "/api/v1/users/exists").permitAll()
                .requestMatchers(HttpMethod.GET, "/api/v1/books/**").permitAll()
                .requestMatchers(HttpMethod.GET, "/api/v1/genres/**").permitAll()
                .requestMatchers("/v3/api-docs/**", "/swagger-ui/**", "/swagger-ui.html")
                .permitAll().anyRequest().authenticated());

        http.addFilterBefore(authTokenFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("https://localhost:5173"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}

------------------------------------------------------------
AuthController

package com.example.my_books_backend.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import com.example.my_books_backend.dto.auth.LoginRequest;
import com.example.my_books_backend.dto.auth.LoginResponse;
import com.example.my_books_backend.dto.auth.SignupRequest;
import com.example.my_books_backend.dto.auth.AccessTokenResponse;
import com.example.my_books_backend.dto.user.UserResponse;
import com.example.my_books_backend.service.AuthService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class AuthController {
    private final AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@Valid @RequestBody LoginRequest request,
            HttpServletResponse response) {
        LoginResponse loginResponse = authService.login(request, response);
        return ResponseEntity.ok(loginResponse);
    }

    @PostMapping("/signup")
    public ResponseEntity<UserResponse> signup(@Valid @RequestBody SignupRequest request) {
        UserResponse userResponse = authService.signup(request);
        return ResponseEntity.ok(userResponse);
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<AccessTokenResponse> refreshToken(HttpServletRequest request) {
        AccessTokenResponse accessTokenResponse = authService.refreshAccessToken(request);
        return ResponseEntity.ok(accessTokenResponse);
    }

    @PostMapping("/validate-token")
    public ResponseEntity<Void> validateToken(HttpServletRequest request) {
        authService.validateToken(request);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/logout")
    public ResponseEntity<Void> logout(HttpServletResponse response) {
        authService.logout(response);
        return ResponseEntity.ok().build();
    }
}

------------------------------------------------------------
LoginResponse

package com.example.my_books_backend.dto.auth;

import com.example.my_books_backend.dto.user.UserResponse;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse {
    private String accessToken;
    private UserResponse user;
}

------------------------------------------------------------
ExceptionControllerAdvice

package com.example.my_books_backend.exception;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.lang.NonNull;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

@ControllerAdvice
public class ExceptionControllerAdvice extends ResponseEntityExceptionHandler {
        @ExceptionHandler({NotFoundException.class})
        public ResponseEntity<Object> handleNotFound(NotFoundException ex, WebRequest request) {
                ErrorResponse errorResponse = new ErrorResponse(Arrays.asList(ex.getMessage()),
                                HttpStatus.NOT_FOUND);
                return this.handleExceptionInternal(ex, errorResponse, new HttpHeaders(),
                                HttpStatus.NOT_FOUND, request);
        }

        @ExceptionHandler({BadRequestException.class})
        public ResponseEntity<Object> handleBadRequest(BadRequestException ex, WebRequest request) {
                ErrorResponse errorResponse = new ErrorResponse(Arrays.asList(ex.getMessage()),
                                HttpStatus.BAD_REQUEST);
                return this.handleExceptionInternal(ex, errorResponse, new HttpHeaders(),
                                HttpStatus.BAD_REQUEST, request);
        }

        @ExceptionHandler({ValidationException.class})
        public ResponseEntity<Object> handleBadRequest(ValidationException ex, WebRequest request) {
                ErrorResponse errorResponse = new ErrorResponse(Arrays.asList(ex.getMessage()),
                                HttpStatus.BAD_REQUEST);
                return this.handleExceptionInternal(ex, errorResponse, new HttpHeaders(),
                                HttpStatus.BAD_REQUEST, request);
        }

        @ExceptionHandler({ConflictException.class})
        public ResponseEntity<Object> handleConflict(ConflictException ex, WebRequest request) {
                ErrorResponse errorResponse = new ErrorResponse(Arrays.asList(ex.getMessage()),
                                HttpStatus.CONFLICT);
                return this.handleExceptionInternal(ex, errorResponse, new HttpHeaders(),
                                HttpStatus.CONFLICT, request);
        }

        @ExceptionHandler({UnauthorizedException.class})
        public ResponseEntity<Object> handleUnauthorized(UnauthorizedException ex,
                        WebRequest request) {
                ErrorResponse errorResponse = new ErrorResponse(Arrays.asList(ex.getMessage()),
                                HttpStatus.UNAUTHORIZED);
                return this.handleExceptionInternal(ex, errorResponse, new HttpHeaders(),
                                HttpStatus.UNAUTHORIZED, request);
        }

        @ExceptionHandler({ForbiddenException.class})
        public ResponseEntity<Object> handleForbidden(ForbiddenException ex, WebRequest request) {
                ErrorResponse errorResponse = new ErrorResponse(Arrays.asList(ex.getMessage()),
                                HttpStatus.FORBIDDEN);
                return this.handleExceptionInternal(ex, errorResponse, new HttpHeaders(),
                                HttpStatus.FORBIDDEN, request);
        }

        @Override
        protected ResponseEntity<Object> handleMethodArgumentNotValid(
                        @NonNull MethodArgumentNotValidException ex, @NonNull HttpHeaders headers,
                        @NonNull HttpStatusCode status, @NonNull WebRequest request) {
                ErrorResponse errorResponse = buildErrorResponse(ex.getBindingResult());
                return this.handleExceptionInternal(ex, errorResponse, headers,
                                HttpStatus.BAD_REQUEST, request);
        }

        private ErrorResponse buildErrorResponse(BindingResult bindingResult) {
                List<FieldError> fieldErrors = bindingResult.getFieldErrors();
                List<String> errorMessages = new ArrayList<>();
                for (final FieldError error : fieldErrors) {
                        errorMessages.add(error.getField() + ": " + error.getDefaultMessage());
                }
                ErrorResponse errorResponse =
                                new ErrorResponse(errorMessages, HttpStatus.BAD_REQUEST);
                return errorResponse;
        }
}

------------------------------------------------------------
AuthService

package com.example.my_books_backend.service;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Service;
import com.example.my_books_backend.dto.auth.LoginRequest;
import com.example.my_books_backend.dto.auth.LoginResponse;
import com.example.my_books_backend.dto.auth.SignupRequest;
import com.example.my_books_backend.dto.auth.AccessTokenResponse;
import com.example.my_books_backend.dto.user.CreateUserRequest;
import com.example.my_books_backend.dto.user.UserResponse;
import com.example.my_books_backend.entity.User;
import com.example.my_books_backend.exception.ConflictException;
import com.example.my_books_backend.exception.UnauthorizedException;
import com.example.my_books_backend.exception.ValidationException;
import com.example.my_books_backend.mapper.UserMapper;
import com.example.my_books_backend.repository.UserRepository;
import com.example.my_books_backend.service.impl.UserDetailsServiceImpl;
import com.example.my_books_backend.util.JwtUtil;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AuthService {
    private final AuthenticationManager authenticationManager;
    private final UserRepository userRepository;
    private final UserService userService;
    private final UserDetailsServiceImpl userDetailsService;
    private final UserMapper userMapper;
    private final JwtUtil jwtUtil;

    public LoginResponse login(LoginRequest request, HttpServletResponse response) {
        Authentication authentication;
        try {
            authentication =
                    authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(
                            request.getEmail(), request.getPassword()));
        } catch (AuthenticationException e) {
            throw new UnauthorizedException("ログインに失敗しました。メールアドレスまたはパスワードが無効です。");
        }

        SecurityContextHolder.getContext().setAuthentication(authentication);
        User user = (User) authentication.getPrincipal();

        String accessToken = jwtUtil.generateAccessToken(user);
        String refreshToken = jwtUtil.generateRefreshToken(user);

        Cookie refreshTokenCookie = jwtUtil.createRefreshTokenCookie(refreshToken);
        response.addCookie(refreshTokenCookie);

        UserResponse userResponse = userMapper.toUserResponse(user);

        return new LoginResponse(accessToken, userResponse);
    }

    public UserResponse signup(SignupRequest request) {
        String name = request.getName();
        String email = request.getEmail();
        String password = request.getPassword();

        if (userRepository.existsByName(name)) {
            throw new ConflictException("サインアップに失敗しました。このユーザー名は既に登録されています。: " + name);
        }

        if (userRepository.existsByEmail(email)) {
            throw new ConflictException("サインアップに失敗しました。このメールアドレスは既に登録されています。: " + email);
        }

        CreateUserRequest createUserRequest = new CreateUserRequest();
        createUserRequest.setName(name);
        createUserRequest.setEmail(email);
        createUserRequest.setPassword(password);

        return userService.createUser(createUserRequest);
    }

    public AccessTokenResponse refreshAccessToken(HttpServletRequest request) {
        String refreshToken = jwtUtil.getRefreshTokenFromCookie(request);

        if (refreshToken == null || !jwtUtil.validateToken(refreshToken)) {
            throw new ValidationException("リフレッシュトークンが無効です。");
        }

        String email = jwtUtil.getSubjectFromToken(refreshToken);
        User user = (User) userDetailsService.loadUserByUsername(email);

        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
        SecurityContextHolder.getContext().setAuthentication(authentication);

        String accessToken = jwtUtil.generateAccessToken(user);
        return new AccessTokenResponse(accessToken);
    }

    public void validateToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken == null || !bearerToken.startsWith("Bearer ")) {
            throw new ValidationException("アクセストークンが無効です。");
        }
        String accessToken = bearerToken.substring(7);
        if (!jwtUtil.validateToken(accessToken)) {
            throw new ValidationException("アクセストークンが無効です。");
        }
    }

    public void logout(HttpServletResponse response) {
        Cookie cookie = jwtUtil.getInvalidateRefreshTokenCookie();
        response.addCookie(cookie);
    }
}

------------------------------------------------------------
JwtUtil

package com.example.my_books_backend.util;

import java.security.Key;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;
import javax.crypto.SecretKey;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import com.example.my_books_backend.entity.User;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;

@Component
public class JwtUtil {
    private static final Logger logger = LoggerFactory.getLogger(JwtUtil.class);

    @Value("${spring.app.jwtSecret}")
    private String secret;

    @Value("${spring.app.jwtAccessExpiration}")
    private int accessExpiration;

    @Value("${spring.app.jwtRefreshExpiration}")
    private int refreshExpiration;

    private static final String REFRESH_TOKEN_KEY = "refreshToken";

    // アクセストークン生成
    public String generateAccessToken(User user) {
        String email = user.getEmail();
        String name = user.getName();
        String roles = user.getRoles().stream().map(role -> role.getName().toString())
                .collect(Collectors.joining(","));

        return Jwts.builder().subject(email).claim("name", name).claim("roles", roles)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + accessExpiration * 1000))
                .signWith(key()).compact();
    }

    // リフレッシュトークン生成
    public String generateRefreshToken(User user) {
        String email = user.getEmail();

        return Jwts.builder().subject(email).issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + refreshExpiration * 1000))
                .signWith(key()).compact();
    }

    // リフレッシュトークンからCookieを作成
    public Cookie createRefreshTokenCookie(String refreshToken) {
        Cookie cookie = new Cookie(REFRESH_TOKEN_KEY, refreshToken);
        cookie.setHttpOnly(true);
        cookie.setPath("/");
        cookie.setAttribute("SameSite", "None");
        cookie.setSecure(true);
        cookie.setMaxAge(refreshExpiration);
        return cookie;
    }

    // リフレッシュトークンを無効にしたCookieを取得
    public Cookie getInvalidateRefreshTokenCookie() {
        Cookie cookie = new Cookie(REFRESH_TOKEN_KEY, "");
        cookie.setHttpOnly(true);
        cookie.setPath("/");
        cookie.setAttribute("SameSite", "None");
        cookie.setSecure(true);
        cookie.setMaxAge(0); // すぐに削除
        return cookie;
    }

    // リフレッシュトークンをCookieから取得
    public String getRefreshTokenFromCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();

        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (REFRESH_TOKEN_KEY.equals(cookie.getName())) {
                    return cookie.getValue();
                }
            }
        }
        return null;
    }

    // トークンの検証
    public boolean validateToken(String token) {
        try {
            Jwts.parser().verifyWith((SecretKey) key()).build().parseSignedClaims(token);
            return true;
        } catch (MalformedJwtException e) {
            logger.error("無効な JWTトークン: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("JWTトークンの有効期限が切れています: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("JWTトークンはサポートされていません: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("JWTクレーム文字列が空です: {}", e.getMessage());
        }
        return false;
    }

    // トークンからサブジェクトを取得
    public String getSubjectFromToken(String token) {
        return getClaimFromToken(token, claims -> claims.getSubject());
    }

    // トークンからJTIを取得
    public String getJtiFromToken(String token) {
        return getClaimFromToken(token, claims -> claims.getId());
    }

    // トークンから有効期限を取得
    public Date getExpiryTimeFromToken(String token) {
        return getClaimFromToken(token, claims -> claims.getExpiration());
    }

    // トークンのロールを取得
    public List<String> getRolesFromToken(String token) {
        return getClaimFromToken(token, claims -> {
            String rolesString = claims.get("roles", String.class);
            return rolesString != null ? Arrays.asList(rolesString.split(","))
                    : Collections.emptyList();
        });
    }

    // 秘密鍵の生成
    private Key key() {
        byte[] keyBytes = Decoders.BASE64.decode(secret);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    // 汎用的なクレーム取得メソッド
    private <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }

    // すべてのクレームを取得
    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parser().verifyWith((SecretKey) key()).build().parseSignedClaims(token)
                .getPayload();
    }
}

// ---------------------------------------------------------------------------
// JWT秘密鍵
// @Value("${spring.app.jwtSecret}")
// private String secret;
//
// 以下のようなプログラムで生成した値を環境変数に設定
// import java.security.SecureRandom;
// import java.util.Base64;
//
// public class JwtSecretGenerator {
// public static void main(String[] args) {
// // 256ビット（32バイト）のランダムな秘密鍵を生成
// byte[] keyBytes = new byte[32];
// new SecureRandom().nextBytes(keyBytes);
//
// // Base64エンコード
// String base64EncodedSecret = Base64.getEncoder().encodeToString(keyBytes);
//
// System.out.println("生成されたBase64エンコード秘密鍵:");
// System.out.println(base64EncodedSecret);
// }
// }

------------------------------------------------------------
application.properties

spring.application.name=my-books-backend

spring.jpa.properties.hibernate.hbm2dll.create_namespaces=true
spring.jpa.hibernate.ddl-auto=update
# spring.jpa.show-sql=true
spring.jpa.open-in-view=false

# X-Forwarded-Protoヘッダーを使用して元のプロトコルを認識する
# （リバースプロキシ元がHTTPS通信ならHTTPS通信と認識するため）
server.forward-headers-strategy = native

# DB
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}

# JWT
spring.app.jwtSecret=${SPRING_APP_JWT_SECRET}
# spring.app.jwtAccessExpiration=${SPRING_APP_JWT_ACCESS_EXPIRATION}
# spring.app.jwtRefreshExpiration=${SPRING_APP_JWT_REFRESH_EXPIRATION}
spring.app.jwtAccessExpiration=30
spring.app.jwtRefreshExpiration=120

# ユーザーのデフォルトアバター
spring.app.defaultAvatarUrl=https://localhost/images/avatars/avatar00.png
------------------------------------------------------------
docker-compose.yml

services:
  app:
    build:
      context: .
      dockerfile: .devcontainer/Dockerfile
    volumes:
      - .:/my-books-backend
    tty: true
    ports:
      - 8080:8080
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://db:3306/my-books-db
      SPRING_DATASOURCE_USERNAME: root
      SPRING_DATASOURCE_PASSWORD: password
      SPRING_APP_JWT_SECRET: j2fEn1JVrRd0IPQuPJAixNP5zM97PxcSdkt82O5MVJQ=
      SPRING_APP_JWT_ACCESS_EXPIRATION: 3600
      SPRING_APP_JWT_REFRESH_EXPIRATION: 86400
    depends_on:
      - db

  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: my-books-db
    ports:
      - 3306:3306
    volumes:
      - ./.devcontainer/db/init.sql:/docker-entrypoint-initdb.d/init.sql
      - ./.devcontainer/db/books.csv:/docker-entrypoint-initdb.d/books.csv
      - ./.devcontainer/db/book_genres.csv:/docker-entrypoint-initdb.d/book_genres.csv
      - ./.devcontainer/db/book_content_pages.csv:/docker-entrypoint-initdb.d/book_content_pages.csv
      - ./.devcontainer/db/my.cnf:/etc/mysql/conf.d/my.cnf
      - db_data:/var/lib/mysql
    command: --secure-file-priv=/docker-entrypoint-initdb.d

volumes:
  db_data:

------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------


