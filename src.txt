------------------------------------------------------------
book-detail

<TooltipTrigger asChild>

------------------------------------------------------------
review-dialog

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogTrigger } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useToast } from '@/hooks/use-toast';
import { useEffect, useRef, useState } from 'react';

export default function ReviewDialog() {
  const [isOpen, setIsOpen] = useState(false);
  const [rating, setRating] = useState(0);
  const commentRef = useRef<HTMLTextAreaElement | null>(null);
  const { toast } = useToast();

  useEffect(() => {
    if (isOpen) {
      if (commentRef.current) {
        commentRef.current.value = '';
      }
      setRating(0);
    }
  }, [isOpen]);

  const handlePost = () => {
    toast({ description: 'レビューを投稿しました' });
    setIsOpen(false);
  };

  return (
    <>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className="rounded-full"
            variant="outline"
            onClick={() => setIsOpen(true)}
          >
            レビューを書く
          </Button>
        </TooltipTrigger>
        <TooltipContent>
          <p>ログインしてこの本のレビューを書きましょう</p>
        </TooltipContent>
      </Tooltip>

      <Tooltip>
        <TooltipTrigger>レビューを書く</TooltipTrigger>
        <TooltipContent>
          <p>ログインしてこの本のレビューを書きましょう</p>
        </TooltipContent>
      </Tooltip>

      <Dialog
        className="w-1/2 min-w-[360px] max-w-[600px]"
        open={isOpen}
        onOpenChange={setIsOpen}
      >
        <DialogTrigger asChild>
          <Button onClick={() => console.log('FFF')}>ボタン</Button>
        </DialogTrigger>
        <DialogContent>
          <div className="mb-3 flex items-start justify-between">
            <div>
              <p className="font-semibold leading-10">レビュー</p>
              <p className="text-xs text-muted-foreground md:text-sm">
                素敵な感想を伝えましょう！
              </p>
            </div>
            <div>
              <Rating rating={rating} onChange={setRating} />
              <p className="text-center text-xs text-muted-foreground md:text-sm">
                {rating === 0 ? '星をクリックで決定' : ''}
              </p>
            </div>
          </div>

          <Textarea className="mb-6" ref={commentRef} />

          <div className="flex justify-center">
            <Button className="w-48 rounded-full" onClick={handlePost}>
              投稿する
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
}


------------------------------------------------------------
button

import { cn } from '@/lib/util';
import React, { ButtonHTMLAttributes } from 'react';

const variantList = {
  default: 'bg-primary text-primary-foreground hover:bg-primary/90',
  outline:
    'border border-primary/50 text-primary bg-background hover:bg-primary/20 hover:border-primary',
  secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
  ghost: 'bg-transparent text-foreground hover:bg-primary/20 hover:text-primary',
};

const sizeList = {
  default: 'h-10 px-4 py-2',
  sm: 'h-9 rounded-md px-3',
  lg: 'h-11 rounded-md px-8',
  icon: 'size-10',
};

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'outline' | 'secondary' | 'ghost';
  size?: 'default' | 'sm' | 'lg' | 'icon';
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, children, variant = 'default', size = 'default', ...props }, ref) => {
    return (
      <button
        className={cn(
          'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
          variantList[variant],
          sizeList[size],
          className
        )}
        ref={ref}
        {...props}
      >
        {children}
      </button>
    );
  }
);

export { Button };

------------------------------------------------------------
dialog

import { cn } from '@/lib/util';
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';

interface DialogContextType {
  openDialog: () => void;
  closeDialog: () => void;
  isOpen: boolean;
}

const DialogContext = React.createContext<DialogContextType | undefined>(undefined);

// ----------------------------------------------------------------------------
// Dialog
// ----------------------------------------------------------------------------
interface DialogProps extends React.DialogHTMLAttributes<HTMLDialogElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const Dialog = ({ className, children, open, onOpenChange, ...props }: DialogProps) => {
  // 外部からのopen状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsのopenが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
      if (open) {
        ref.current?.showModal();
      }
    }
  }, [open]);

  const ref = useRef<HTMLDialogElement | null>(null);

  const openDialog = useCallback(() => {
    ref.current?.showModal();
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeDialog = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  // 閉じるアニメーションが終わったときにDialogをcloseする
  // ref.current?.close()のタイミングが早すぎてパッと消えてしまうのを防ぐ
  const handleTransitionEnd = (e: React.TransitionEvent<HTMLDialogElement>) => {
    if (!isOpen && e.propertyName) {
      ref.current?.close();
    }
  };

  // バックドロップクリックで閉じる
  const handleClickOutside = useCallback(
    (e: React.MouseEvent<HTMLDialogElement>) => {
      if (e.target === ref.current) {
        closeDialog();
      }
    },
    [closeDialog]
  );

  // ESCキーで閉じるための関数とイベントリスナーの登録
  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        closeDialog();
      }
    },
    [closeDialog, isOpen]
  );
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown]);

  // 子要素を分割
  const trigger = React.Children.toArray(children).find(
    (child) => React.isValidElement(child) && child.type === DialogTrigger
  );
  const content = React.Children.toArray(children).find(
    (child) => React.isValidElement(child) && child.type === DialogContent
  );

  return (
    <DialogContext.Provider value={{ openDialog, closeDialog, isOpen }}>
      {trigger}
      {isOpen && <div className="fixed inset-0 z-50 bg-black/60" />}
      <dialog
        className={cn(
          'fixed w-[300px] rounded-lg bg-background text-foreground',
          'transition-all duration-200',
          isOpen ? 'opacity-100 scale-100' : 'opacity-0 scale-95',
          className
        )}
        ref={ref}
        {...props}
        onClick={handleClickOutside} // バックドロップクリック時の処理
        onTransitionEnd={handleTransitionEnd} // アニメーション終了時の処理
      >
        <div className="relative p-4 md:p-6">{content}</div>
      </dialog>
    </DialogContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// DialogTrigger
// ----------------------------------------------------------------------------
interface DialogTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  children?: React.ReactNode;
  asChild?: boolean;
}
const DialogTrigger = ({ children, asChild = false, ...props }: DialogTriggerProps) => {
  const context = useContext(DialogContext);

  if (!context) {
    throw new Error('DialogTrigger must be used within Dialog');
  }

  const handleClick = () => {
    context.openDialog();
  };

  if (asChild && React.isValidElement(children)) {
    const childProps = {
      ...props,
      ...children.props,
      onClick: (e: React.MouseEvent) => {
        // 元々childに設定されていたイベントがあれば呼び出すようにする
        if (children.props.onClick) {
          children.props.onClick(e);
        }
        handleClick();
      },
    };
    return React.cloneElement(children, childProps);
  }

  return (
    <button type="button" {...props} onClick={handleClick}>
      {children}
    </button>
  );
};

// ----------------------------------------------------------------------------
// DialogContent
// ----------------------------------------------------------------------------
interface DialogContentProps {
  children?: React.ReactNode;
  className?: string;
}
const DialogContent = ({ children, className }: DialogContentProps) => {
  const context = useContext(DialogContext);

  if (!context) {
    throw new Error('DialogContent must be used within Dialog');
  }

  return <div className={cn('relative', className)}>{children}</div>;
};

// ----------------------------------------------------------------------------
// DialogHeader
// ----------------------------------------------------------------------------
interface DialogHeaderProps {
  children?: React.ReactNode;
  className?: string;
}
const DialogHeader = ({ children, className }: DialogHeaderProps) => {
  return (
    <div className={cn('mb-4 flex items-center justify-between', className)}>
      {children}
    </div>
  );
};

// ----------------------------------------------------------------------------
// DialogTitle
// ----------------------------------------------------------------------------
interface DialogTitleProps {
  children?: React.ReactNode;
  className?: string;
}
const DialogTitle = ({ children, className }: DialogTitleProps) => {
  return <h2 className={cn('text-lg font-semibold', className)}>{children}</h2>;
};

// ----------------------------------------------------------------------------
// DialogClose
// ----------------------------------------------------------------------------
interface DialogCloseProps {
  children?: React.ReactNode;
  className?: string;
  onClick?: () => void;
}
const DialogClose = ({ children, className, onClick }: DialogCloseProps) => {
  const context = useContext(DialogContext);

  if (!context) {
    throw new Error('DialogClose must be used within Dialog');
  }

  const props = {
    onClick: () => {
      context.closeDialog();
      onClick?.();
    },
  };

  return (
    <button
      className={cn('hover:opacity-80 transition-opacity', className)}
      type="button"
      {...props}
    >
      {children}
    </button>
  );
};

export { Dialog, DialogClose, DialogContent, DialogHeader, DialogTitle, DialogTrigger };


------------------------------------------------------------
tooltip

import { cn } from '@/lib/util';
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';

type TooltipSideType = 'top' | 'bottom' | 'left' | 'right';

interface TooltipContextType {
  openTooltip: () => void;
  closeTooltip: () => void;
  isOpen: boolean;
  side: TooltipSideType;
}

const TooltipContext = React.createContext<TooltipContextType | undefined>(undefined);

// ----------------------------------------------------------------------------
// Tooltip
// ----------------------------------------------------------------------------
interface TooltipProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
  side?: TooltipSideType;
  sideOffset?: number;
}

const Tooltip = ({
  className,
  children,
  open,
  onOpenChange,
  side = 'top',
  sideOffset = 8,
}: TooltipProps) => {
  // 外部からのopen状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsのopenが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openTooltip = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeTooltip = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  // ポインタ（マウス、ペン、タッチ）が要素内に入った時のイベントで
  // Tooltipを表示する座標の計算（style属性に指定する文字列作成）
  const ref = useRef<HTMLDivElement | null>(null);
  const [transformStyle, setTransformStyle] = useState('');
  const handlePointerEnter = () => {
    if (ref.current) {
      const { left, top, right, bottom, width, height } =
        ref.current.getBoundingClientRect();
      const positions = {
        top: {
          x: left + width / 2,
          y: top,
          offset: { x: '-50%', y: `-100% - ${sideOffset}px` },
        },
        bottom: {
          x: left + width / 2,
          y: bottom,
          offset: { x: '-50%', y: `0% + ${sideOffset}px` },
        },
        left: {
          x: left,
          y: top + height / 2,
          offset: { x: `-100% - ${sideOffset}px`, y: '-50%' },
        },
        right: {
          x: right,
          y: top + height / 2,
          offset: { x: `0% + ${sideOffset}px`, y: '-50%' },
        },
      };
      const pos = positions[side];

      setTransformStyle(
        `translate(calc(${pos.x}px + ${pos.offset.x}), calc(${pos.y}px + ${pos.offset.y}))`
      );

      openTooltip();
    }
  };

  const handlePointerLeave = () => {
    closeTooltip();
  };

  const handlePointerDown = () => {
    closeTooltip();
  };

  // 子要素を分割
  const trigger = React.Children.toArray(children).find(
    (child) => React.isValidElement(child) && child.type === TooltipTrigger
  );
  const content = React.Children.toArray(children).find(
    (child) => React.isValidElement(child) && child.type === TooltipContent
  );

  return (
    <TooltipContext.Provider value={{ openTooltip, closeTooltip, isOpen, side }}>
      <div
        ref={ref}
        onPointerEnter={handlePointerEnter}
        onPointerLeave={handlePointerLeave}
        onPointerDown={handlePointerDown}
      >
        {trigger}
      </div>
      {isOpen && (
        <div
          className={cn('z-50 fixed top-0 left-0', className)}
          style={{ transform: transformStyle }}
        >
          {content}
        </div>
      )}
    </TooltipContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// TooltipTrigger
// ----------------------------------------------------------------------------
interface TooltipTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const TooltipTrigger = React.forwardRef<HTMLButtonElement, TooltipTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    if (asChild && React.isValidElement(children)) {
      const childProps = {
        ...props,
        ...children.props,
      };
      return React.cloneElement(children, { ...childProps, ref });
    }

    return (
      <button type="button" ref={ref} {...props}>
        {children}
      </button>
    );
  }
);

// ----------------------------------------------------------------------------
// TooltipContent
// ----------------------------------------------------------------------------
type TooltipContentProps = React.HTMLAttributes<HTMLDivElement>;

const TooltipContent = React.forwardRef<HTMLDivElement, TooltipContentProps>(
  ({ children, className, ...props }, ref) => {
    const context = useContext(TooltipContext);

    if (!context) {
      throw new Error('TooltipContent must be used within Tooltip');
    }

    return (
      <div
        className={cn(
          'z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
          className
        )}
        data-state={context.isOpen ? 'open' : 'closed'}
        data-side={context.side}
        ref={ref}
        {...props}
      >
        {children}
      </div>
    );
  }
);

export { Tooltip, TooltipContent, TooltipTrigger };


------------------------------------------------------------
