６３ファイル

------------------------------------------------------------
book-detail-skeleton.tsx

import { Skeleton } from '@/components/ui/skeleton';

export default function BookDetailSkeleton() {
  return (
    <div className="flex flex-col justify-center p-3 pt-10 sm:p-6 lg:flex-row">
      <div className="flex flex-col items-center justify-center lg:w-1/2">
        <Skeleton className="h-[360px] w-[280px] rounded bg-muted-foreground/5 object-cover sm:h-[480px] sm:w-[360px]" />
        <div className="mt-2 flex flex-col items-center justify-around sm:w-[440px] sm:flex-row">
          <div className="flex justify-center gap-x-2">
            <Skeleton className="size-8 rounded-full bg-muted-foreground/5" />
            <Skeleton className="size-8 rounded-full bg-muted-foreground/5" />
          </div>
          <Skeleton className="mt-2 h-6 w-48 rounded-full bg-muted-foreground/5" />
        </div>
        <div className="my-4 flex items-center">
          <Skeleton className="h-11 w-48 rounded-full bg-muted-foreground/5" />
        </div>
      </div>

      <div className="p-4 lg:w-1/2">
        <div className="text-3xl font-bold sm:text-4xl">
          <Skeleton className="h-9 w-64 rounded-full bg-muted-foreground/5 sm:h-10" />
        </div>
        <div className="my-4 flex w-full flex-wrap items-center justify-end gap-x-3">
          <Skeleton className="h-7 w-24 rounded-full bg-muted-foreground/5 sm:h-8" />
        </div>

        <div className="flex gap-x-2">
          <Skeleton className="h-9 w-24 rounded-full bg-muted-foreground/5" />
          <Skeleton className="h-9 w-24 rounded-full bg-muted-foreground/5" />
        </div>

        <div className="my-6 md:my-10">
          <Skeleton className="my-2 h-6 w-full rounded-full bg-muted-foreground/5" />
          <Skeleton className="my-2 h-6 w-full rounded-full bg-muted-foreground/5" />
          <Skeleton className="my-2 h-6 w-full rounded-full bg-muted-foreground/5" />
        </div>

        <div className="flex flex-col justify-between gap-y-4 lg:flex-row">
          <div className="flex flex-col gap-y-1 text-muted-foreground">
            <div className="flex">
              <Skeleton className="mb-1 h-5 w-48 rounded-full bg-muted-foreground/5" />
            </div>
            <div className="flex">
              <Skeleton className="mb-1 h-5 w-36 rounded-full bg-muted-foreground/5" />
            </div>
            <div className="flex">
              <Skeleton className="mb-1 h-5 w-44 rounded-full bg-muted-foreground/5" />
            </div>
            <div className="flex">
              <Skeleton className="mb-1 h-5 w-36 rounded-full bg-muted-foreground/5" />
            </div>
            <div className="flex">
              <Skeleton className="mb-1 h-5 w-32 rounded-full bg-muted-foreground/5" />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
book-card.tsx

import AverageRatingIcon from '@/components/count-icon/average-rating-icon';
import FavoriteCountIcon from '@/components/count-icon/favorite-count-icon';
import ReviewCountIcon from '@/components/count-icon/review-count-icon';
import { Card, CardContent } from '@/components/ui/card';
import { formatDateJP } from '@/lib/util';
import { Book } from '@/types';
import { Link } from 'react-router-dom';

type Props = {
  book: Book;
};

export default function BookCard({ book }: Props) {
  return (
    <Card className="border-card-foreground/5 bg-card/70">
      <CardContent className="relative flex w-40 flex-col items-center px-3 pb-2 pt-4 sm:w-48 sm:px-4">
        <Link to={`/book/${book.id}`} className="flex justify-center">
          <img
            className="h-44 rounded object-cover sm:h-52"
            src={book.imageUrl}
            alt={book.title}
          />
        </Link>
        <Link
          to={`/book/${book.id}`}
          className="mt-1 flex h-8 w-full items-center justify-center text-xs hover:text-primary sm:h-10 sm:text-sm"
        >
          <p className="line-clamp-2 text-center">{book.title}</p>
        </Link>
        <div className="mt-1 flex w-full flex-col items-center gap-y-1">
          <p className="text-xs tracking-wide text-muted-foreground">
            {formatDateJP(book.publishedDate)}
          </p>
          <div className="flex justify-around gap-x-2 sm:gap-x-4">
            <FavoriteCountIcon size="sm" bookId={book.id} />
            <ReviewCountIcon size="sm" reviewCount={book.reviewCount} />
            <AverageRatingIcon size="sm" averageRating={book.averageRating} />
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
book-list-by-genre-id.tsx

import BookList from '@/components/book-list/book-list';
import BookPagination from '@/components/book-list/book-pagination';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useSuspenseQuery } from '@tanstack/react-query';

type Props = {
  genreIdsQuery: string;
  conditionQuery: string;
  page: number;
};

export default function BookListByGenreId({
  genreIdsQuery,
  conditionQuery,
  page,
}: Props) {
  const { getBookPageByGenreId } = useApiBook();

  const { data: bookPage } = useSuspenseQuery({
    queryKey: ['getBookPageByGenreId', genreIdsQuery, conditionQuery, page],
    queryFn: () => getBookPageByGenreId(genreIdsQuery, conditionQuery, page),
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <p className="text-right">
        {bookPage.totalItems}
        <span className="ml-1 mr-4 text-sm text-muted-foreground">件</span>
      </p>
      <BookList books={bookPage.books} />
      <BookPagination totalPages={bookPage.totalPages} />
    </div>
  );
}

------------------------------------------------------------
book-list-by-query.tsx

import BookList from '@/components/book-list/book-list';
import BookPagination from '@/components/book-list/book-pagination';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useSuspenseQuery } from '@tanstack/react-query';

type Props = {
  query: string;
  page: number;
};

export default function BookListByQuery({ query, page }: Props) {
  const { getBookPageByQuery } = useApiBook();

  const { data: bookPage } = useSuspenseQuery({
    queryKey: ['getBookPageByQuery', query, page],
    queryFn: () => getBookPageByQuery(query, page),
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <p className="text-right">
        {bookPage.totalItems}
        <span className="ml-1 mr-4 text-sm text-muted-foreground">件</span>
      </p>
      <BookList books={bookPage.books} />
      <BookPagination totalPages={bookPage.totalPages} />
    </div>
  );
}

------------------------------------------------------------
book-list-empty.tsx

export default function BookListEmpty() {
  return (
    <div className="flex h-32 items-center justify-center">
      <p>見つかりませんでした</p>
    </div>
  );
}

------------------------------------------------------------
book-list-favorites.tsx

import BookList from '@/components/book-list/book-list';
import BookPagination from '@/components/book-list/book-pagination';
import { useApiFavorite } from '@/hooks/api/use-api-favorite';
import { useSuspenseQuery } from '@tanstack/react-query';

type Props = {
  page: number;
};

export default function BookListFavorites({ page }: Props) {
  const { getFavoritePage } = useApiFavorite();

  const { data: bookPage } = useSuspenseQuery({
    queryKey: ['getFavoritePage', page],
    queryFn: () => getFavoritePage(page),
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <p className="text-right">
        {bookPage.totalItems}
        <span className="ml-1 mr-4 text-sm text-muted-foreground">件</span>
      </p>
      <BookList books={bookPage.favorites.map((favorite) => favorite.book)} />
      <BookPagination totalPages={bookPage.totalPages} />
    </div>
  );
}

------------------------------------------------------------
book-list-new-releases.tsx

import BookList from '@/components/book-list/book-list';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useSuspenseQuery } from '@tanstack/react-query';

export default function BookListNewReleases() {
  const { getNewBooks } = useApiBook();

  const { data: bookPage } = useSuspenseQuery({
    queryKey: ['getNewBooks'],
    queryFn: () => getNewBooks(),
  });

  return (
    <div className="pb-4">
      <BookList books={bookPage.books} />
    </div>
  );
}

------------------------------------------------------------
book-list-skeleton.tsx

import { Card, CardContent } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';

export default function BookListSkeleton() {
  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <div className="h-6" />
      <ul className="grid grid-cols-2 justify-items-center gap-2 sm:grid-cols-3 sm:gap-3 md:grid-cols-4 lg:grid-cols-5">
        {[...Array<number>(FETCH_BOOKS_MAX_RESULTS)].map((_, index) => (
          <li key={index}>
            <Card>
              <CardContent className="relative flex w-40 flex-col items-center px-3 pb-2 pt-4 sm:w-48 sm:px-4">
                <Skeleton className="h-44 w-32 rounded bg-muted-foreground/5 object-cover sm:h-52 sm:w-36" />
                <div className="mt-1 flex h-8 w-full items-center justify-center sm:h-10">
                  <Skeleton className="h-4 w-4/5 rounded-full bg-muted-foreground/5 sm:h-5" />
                </div>
                <div className="mt-1 flex h-11 w-full flex-col items-center">
                  <Skeleton className="h-3 w-24 rounded-lg bg-muted-foreground/5" />
                  <Skeleton className="mt-3 h-3 w-24 rounded-lg bg-muted-foreground/5" />
                </div>
              </CardContent>
            </Card>
          </li>
        ))}
      </ul>
    </div>
  );
}

------------------------------------------------------------
book-pagination.tsx

import Pagination from '@/components/pagination';
import { useEffect, useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

type Props = {
  totalPages: number;
};

export default function BookPagination({ totalPages }: Props) {
  const location = useLocation();
  const navigate = useNavigate();

  const [page, setPage] = useState(1);

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const page = Number(params.get('page') ?? '1');
    setPage(page);
  }, [location.search]);

  const handleChange = (page: number) => {
    setPage(page);
    const params = new URLSearchParams(location.search);
    params.set('page', page.toString());
    navigate(`${location.pathname}?${params.toString()}`);
  };

  return (
    <div className="flex justify-center">
      {totalPages > 1 && (
        <Pagination total={totalPages} page={page} onChangePage={handleChange} />
      )}
    </div>
  );
}

------------------------------------------------------------
book-read-background.tsx

import { useApiBook } from '@/hooks/api/use-api-book';
import { useSuspenseQuery } from '@tanstack/react-query';

type Props = {
  bookId: string;
};

export default function BookReadBackground({ bookId }: Props) {
  const { getBookDetailsById } = useApiBook();

  const { data: book } = useSuspenseQuery({
    queryKey: ['getBookDetailsById', bookId],
    queryFn: () => getBookDetailsById(bookId),
  });

  return (
    <div className="fixed left-0 top-0 -z-10 flex h-screen w-full justify-center">
      <img
        className="w-full max-w-7xl object-cover opacity-5"
        src={book.imageUrl}
        alt="bg-image"
      />
    </div>
  );
}

------------------------------------------------------------
book-read-content.tsx

import BookmarkButton from '@/components/count-icon/bookmark-button';
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useApiBookmark } from '@/hooks/api/use-api-bookmark';
import { cn } from '@/lib/util';
import { Bookmark, BookTableOfContents } from '@/types';
import { useSuspenseQueries } from '@tanstack/react-query';
import { ChevronLeftIcon, ChevronRightIcon, TableOfContentsIcon } from 'lucide-react';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
};

export default function BookReadContent({ bookId, chapterNumber, pageNumber }: Props) {
  const { getBookTableOfContents, getBookContentPage } = useApiBook();
  const { getBookmarkByBookId } = useApiBookmark();

  const [{ data: bookTableOfContents }, { data: bookContentPage }, { data: bookmark }] =
    useSuspenseQueries({
      queries: [
        {
          queryKey: ['getBookTableOfContents', bookId],
          queryFn: () => getBookTableOfContents(bookId),
        },
        {
          queryKey: ['getBookContentPage', bookId, chapterNumber, pageNumber],
          queryFn: () => getBookContentPage(bookId, chapterNumber, pageNumber),
        },
        {
          queryKey: ['getBookmarkByBookId', bookId],
          queryFn: () => getBookmarkByBookId(bookId),
          select: (bookmarks: Bookmark[]) =>
            bookmarks.find(
              (bookmark) =>
                bookmark.bookId === bookId &&
                bookmark.chapterNumber === chapterNumber &&
                bookmark.pageNumber === pageNumber
            ),
        },
      ],
    });

  const chapterIndex = bookTableOfContents.chapters.findIndex(
    (chapter) => chapter.chapterNumber === chapterNumber
  );
  const totalPage = bookTableOfContents.chapters[chapterIndex]?.pageNumbers.length ?? 1;
  const pageTitle = `（${pageNumber}/${totalPage}）`;

  const isFirstPage = chapterNumber === 1 && pageNumber === 1;
  const isLastPage =
    chapterNumber === bookTableOfContents.chapters.length &&
    pageNumber ===
      bookTableOfContents.chapters.find(
        (chapter) => chapter.chapterNumber === chapterNumber
      )?.pageNumbers.length;

  /**
   * 指定方向（次 or 前）のページ情報を取得する関数
   */
  const getPageInfo = (
    bookTableOfContents: BookTableOfContents,
    chapterNumber: number,
    pageNumber: number,
    direction: 'next' | 'prev'
  ) => {
    const chapterIndex = bookTableOfContents.chapters.findIndex(
      (chapter) => chapter.chapterNumber === chapterNumber
    );

    if (chapterIndex === -1) return { chapterNumber, pageNumber };

    const totalPages =
      bookTableOfContents.chapters[chapterIndex]?.pageNumbers.length ?? 1;
    const isMovingForward = direction === 'next';

    const isLastPage = pageNumber >= totalPages;
    const isFirstPage = pageNumber <= 1;
    const isLastChapter = chapterIndex >= bookTableOfContents.chapters.length - 1;
    const isFirstChapter = chapterIndex <= 0;

    let newChapterNumber = chapterNumber;
    let newPageNumber = pageNumber;

    if (isMovingForward) {
      if (isLastPage) {
        // 最終章の最後のページなら、それ以上進めない
        if (isLastChapter) {
          newPageNumber = totalPages; // 現在の最後のページのまま
        } else {
          // 次のチャプターの最初のページへ
          newChapterNumber = chapterNumber + 1;
          newPageNumber = 1;
        }
      } else {
        newPageNumber = pageNumber + 1;
      }
    } else {
      if (isFirstPage) {
        // 最初の章の最初のページなら、それ以上戻れない
        if (isFirstChapter) {
          newPageNumber = 1; // 現在の最初のページのまま
        } else {
          // 前のチャプターの最後のページへ
          newChapterNumber = chapterNumber - 1;
          newPageNumber =
            bookTableOfContents.chapters[chapterIndex - 1].pageNumbers.length;
        }
      } else {
        newPageNumber = pageNumber - 1;
      }
    }

    return { chapterNumber: newChapterNumber, pageNumber: newPageNumber };
  };

  const { chapterNumber: nextChapter, pageNumber: nextPage } = getPageInfo(
    bookTableOfContents,
    chapterNumber,
    pageNumber,
    'next'
  );
  const nextPageLink = `/read/${bookId}/chapter/${nextChapter}/page/${nextPage}`;

  const { chapterNumber: prevChapter, pageNumber: prevPage } = getPageInfo(
    bookTableOfContents,
    chapterNumber,
    pageNumber,
    'prev'
  );
  const prevPageLink = `/read/${bookId}/chapter/${prevChapter}/page/${prevPage}`;

  return (
    <div className="delay-0 duration-200 animate-in fade-in-0">
      <div className="flex flex-col gap-y-12 px-4 pb-6 pt-12 sm:px-20">
        <div className="flex flex-col items-start justify-center gap-x-2">
          <p className="mb-2 text-xs text-muted-foreground/70 sm:text-sm">{`chapter ${bookContentPage.chapterNumber}`}</p>
          <div className="text-xl font-bold sm:text-2xl">
            {bookContentPage.chapterTitle}
            <span className="text-sm text-muted-foreground sm:text-base">
              {pageTitle}
            </span>
            <div className="inline-block">
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    className="size-8 rounded-full"
                    variant="ghost"
                    size="icon"
                    asChild
                  >
                    <Link
                      to={`/read/${bookId}/table-of-contents`}
                      className="flex items-center gap-x-2"
                    >
                      <TableOfContentsIcon className="size-4" />
                    </Link>
                  </Button>
                </TooltipTrigger>
                <TooltipContent>目次に戻る</TooltipContent>
              </Tooltip>
            </div>
            <div className="inline-block">
              <Tooltip>
                <TooltipTrigger asChild>
                  <BookmarkButton
                    bookmark={bookmark}
                    bookId={bookId}
                    chapterNumber={chapterNumber}
                    pageNumber={pageNumber}
                  />
                </TooltipTrigger>
                <TooltipContent>
                  {bookmark
                    ? bookmark.note
                      ? `メモ「${bookmark.note}」`
                      : 'ブックマークからから削除'
                    : 'ブックマークに追加'}
                </TooltipContent>
              </Tooltip>
            </div>
          </div>
        </div>
        <p className="whitespace-pre-wrap">{bookContentPage.content}</p>
      </div>
      <div className="flex justify-between px-0 py-6 sm:px-12">
        <Button
          className={cn(
            'flex items-center gap-x-2 rounded-full hover:bg-transparent',
            isFirstPage ? 'pointer-events-none opacity-30' : ''
          )}
          variant="ghost"
          asChild
        >
          <Link to={prevPageLink}>
            <ChevronLeftIcon />
            <span>前のページへ</span>
          </Link>
        </Button>
        <Button
          className={cn(
            'flex items-center gap-x-2 rounded-full hover:bg-transparent',
            isLastPage ? 'pointer-events-none opacity-30' : ''
          )}
          variant="ghost"
          asChild
        >
          <Link to={nextPageLink}>
            <span>次のページへ</span>
            <ChevronRightIcon />
          </Link>
        </Button>
      </div>
    </div>
  );
}

------------------------------------------------------------
book-table-of-contents.tsx

import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useAuth } from '@/hooks/use-auth';
import { cn } from '@/lib/util';
import { useSuspenseQueries } from '@tanstack/react-query';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
};

export default function BookTableOfContents({ bookId }: Props) {
  const { getBookDetailsById, getBookTableOfContents } = useApiBook();
  const { user } = useAuth();

  const [{ data: book }, { data: bookTableOfContents }] = useSuspenseQueries({
    queries: [
      {
        queryKey: ['getBookDetailsById', bookId],
        queryFn: () => getBookDetailsById(bookId),
      },
      {
        queryKey: ['getBookTableOfContents', bookId],
        queryFn: () => getBookTableOfContents(bookId),
      },
    ],
  });

  return (
    <div className="delay-0 duration-200 animate-in fade-in-0">
      <div className="flex flex-col gap-y-12 px-4 py-12 sm:px-20">
        <div className="flex w-full flex-col items-center gap-y-6 sm:items-start">
          <p className="text-3xl font-bold sm:text-5xl">{book.title}</p>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                className={cn(
                  'w-44 rounded-full bg-transparent',
                  (!user || !bookTableOfContents.chapters.length) &&
                    'pointer-events-none opacity-50'
                )}
                variant="outline"
                asChild
              >
                <Link to={`/read/${bookId}/chapter/1/page/1`}>最初から読む</Link>
              </Button>
            </TooltipTrigger>
            {!user && <TooltipContent>ログインしてこの本を読みましょう</TooltipContent>}
          </Tooltip>
        </div>

        {bookTableOfContents.chapters.length ? (
          <ul className="flex w-full flex-col items-center gap-y-8 sm:items-start">
            {bookTableOfContents.chapters.map((chapter) => (
              <li key={chapter.chapterNumber}>
                <p className="text-center text-xs text-muted-foreground/70 sm:text-left sm:text-sm">{`chapter ${chapter.chapterNumber}`}</p>
                <Link
                  to={`/read/${bookId}/chapter/${chapter.chapterNumber}/page/1`}
                  className={cn(
                    'font-semibold hover:text-primary text-base sm:text-xl',
                    !user && 'pointer-events-none'
                  )}
                >
                  {chapter.chapterTitle}
                </Link>
              </li>
            ))}
          </ul>
        ) : (
          <p className="text-center sm:text-start">目次がありません</p>
        )}
      </div>
    </div>
  );
}

------------------------------------------------------------
bookmark-list.tsx

import BookPagination from '@/components/book-list/book-pagination';
import { Card, CardContent } from '@/components/ui/card';
import { useApiBookmark } from '@/hooks/api/use-api-bookmark';
import { useSuspenseQuery } from '@tanstack/react-query';
import { BookmarkIcon } from 'lucide-react';
import { Link } from 'react-router-dom';

type Props = {
  page: number;
};

export default function BookmarkList({ page }: Props) {
  const { getBookmarkPage } = useApiBookmark();

  const { data: bookmarkPage } = useSuspenseQuery({
    queryKey: ['getBookmarkPage', page],
    queryFn: () => getBookmarkPage(page),
  });

  return (
    <>
      <div className="flex flex-col gap-y-4 pb-4">
        <p className="text-right">
          {bookmarkPage.totalItems}
          <span className="ml-1 mr-4 text-sm text-muted-foreground">件</span>
        </p>
        <ul className="flex flex-col gap-y-2">
          {bookmarkPage.bookmarks.map((bookmark) => (
            <li key={bookmark.id}>
              <Card>
                <CardContent className="p-3">
                  <Link
                    to={`/read/${bookmark.bookId}/chapter/${bookmark.chapterNumber}/page/${bookmark.pageNumber}`}
                    className="flex gap-x-2"
                  >
                    <div className="flex w-24 justify-center">
                      <img
                        className="h-20 rounded object-cover sm:h-24"
                        src={bookmark.book.imageUrl}
                        alt={bookmark.book.title}
                      />
                    </div>
                    <div className="flex w-full flex-col justify-center gap-y-2">
                      <div className="text-base font-semibold sm:text-xl">
                        {bookmark.book.title}
                        <div className="ml-2 inline-block">
                          <BookmarkIcon
                            className="size-4 text-primary"
                            style={{ fill: 'hsl(var(--primary))' }}
                          />
                        </div>
                      </div>
                      <div className="px-2">
                        <p className="mb-1 text-xs text-muted-foreground sm:text-sm">
                          chapter {bookmark.chapterNumber}
                        </p>
                        <p className="mb-2 text-xs text-muted-foreground sm:text-sm">
                          {bookmark.chapterTitle}（{bookmark.pageNumber}ページ目）
                        </p>
                        {bookmark.note && <p>「{bookmark.note}」</p>}
                      </div>
                    </div>
                  </Link>
                </CardContent>
              </Card>
            </li>
          ))}
        </ul>
        <BookPagination totalPages={bookmarkPage.totalPages} />
      </div>
    </>
  );
}

------------------------------------------------------------
bookmark-button.tsx

import { Button } from '@/components/ui/button';
import { useApiBookmark } from '@/hooks/api/use-api-bookmark';
import { useAuth } from '@/hooks/use-auth';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { cn } from '@/lib/util';
import { Bookmark, BookmarkRequest } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { BookmarkIcon } from 'lucide-react';

const BUTTON_SIZE = { sm: 'size-6', md: 'size-8' };
const ICON_SIZE = { sm: 'size-3', md: 'size-4' };

type Props = {
  bookmark?: Bookmark;
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
  size?: 'sm' | 'md';
};

export default function BookmarkButton({
  bookmark,
  bookId,
  chapterNumber,
  pageNumber,
  size = 'md',
}: Props) {
  const { confirmDialog } = useConfirmDialog();
  const { user } = useAuth();
  const { createBookmark, deleteBookmark } = useApiBookmark();

  const queryClient = useQueryClient();

  const { mutate: createMutation } = useMutation({
    mutationFn: (requestBody: BookmarkRequest) => createBookmark(requestBody),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['getBookmarkByBookId', bookId] });
    },
  });

  const { mutate: deleteMutation } = useMutation({
    mutationFn: (bookmarkId: number) => deleteBookmark(bookmarkId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['getBookmarkByBookId', bookId] });
    },
  });

  const handleClick = async () => {
    if (!user) return;

    if (bookmark) {
      if (bookmark.note) {
        const { isCancel } = await confirmDialog({
          icon: '?',
          title: 'このブックマークを削除しますか？',
          message: 'ブックマークのメモも削除されます。',
        });
        if (isCancel) return;
      }
      deleteMutation(bookmark.id);
    } else {
      const { text: note } = await confirmDialog({
        icon: 'i',
        title: 'ブックマーク',
        message:
          'このブックマークにメモを残せます。メモがなくてもブックマーク登録できます。',
        showInput: true,
        inputRows: 1,
      });
      const requestBody: BookmarkRequest = {
        bookId,
        chapterNumber,
        pageNumber,
        note,
      };
      createMutation(requestBody);
    }
  };

  return (
    <Button
      className={cn(
        'rounded-full text-muted-foreground',
        BUTTON_SIZE[size],
        bookmark && 'text-primary bg-transparent'
      )}
      variant="ghost"
      size="icon"
      onClick={handleClick}
    >
      <BookmarkIcon
        className={ICON_SIZE[size]}
        style={{
          fill: bookmark ? 'hsl(var(--primary))' : '',
        }}
      />
    </Button>
  );
}

------------------------------------------------------------
genre-condition-selector.tsx

import { Label } from '@/components/ui/label';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { useEffect, useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

export default function GenreConditionSelector() {
  const CONDITIONS: string[] = ['SINGLE', 'AND', 'OR'];

  const location = useLocation();
  const navigate = useNavigate();

  const [selectedCondition, setSelectedCondition] = useState(CONDITIONS[0]);

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const conditionQuery = params.get('condition') ?? '';

    setSelectedCondition(conditionQuery);
  }, [location.search]);

  const handleChangeCondition = (condition: string) => {
    setSelectedCondition(condition);

    const params = new URLSearchParams(location.search);

    // SINGLE選択以外は複数ジャンル選択可能OKですが
    // SINGLE選択の場合、複数ジャンルの中の最初の値（単一の値）とする
    let genreIdsQuery = params.get('genreIds') ?? '';
    if (condition === 'SINGLE') {
      genreIdsQuery = genreIdsQuery.split(',')[0];
    }

    params.set('genreIds', genreIdsQuery);
    params.set('condition', condition);
    params.set('page', '1');
    navigate(`/discover?${params.toString()}`);
  };

  return (
    <RadioGroup
      className="flex gap-x-4"
      value={selectedCondition}
      onValueChange={handleChangeCondition}
    >
      {CONDITIONS.map((condition) => (
        <div className="flex items-center" key={condition}>
          <RadioGroupItem value={condition} id={condition} />
          <Label className="cursor-pointer select-none p-2" htmlFor={condition}>
            {condition}
          </Label>
        </div>
      ))}
    </RadioGroup>
  );
}

------------------------------------------------------------
genre-ids-selector.tsx

import GenreListSelector from '@/components/genre-list/genre-list-selector';
import GenreListSkeleton from '@/components/genre-list/genre-list-skeleton';
import ErrorElement from '@/routes/error-element';
import { Suspense, useEffect, useState } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { useLocation, useNavigate } from 'react-router-dom';

export default function GenreIdsSelector() {
  const location = useLocation();
  const navigate = useNavigate();

  const [selectedGenreIds, setSelectedGenreIds] = useState<number[]>([]);

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const genreIdsQuery = params.get('genreIds') ?? '';

    const ids = genreIdsQuery.split(',').map((genreId) => Number(genreId));
    setSelectedGenreIds(ids);
  }, [location.search]);

  const handleClickGenre = (genreId: number) => {
    let newGenreIds = selectedGenreIds.includes(genreId)
      ? selectedGenreIds.filter((id) => id !== genreId)
      : [...selectedGenreIds, genreId].sort((a, b) => a - b);

    const params = new URLSearchParams(location.search);

    // 最後の一つをクリックした場合、空配列になるので必ず１つは選択になるようにする
    // SINGLE選択に関しても同じ
    const isSingleCondition = params.get('condition') === 'SINGLE';
    if (newGenreIds.length === 0 || isSingleCondition) {
      newGenreIds = [genreId];
    }

    setSelectedGenreIds(newGenreIds);

    const genreIdsQuery = newGenreIds.join(',');

    params.set('genreIds', genreIdsQuery);
    params.set('page', '1');
    navigate(`/discover?${params.toString()}`);
  };

  return (
    <ErrorBoundary fallback={<ErrorElement />}>
      <Suspense fallback={<GenreListSkeleton />}>
        <GenreListSelector activeIds={selectedGenreIds} onClick={handleClickGenre} />
      </Suspense>
    </ErrorBoundary>
  );
}

------------------------------------------------------------
genre-list-skeleton.tsx

import { Skeleton } from '@/components/ui/skeleton';

export default function GenreListSkeleton() {
  return (
    <ul className="flex flex-wrap gap-x-2">
      {[...Array<number>(3)].map((_, index) => (
        <li key={index}>
          <Skeleton className="h-9 w-24 rounded-full bg-muted-foreground/5" />
        </li>
      ))}
    </ul>
  );
}

------------------------------------------------------------
genre-list-top-page.tsx

import GenreList from '@/components/genre-list/genre-list';
import { useApiGenre } from '@/hooks/api/use-api-genre';
import { useSuspenseQuery } from '@tanstack/react-query';

export default function GenreListTopPage() {
  const { getGenres } = useApiGenre();

  const { data: genres } = useSuspenseQuery({
    queryKey: ['getGenres'],
    queryFn: () => getGenres(),
  });

  return <GenreList genres={genres} variant="ghost" />;
}

------------------------------------------------------------
genre-list.tsx

import { Button } from '@/components/ui/button';
import { cn } from '@/lib/util';
import { Genre } from '@/types';
import { Link } from 'react-router-dom';

type Props = {
  genres: Genre[];
  className?: string;
  filterList?: number[];
  variant?: 'default' | 'outline' | 'secondary' | 'ghost';
};

export default function GenreList({ genres, className, variant = 'default' }: Props) {
  return (
    <ul className={cn('flex flex-wrap', className)}>
      {genres.map((genre) => (
        <li key={genre.id}>
          <Button
            className={cn('rounded-full', variant === 'outline' && 'bg-transparent')}
            variant={variant}
            size="sm"
            asChild
          >
            <Link to={`/discover?genreIds=${genre.id}&condition=SINGLE`}>
              {genre.name}
            </Link>
          </Button>
        </li>
      ))}
    </ul>
  );
}

------------------------------------------------------------
footer.tsx

import Logo from '@/components/layout/logo';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/util';
import { FacebookIcon, InstagramIcon, TwitterIcon, YoutubeIcon } from 'lucide-react';

type Props = {
  className?: string;
};

export default function Footer({ className }: Props) {
  return (
    <footer className={cn('bg-card', className)}>
      <div className="mx-auto max-w-7xl px-3 sm:px-6">
        <div className="grid items-center justify-center py-2 sm:grid-cols-3">
          <div>
            <Button className="rounded-full" variant="ghost" size="icon">
              <YoutubeIcon className="size-5" />
            </Button>
            <Button className="rounded-full" variant="ghost" size="icon">
              <TwitterIcon className="size-5" />
            </Button>
            <Button className="rounded-full" variant="ghost" size="icon">
              <InstagramIcon className="size-5" />
            </Button>
            <Button className="rounded-full" variant="ghost" size="icon">
              <FacebookIcon className="size-5" />
            </Button>
          </div>
          <p className="grid h-7 place-items-center text-sm">© 2025 Xxxxx, Inc.</p>
          <div className="flex justify-center sm:justify-end">
            <Logo size="sm" />
          </div>
        </div>
      </div>
    </footer>
  );
}

------------------------------------------------------------
header.tsx

import NavList from '@/components/layout/nav-list';
import SearchInput from '@/components/layout/search-input';
import ThemeToggleButton from '@/components/layout/theme-toggle-button';
import UserIconButton from '@/components/layout/user-icon-button';
import { cn } from '@/lib/util';

type Props = {
  className?: string;
};

export default function Header({ className }: Props) {
  return (
    <header
      className={cn('w-screen max-w-full bg-background/30 backdrop-blur-lg', className)}
    >
      <div className="mx-auto max-w-7xl px-3 sm:px-6">
        <div className="delay-0 duration-500 animate-in fade-in-0 slide-in-from-top-10 fill-mode-both">
          <div className="flex h-16 w-full items-center sm:gap-x-2">
            <NavList />
            <span className="flex-1"></span>
            <SearchInput />
            <UserIconButton />
            <ThemeToggleButton />
          </div>
        </div>
      </div>
    </header>
  );
}

------------------------------------------------------------
hero.tsx

import imgUrl from '@/assets/main-visual.png';
import SearchInput from '@/components/layout/search-input';

export default function Hero() {
  return (
    <div className="relative mb-8 flex h-[460px] w-full items-center gap-3 sm:mb-0 sm:gap-4 lg:h-[500px]">
      <div className="z-10 flex w-3/4 flex-col justify-between lg:w-3/5">
        <div>
          <div className="delay-0 duration-500 animate-in fade-in-0 slide-in-from-bottom-10 fill-mode-both">
            <h1 className="w-fit text-5xl font-bold sm:text-6xl xl:text-7xl">
              Let’s search for <span className="text-primary">Books</span> to discover new
              knowledge.
            </h1>
          </div>
          <div className="delay-150 duration-500 animate-in fade-in-0 slide-in-from-bottom-10 fill-mode-both">
            <p className="my-6 w-full break-words text-sm text-muted-foreground">
              本の探索サイトへようこそ。多様なコレクションから、新しい知識を発見しましょう。厳選された書籍で、あなたの次の読書を見つけてください。知識の旅に一緒に出かけましょう。
            </p>
          </div>
        </div>
        <div className="delay-300 duration-500 animate-in fade-in-0 slide-in-from-bottom-10 fill-mode-both">
          <div className="flex h-full max-w-96 items-center">
            <SearchInput />
          </div>
        </div>
      </div>
      <div className="absolute right-0 top-10 w-[400px] opacity-25 sm:right-5 sm:w-[400px] lg:w-[450px] lg:opacity-100">
        <div className="delay-500 duration-500 animate-in fade-in-0 slide-in-from-right-10 fill-mode-both">
          <img src={imgUrl} alt="main-visual-image" />
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
logo.tsx

import { LOGO_TITLE } from '@/constants/constants';
import { cn } from '@/lib/util';
import { Link } from 'react-router-dom';

type Props = {
  size?: 'sm' | 'md' | 'lg';
  disableLink?: boolean;
};

export default function Logo({ size = 'md', disableLink = false }: Props) {
  const SIZE = {
    sm: 'text-xl',
    md: 'text-3xl',
    lg: 'text-5xl',
  };

  return (
    <h1>
      <Link
        to="/"
        className={cn(
          "select-none whitespace-nowrap font-['Alfa_Slab_One'] tracking-tighter text-primary",
          'px-4 py-2 ',
          disableLink && 'cursor-default pointer-events-none',
          SIZE[size]
        )}
        aria-disabled={disableLink}
      >
        {LOGO_TITLE}
      </Link>
    </h1>
  );
}

------------------------------------------------------------
nav-list.tsx

import Logo from '@/components/layout/logo';
import MenuList from '@/components/layout/menu-list';
import { Button } from '@/components/ui/button';
import { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet';
import { useWindowSize } from '@/hooks/use-window-size';
import { MenuIcon } from 'lucide-react';
import { useState } from 'react';

export default function NavList() {
  const [isOpen, setIsOpen] = useState(false);

  const DEBOUNCED_DELAY = 100;
  const { width } = useWindowSize(DEBOUNCED_DELAY);

  const TABLET_WIDTH = 1024;
  if (isOpen && width >= TABLET_WIDTH) {
    setIsOpen(false);
  }

  return (
    <>
      <div className="hidden lg:flex lg:items-center lg:gap-x-8">
        <Logo />
        <MenuList />
      </div>

      <Sheet open={isOpen} onOpenChange={setIsOpen}>
        <SheetTrigger asChild>
          <Button className="rounded-full lg:hidden" variant="ghost" size="icon">
            <MenuIcon className="size-5" />
          </Button>
        </SheetTrigger>
        <SheetContent className="w-fit p-8" side="left">
          <div className="mb-8" onClick={() => setIsOpen(false)}>
            <Logo />
          </div>
          <MenuList onClick={() => setIsOpen(false)} />
        </SheetContent>
      </Sheet>
    </>
  );
}

------------------------------------------------------------
search-input.tsx

import { Input } from '@/components/ui/input';
import { Search } from 'lucide-react';
import { FormEvent, useEffect, useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

export default function SearchInput() {
  const location = useLocation();
  const navigate = useNavigate();

  const [query, setQuery] = useState('');

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const query = params.get('q') ?? '';
    setQuery(query);
  }, [location.search]);

  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!query) return;

    const params = new URLSearchParams();
    params.set('q', query);
    params.set('page', '1');
    navigate(`/search?${params.toString()}`, { replace: true });
  };

  return (
    <div className="w-44 sm:w-64">
      <form className="relative h-10 w-full" onSubmit={handleSubmit}>
        <Input
          className="rounded-full border-foreground/20 bg-background/20 pl-10 pr-4"
          type="search"
          placeholder="タイトルで検索"
          name="query"
          autoComplete="off"
          spellCheck="false"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />
        <Search className="absolute left-2.5 top-2.5 size-5" />
      </form>
    </div>
  );
}

------------------------------------------------------------
user-icon-button.tsx

import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { MENU_LIST } from '@/constants/constants';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { useMutation } from '@tanstack/react-query';
import { LogOutIcon } from 'lucide-react';
import { useEffect, useState } from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';

export default function UserIconButton() {
  const [isOpen, setIsOpen] = useState(false);

  const navigate = useNavigate();
  const location = useLocation();

  const { accessToken, user, setUser, logout } = useAuth();
  const { getCurrentUser } = useApiUser();
  const { toast } = useToast();

  const logoutMutation = useMutation({
    mutationFn: () => logout(),
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    const init = async () => {
      if (accessToken && !user) {
        const currentUser = await getCurrentUser();
        setUser(currentUser);
      }
    };
    init();
  }, [accessToken, getCurrentUser, setUser, user]);

  const handleClickLogout = async () => {
    logoutMutation.mutate(undefined, {
      onSuccess: () => {
        toast({ title: 'ログアウトしました' });
        setIsOpen(false);
        navigate('/');
      },
    });
  };

  const handleClickMenuItem = (href: string) => {
    navigate(href);
    setIsOpen(false);
  };

  if (!user)
    return (
      <Button className="rounded-full" variant="ghost" asChild>
        <Link to="/login" state={{ from: location }}>
          ログイン
        </Link>
      </Button>
    );

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger className="ml-2 flex items-center justify-center" asChild>
        <Button className="rounded-full" variant="ghost" size="icon">
          <Avatar>
            <AvatarImage
              className="bg-primary/50"
              src={user.avatarUrl}
              alt="avatar-image"
            />
            <AvatarFallback className="text-lg font-semibold">
              {user.name.slice(0, 1)}
            </AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-48 p-2" side="bottom" align="end">
        <DropdownMenuLabel>
          <div className="flex items-center gap-x-2">
            <Avatar className="size-8">
              <AvatarImage
                className="bg-primary/50"
                src={user.avatarUrl}
                alt="avatar-image"
              />
              <AvatarFallback className="font-semibold">
                {user.name.slice(0, 1)}
              </AvatarFallback>
            </Avatar>
            <div className="flex-1 overflow-hidden">
              <p className="truncate">{user.name}</p>
              <p className="truncate text-xs font-normal text-muted-foreground">
                {user.email}
              </p>
            </div>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        {MENU_LIST.map((item) => (
          <DropdownMenuItem
            onClick={() => handleClickMenuItem(item.href)}
            key={item.href}
          >
            <item.icon className="mr-1" />
            {item.title}
          </DropdownMenuItem>
        ))}
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={handleClickLogout}>
          <LogOutIcon className="mr-1" />
          ログアウト
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

------------------------------------------------------------
review-create-dialog.tsx

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useApiRevew } from '@/hooks/api/use-api-review';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { ReviewRequest } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import React, { useEffect, useRef, useState } from 'react';

type Props = {
  bookId: string;
  page: number;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
};

export default function ReviewCreateDialog({ bookId, page, isOpen, setIsOpen }: Props) {
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { createReview } = useApiRevew();
  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const queryClient = useQueryClient();
  const createMutation = useMutation({
    mutationFn: (reqestBody: ReviewRequest) => createReview(reqestBody),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['getReviewPage', bookId, page] });
      queryClient.invalidateQueries({ queryKey: ['getBookDetailsById', bookId] });
      queryClient.invalidateQueries({ queryKey: ['checkSelfReviewExists', bookId] });
    },
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    if (isOpen) {
      setRating(0);
      setComment('');
    }
  }, [isOpen]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handlePost = async () => {
    if (rating === 0) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: 'このまま投稿しますか？',
        message: '星の数が「0」のままです。',
        actionLabel: '投稿する',
      });
      if (isCancel) return;
    }

    const requestBody: ReviewRequest = { bookId, comment, rating };
    createMutation.mutate(requestBody, {
      onSuccess: () => {
        toast({ title: 'レビューを投稿しました' });
        setIsOpen(false);
      },
      onError: () => {
        toast({
          title: 'レビュー投稿に失敗しました',
          description: '管理者へ連絡してください。',
          variant: 'destructive',
          duration: 5000,
        });
        setIsOpen(false);
      },
    });
  };

  const handleCloseDialog = async () => {
    if (comment) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: '本当に閉じますか？',
        message: 'コメントはまだ投稿していません。',
        actionLabel: '閉じる',
        persistent: true,
      });
      if (isCancel) return;
    }
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
        onAnimationStart={handleAnimationStart}
      >
        <div className="flex items-start justify-between">
          <div>
            <p className="font-semibold leading-10">レビュー</p>
            <p className="text-xs text-muted-foreground sm:text-sm">
              素敵な感想を伝えましょう！
            </p>
          </div>
          <div>
            <Rating rating={rating} onChange={setRating} />
            <p className="text-center text-xs text-muted-foreground sm:text-sm">
              星をクリックして決定
            </p>
          </div>
        </div>

        <Textarea
          ref={ref}
          spellCheck={false}
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />

        <DialogFooter>
          <Button className="rounded-full" variant="ghost" onClick={handleCloseDialog}>
            閉じる
          </Button>
          <Button
            className="rounded-full"
            disabled={comment === '' ? true : false}
            onClick={handlePost}
          >
            投稿する
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
review-item.tsx

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/review-list/review-update-dialog';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { useApiRevew } from '@/hooks/api/use-api-review';
import { useAuth } from '@/hooks/use-auth';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { formatDateJP, formatTime } from '@/lib/util';
import { Review } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';

type Props = {
  review: Review;
  bookId: string;
  page: number;
};

export default function ReviewItem({ review, bookId, page }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const { user } = useAuth();
  const { deleteReview } = useApiRevew();
  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const queryClient = useQueryClient();
  const deleteMutation = useMutation({
    mutationFn: (id: number) => deleteReview(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['getReviewPage', bookId, page] });
      queryClient.invalidateQueries({ queryKey: ['getBookDetailsById', bookId] });
      queryClient.invalidateQueries({ queryKey: ['checkSelfReviewExists', bookId] });
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: '!',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除する',
    });
    if (isCancel) return;

    deleteMutation.mutate(review.id, {
      onSuccess: () => {
        toast({ title: 'レビューを削除しました' });
      },
    });
  };

  return (
    <div className="p-4">
      <div className="flex flex-col items-center justify-between sm:flex-row">
        <div className="flex w-full items-center gap-x-4">
          <Avatar className="size-16">
            <AvatarImage
              className="bg-primary/50"
              src={review.avatarUrl}
              alt="avatar-image"
            />
            <AvatarFallback className="font-semibold">
              {review.name.slice(0, 1)}
            </AvatarFallback>
          </Avatar>
          <div>
            <p className="-mb-1 text-lg font-semibold">{review.name}</p>
            <div className="flex items-center">
              <p className="whitespace-nowrap text-sm leading-8 tracking-wide text-muted-foreground">
                {formatDateJP(review.updatedAt)} {formatTime(review.updatedAt)}
              </p>
              <div className="ml-2 flex w-16">
                {user?.id === review.userId && (
                  <>
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      onClick={() => user && setIsOpen(true)}
                    >
                      <SquarePenIcon className="size-4" />
                    </Button>
                    <ReviewUpdateDialog
                      bookId={bookId}
                      page={page}
                      review={review}
                      isOpen={isOpen}
                      setIsOpen={setIsOpen}
                    />
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      onClick={handleClickDelete}
                    >
                      <Trash2Icon className="size-4" />
                    </Button>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
        <Rating rating={review.rating} readOnly />
      </div>
      <p className="mt-2 text-muted-foreground sm:pl-20">{review.comment}</p>
    </div>
  );
}

------------------------------------------------------------
review-list.tsx

import Pagination from '@/components/pagination';
import ReviewCreateDialog from '@/components/review-list/review-create-dialog';
import ReviewItem from '@/components/review-list/review-item';
import { Button } from '@/components/ui/button';
import { Separator } from '@/components/ui/separator';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useApiRevew } from '@/hooks/api/use-api-review';
import { useAuth } from '@/hooks/use-auth';
import { useQuery, useSuspenseQuery } from '@tanstack/react-query';
import { useState } from 'react';

type Props = {
  bookId: string;
};

export default function ReviewList({ bookId }: Props) {
  const [page, setPage] = useState(1);
  const [isOpen, setIsOpen] = useState(false);

  const { user } = useAuth();
  const { getReviewPage, checkSelfReviewExists } = useApiRevew();

  const { data: reviewPage } = useSuspenseQuery({
    queryKey: ['getReviewPage', bookId, page],
    queryFn: () => getReviewPage(bookId, page),
  });

  // enabledオプションを使って、ログインしていない場合は
  // queryFnを呼び出さない（この指定はuseSuspenseQueryでは出来ない模様）
  const { data: reviewExists = false } = useQuery({
    queryKey: ['checkSelfReviewExists', bookId],
    queryFn: () => checkSelfReviewExists(bookId),
    enabled: !!user,
    retry: false,
  });

  return (
    <div className="mx-auto w-full lg:w-3/4">
      <div className="flex flex-col-reverse items-center justify-end gap-y-4 sm:flex-row sm:gap-x-4 sm:px-6">
        <p>レビュー {reviewPage.totalItems} 件</p>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              className="w-44 rounded-full bg-transparent"
              variant="outline"
              disabled={user ? reviewExists : true}
              onClick={() => user && setIsOpen(true)}
            >
              {user && reviewExists ? 'レビュー済み' : 'レビューする'}
            </Button>
          </TooltipTrigger>
          {!user && (
            <TooltipContent>
              ログインしてこの本の「レビュー」を書きましょう
            </TooltipContent>
          )}
        </Tooltip>
        <ReviewCreateDialog
          bookId={bookId}
          page={page}
          isOpen={isOpen}
          setIsOpen={setIsOpen}
        />
      </div>

      <ul className="flex flex-col p-3 sm:p-6">
        {reviewPage.reviews.map((review) => (
          <li key={review.userId}>
            <Separator className="bg-foreground/10" />
            <ReviewItem review={review} bookId={bookId} page={page} />
          </li>
        ))}
      </ul>

      <div className="mb-4 flex justify-center">
        {reviewPage.totalPages > 1 && (
          <Pagination total={reviewPage.totalPages} page={page} onChangePage={setPage} />
        )}
      </div>
    </div>
  );
}

------------------------------------------------------------
review-update-dialog.tsx

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useApiRevew } from '@/hooks/api/use-api-review';
import { useToast } from '@/hooks/use-toast';
import { Review, ReviewRequest } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import React, { useEffect, useRef, useState } from 'react';

type Props = {
  bookId: string;
  page: number;
  review: Review;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
};

export default function ReviewUpdateDialog({
  bookId,
  page,
  review,
  isOpen,
  setIsOpen,
}: Props) {
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { updateReview } = useApiRevew();
  const { toast } = useToast();

  const queryClient = useQueryClient();
  const updateMutation = useMutation({
    mutationFn: ({ id, requestBody }: { id: number; requestBody: ReviewRequest }) =>
      updateReview(id, requestBody),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['getReviewPage', bookId, page] });
      queryClient.invalidateQueries({ queryKey: ['getBookDetailsById', bookId] });
    },
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    if (isOpen) {
      setRating(review.rating);
      setComment(review.comment);
    }
  }, [isOpen, review.comment, review.rating]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handlePost = async () => {
    const requestBody: ReviewRequest = { bookId, comment, rating };
    updateMutation.mutate(
      { id: review.id, requestBody },
      {
        onSuccess: () => {
          toast({ title: 'レビューを投稿しました' });
          setIsOpen(false);
        },
        onError: () => {
          toast({
            title: 'レビュー投稿に失敗しました',
            description: '管理者へ連絡してください。',
            variant: 'destructive',
            duration: 5000,
          });
          setIsOpen(false);
        },
      }
    );
  };

  const handleCloseDialog = async () => {
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
        onAnimationStart={handleAnimationStart}
      >
        <div className="flex items-start justify-between">
          <div>
            <p className="font-semibold leading-10">レビュー</p>
            <p className="text-xs text-muted-foreground sm:text-sm">
              素敵な感想を伝えましょう！
            </p>
          </div>
          <div>
            <Rating rating={rating} onChange={setRating} />
            <p className="text-center text-xs text-muted-foreground sm:text-sm">
              星をクリックして決定
            </p>
          </div>
        </div>

        <Textarea
          ref={ref}
          spellCheck={false}
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />

        <DialogFooter>
          <Button className="rounded-full" variant="ghost" onClick={handleCloseDialog}>
            閉じる
          </Button>
          <Button
            className="rounded-full"
            disabled={comment === '' ? true : false}
            onClick={handlePost}
          >
            投稿する
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
avatar-carousel.tsx

import SwipeArea from '@/components/settings/swipe-area';
import { Avatar, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { AVATER_IMAGE_MAX_COIUNT, AVATER_IMAGE_URL } from '@/constants/constants';
import { cn } from '@/lib/util';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { useEffect, useRef, useState } from 'react';

const AVATARS = Array.from({ length: AVATER_IMAGE_MAX_COIUNT }, (_, index) => ({
  index,
  avatarUrl: `${AVATER_IMAGE_URL}/avatar${String(index).padStart(2, '0')}.png`,
}));

type Props = {
  value: string;
  onChange: (avatarUrl: string) => void;
  itemWidth?: number;
  frameWidth?: number;
  paddingItem?: number;
};

export default function AvatarCarousel({
  value,
  onChange,
  itemWidth = 70,
  frameWidth = 192,
  paddingItem = 2,
}: Props) {
  // 配列の最初と最後の切れ目部分にアイテムを追加しておく
  // 循環参照するときの見た目の調整のため
  const extendedItems = [
    ...AVATARS.slice(-paddingItem),
    ...AVATARS,
    ...AVATARS.slice(0, paddingItem),
  ];

  // カルーセルの位置調整用
  const marginLeft = Math.floor(frameWidth / 2) - Math.floor(itemWidth / 2);

  // インデックス番号でカルーセルを制御
  // innerIndexは内部的なインデックスとして使用（スクロールアニメーション用）
  const defaultIndex =
    AVATARS.find((avater) => avater.avatarUrl === value)?.index || AVATARS[0].index;
  const [currentIndex, setCurrentIndex] = useState(defaultIndex);
  const [innerIndex, setInnerIndex] = useState(defaultIndex);

  const [isScrolling, setIsScrolling] = useState(false);
  const carouselRef = useRef<HTMLUListElement>(null);

  // 初期値がない（空文字）の場合は０番のアバターをデフォルトとする
  useEffect(() => {
    if (value === '') {
      onChange(AVATARS[0].avatarUrl);
    }
  }, [onChange, value]);

  const handlePrev = () => {
    if (isScrolling) return;
    setIsScrolling(true);
    setInnerIndex(innerIndex - 1);

    const prevIndex = (currentIndex - 1 + AVATARS.length) % AVATARS.length;
    setCurrentIndex(prevIndex);
    onChange(AVATARS[prevIndex].avatarUrl);
  };

  const handleNext = () => {
    if (isScrolling) return;
    setIsScrolling(true);
    setInnerIndex(innerIndex + 1);

    const nextIndex = (currentIndex + 1) % AVATARS.length;
    setCurrentIndex(nextIndex);
    onChange(AVATARS[nextIndex].avatarUrl);
  };

  const handleTransitonEnd = () => {
    setIsScrolling(false);
    setInnerIndex(currentIndex);

    // 循環スクロールのために、先頭から終端などに座標を変化させるとスクロールの
    // ちらつきが発生してしまうので、切れ目の変化ではアニメーションをいったんOffにする
    if (currentIndex === 0 || currentIndex === AVATARS.length - 1) {
      setIsScrolling(true);
      carouselRef.current!.style.transitionProperty = 'none';
      setTimeout(() => {
        carouselRef.current!.style.transitionProperty = 'transform';
        setIsScrolling(false);
      }, 75);
    }
  };

  return (
    <div className="flex items-center justify-center">
      <Button
        className="rounded-full"
        type="button"
        variant="ghost"
        size="icon"
        onClick={handlePrev}
      >
        <ChevronLeft className="size-4" />
      </Button>

      <div
        className="relative w-full select-none overflow-hidden"
        style={{ width: `${frameWidth}px` }}
      >
        <ul
          ref={carouselRef}
          className="flex transition-transform duration-200"
          style={{
            transform: `translateX(-${(innerIndex + paddingItem) * itemWidth}px)`,
            marginLeft: `${marginLeft}px`,
          }}
          onTransitionEnd={handleTransitonEnd}
        >
          {extendedItems.map((item, index) => (
            <li
              key={index}
              className={`flex shrink-0 items-center justify-center`}
              style={{ width: `${itemWidth}px` }}
            >
              <div className="relative flex h-24 items-center">
                <Avatar
                  className={cn(
                    'transition-all duration-200',
                    'size-12 opacity-25 scale-100',
                    currentIndex === item.index &&
                      'opacity-100 scale-150 outline-1 outline-offset-1 outline outline-primary'
                  )}
                >
                  <AvatarImage
                    className="bg-primary"
                    src={item.avatarUrl}
                    alt="avatar-image"
                    draggable={false}
                  />
                </Avatar>
              </div>
            </li>
          ))}
        </ul>
        <SwipeArea
          className="absolute left-0 top-0 h-24 w-full"
          onSwipeLeft={handleNext}
          onSwipeRight={handlePrev}
        />
      </div>

      <Button
        className="rounded-full"
        type="button"
        variant="ghost"
        size="icon"
        onClick={handleNext}
      >
        <ChevronRight className="size-4" />
      </Button>
    </div>
  );
}

------------------------------------------------------------
swipe-area.tsx

import { useState } from 'react';

type Props = {
  className?: string;
  onSwipeUp?: () => void;
  onSwipeDown?: () => void;
  onSwipeLeft?: () => void;
  onSwipeRight?: () => void;
};

export default function SwipeArea({
  className,
  onSwipeUp,
  onSwipeDown,
  onSwipeLeft,
  onSwipeRight,
}: Props) {
  const [startX, setStartX] = useState(0);
  const [startY, setStartY] = useState(0);

  const handleTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {
    const touch = e.touches[0];
    setStartX(touch.clientX);
    setStartY(touch.clientY);
  };

  const handleTouchMove = (e: React.TouchEvent<HTMLDivElement>) => {
    if (!startX || !startY) {
      return;
    }

    const touch = e.touches[0];
    const diffX = touch.clientX - startX;
    const diffY = touch.clientY - startY;

    if (Math.abs(diffX) > Math.abs(diffY)) {
      if (diffX > 0) {
        onSwipeRight?.();
      } else {
        onSwipeLeft?.();
      }
    } else {
      if (diffY > 0) {
        onSwipeDown?.();
      } else {
        onSwipeUp?.();
      }
    }

    setStartX(0);
    setStartY(0);
  };

  return (
    <div
      className={className}
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
    />
  );
}

------------------------------------------------------------
confirm-dialog.tsx

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { ConfirmDialogOptions } from '@/hooks/use-confirm-dialog';
import {
  AlertTriangleIcon,
  CheckCircle2Icon,
  HelpCircleIcon,
  InfoIcon,
  LucideProps,
} from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { cn } from '@/lib/util';
import React, { useEffect, useRef, useState } from 'react';

type IconType = {
  [key: string]: {
    icon: React.ForwardRefExoticComponent<
      Omit<LucideProps, 'ref'> & React.RefAttributes<SVGSVGElement>
    >;
    variant: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost';
    color: string;
  };
};

const iconTypes: IconType = {
  ['']: { icon: InfoIcon, variant: 'default', color: '' },
  ['i']: { icon: InfoIcon, variant: 'default', color: '' },
  ['?']: { icon: HelpCircleIcon, variant: 'default', color: '' },
  ['!']: { icon: AlertTriangleIcon, variant: 'destructive', color: 'text-destructive' },
  ['c']: { icon: CheckCircle2Icon, variant: 'default', color: '' },
};

const defaultOptions: ConfirmDialogOptions = {
  icon: '',
  title: '',
  message: '',
  actionLabel: 'OK',
  actionOnly: false,
  persistent: false,
  showInput: false,
  inputLabel: '',
  inputPlaceholder: '',
  inputRows: 1,
};

export const CONFIRM_DIALOG_EVENT = 'CONFIRM_DIALOG_EVENT';

type SELECTED_BUTTON = 'action' | 'cancel' | undefined;

const ConfirmDialog = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [options, setOptions] = useState<ConfirmDialogOptions>(defaultOptions);
  const refTextarea = useRef<HTMLTextAreaElement | null>(null);
  const Icon = iconTypes[options.icon].icon || InfoIcon;

  // hooksから呼ぶためにイベントリスナー登録
  useEffect(() => {
    const handleEvent = (event: CustomEvent<ConfirmDialogOptions>) => {
      setIsOpen(true);
      setOptions({ ...defaultOptions, ...event.detail });
    };
    document.addEventListener(CONFIRM_DIALOG_EVENT, handleEvent as EventListener);
    return () => {
      document.removeEventListener(CONFIRM_DIALOG_EVENT, handleEvent as EventListener);
    };
  }, []);

  // アニメーションフラグ（閉じれないことを伝えるためにぶるっとする）
  const [isPersistentAnimation, setIsPersistentAnimation] = useState(false);

  // ダイアログを閉じる時のイベント
  const handleCloseDialog = () => {
    if (options.persistent) {
      setIsPersistentAnimation(true);
      setTimeout(() => {
        setIsPersistentAnimation(false);
      }, 50);
      return;
    }
    handleClickCancel();
  };

  // 押したボタンによって、戻り値（resolveの引数も変更する）
  const [selected, setSelected] = useState<SELECTED_BUTTON>();

  const handleClickAction = () => {
    setIsOpen(false);
    setSelected('action');
  };

  const handleClickCancel = () => {
    setIsOpen(false);
    setSelected('cancel');
  };

  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      if (isOpen && options.showInput) {
        refTextarea.current?.focus();
      }
    } else if (e.animationName === 'exit') {
      switch (selected) {
        case 'action':
          options.resolve?.({
            isAction: true,
            isCancel: false,
            text: refTextarea.current?.value || '',
          });
          return;
        case 'cancel':
          options.resolve?.({
            isAction: false,
            isCancel: true,
            text: '',
          });
          return;
      }
    }
  };

  return (
    <Dialog open={isOpen}>
      <DialogContent
        className={cn(
          'w-[360px] sm:w-[400px] transition-transform ease-in-out [transition-duration:25ms]',
          isPersistentAnimation && 'scale-[1.02] transform'
        )}
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
        onAnimationEnd={handleAnimationEnd}
      >
        <DialogHeader>
          <DialogTitle className="my-2 flex items-center">
            <Icon className={cn('mr-3 min-w-fit', iconTypes[options.icon].color)} />
            <p className=" leading-6">{options.title}</p>
          </DialogTitle>
          {options.message && (
            <DialogDescription className="pt-2 text-left">
              {options.message}
            </DialogDescription>
          )}
        </DialogHeader>

        {options.showInput && (
          <div className="mb-4 grid w-full items-center gap-1.5">
            <p className="text-xs">{options.inputLabel}</p>
            <Textarea
              ref={refTextarea}
              className="min-h-[16px] resize-none"
              placeholder={options.inputPlaceholder}
              rows={options.inputRows}
            />
          </div>
        )}

        <DialogFooter className="flex justify-end">
          {!options.actionOnly && (
            <Button className="rounded-full" variant="ghost" onClick={handleClickCancel}>
              キャンセル
            </Button>
          )}
          <Button
            className={cn('rounded-full', options.actionLabel === 'OK' && 'sm:w-20')}
            variant={iconTypes[options.icon].variant || 'default'}
            onClick={handleClickAction}
          >
            {options.actionLabel}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export { ConfirmDialog };

------------------------------------------------------------
rating.tsx

import { cn } from '@/lib/util';
import { StarHalfIcon, StarIcon } from 'lucide-react';
import { useEffect, useState } from 'react';

type Props = {
  rating: number;
  max?: number;
  readOnly?: boolean;
  onChange?: (rating: number) => void;
};

export default function Rating({ rating, max = 5, readOnly = false, onChange }: Props) {
  const [currentRating, setCurrentRating] = useState(0);
  const [dispRating, setDispRating] = useState(0);

  useEffect(() => {
    const initRating = rating > max ? max : rating;
    setDispRating(initRating);
    setCurrentRating(initRating);
  }, [max, rating]);

  const handleMouseClick = (newDispRating: number) => {
    if (readOnly) return;

    setDispRating(newDispRating);
    setCurrentRating(newDispRating);
    if (onChange) {
      onChange(newDispRating);
    }
  };

  const handleMouseEnter = (newDispRating: number) => {
    if (readOnly) return;
    setDispRating(newDispRating);
  };

  const handleMouseLeave = () => {
    if (readOnly) return;
    setDispRating(currentRating);
  };

  return (
    <div className="flex h-10 items-center text-foreground">
      <p
        className={cn(
          'w-8',
          currentRating !== dispRating
            ? 'text-muted-foreground/50'
            : 'text-muted-foreground',
          !readOnly && 'cursor-pointer'
        )}
        onClick={() => handleMouseClick(0)}
        onMouseEnter={() => handleMouseEnter(0)}
        onMouseLeave={() => handleMouseLeave()}
      >
        {dispRating.toFixed(1)}
      </p>

      <div className="relative">
        <div className="flex">
          {[...Array<number>(max)].map((_, index) => (
            <StarIcon
              key={index}
              style={{ fill: 'hsl(var(--foreground) / 0.1)' }}
              strokeWidth={0}
            />
          ))}
        </div>

        <div className="absolute left-0 top-0 flex">
          {[...Array<number>(Math.floor(dispRating))].map((_, index) => (
            <StarIcon
              key={index}
              style={{ fill: 'hsl(var(--primary))' }}
              strokeWidth={0}
            />
          ))}
          {!Number.isInteger(dispRating) && (
            <StarHalfIcon style={{ fill: 'hsl(var(--primary))' }} strokeWidth={0} />
          )}
        </div>

        <div className="absolute left-0 top-0 flex">
          {[...Array<number>(max)].map((_, index) => (
            <div className="flex" key={index}>
              <div
                className={cn('w-3 h-6 bg-transparent', !readOnly && 'cursor-pointer')}
                onClick={() => handleMouseClick(index + 1 - 0.5)}
                onMouseEnter={() => handleMouseEnter(index + 1 - 0.5)}
                onMouseLeave={() => handleMouseLeave()}
              />
              <div
                className={cn('w-3 h-6 bg-transparent', !readOnly && 'cursor-pointer')}
                onClick={() => handleMouseClick(index + 1)}
                onMouseEnter={() => handleMouseEnter(index + 1)}
                onMouseLeave={() => handleMouseLeave()}
              />
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
use-api-book.ts

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { BookContentPage, BookDetails, BookPage, BookTableOfContents } from '@/types';

export const useApiBook = () => {
  const { fetcher, fetcherWithAuth } = useApi();

  const getBookDetailsById = async (bookId: string) => {
    try {
      const url = `/books/${bookId}`;
      const book = await fetcher<BookDetails>(url);
      return book;
    } catch (error) {
      throw new Error('書籍情報の読み込みが失敗しました。' + error);
    }
  };

  const getBookPageByQuery = async (query: string, page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/books/search?q=${query}&page=${basePage}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
      const bookPage = await fetcher<BookPage>(url);
      return bookPage;
    } catch (error) {
      throw new Error('書籍検索が失敗しました。' + error);
    }
  };

  const getBookPageByGenreId = async (
    genreIdsQuery: string,
    conditionQuery: string,
    page: number = 0
  ) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/books/discover?genreIds=${genreIdsQuery}&condition=${conditionQuery}&page=${basePage}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
      const bookPage = await fetcher<BookPage>(url);
      return bookPage;
    } catch (error) {
      throw new Error('ジャンル検索が失敗しました。' + error);
    }
  };

  const getNewBooks = async () => {
    try {
      const url = `/books/new-books`;
      const bookPage = await fetcher<BookPage>(url);
      return bookPage;
    } catch (error) {
      throw new Error('ニューリリース一覧の読み込みが失敗しました。' + error);
    }
  };

  const getBookTableOfContents = async (bookId: string) => {
    try {
      const url = `/books/${bookId}/table-of-contents`;
      const bookTableOfContents = await fetcher<BookTableOfContents>(url);
      return bookTableOfContents;
    } catch (error) {
      throw new Error('書籍の目次の読み込みが失敗しました。' + error);
    }
  };

  const getBookContentPage = async (
    bookId: string,
    chapterNumber: number,
    pageNumber: number
  ) => {
    try {
      const url = `/read/books/${bookId}/chapters/${chapterNumber}/pages/${pageNumber}`;
      const bookContentPage = await fetcherWithAuth<BookContentPage>(url);
      return bookContentPage;
    } catch (error) {
      throw new Error('書籍のページ情報の読み込みが失敗しました。' + error);
    }
  };

  return {
    getBookDetailsById,
    getBookPageByQuery,
    getBookPageByGenreId,
    getNewBooks,
    getBookTableOfContents,
    getBookContentPage,
  };
};

------------------------------------------------------------
use-api-bookmark.ts

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { Bookmark, BookmarkPage, BookmarkRequest } from '@/types';

export const useApiBookmark = () => {
  const { fetcherWithAuth, mutationWithAuth } = useApi();

  const getBookmarkByBookId = async (bookId: string) => {
    try {
      const url = `/bookmarks/${bookId}`;
      const bookmarks = await fetcherWithAuth<Bookmark[]>(url);
      return bookmarks;
    } catch (error) {
      throw new Error('ブックマークの読み込みが失敗しました。' + error);
    }
  };

  const getBookmarkPage = async (page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/bookmarks?&page=${basePage}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
      const bookmarkPage = await fetcherWithAuth<BookmarkPage>(url);
      return bookmarkPage;
    } catch (error) {
      throw new Error('ブックマーク一覧の読み込みが失敗しました。' + error);
    }
  };

  const createBookmark = async (reqestBody: BookmarkRequest) => {
    try {
      const url = `/bookmarks`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(reqestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('ブックマークの作成に失敗しました。' + error);
    }
  };

  const updateBookmark = async (id: number, reqestBody: BookmarkRequest) => {
    try {
      const url = `/bookmarks/${id}`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(reqestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('ブックマークの更新に失敗しました。' + error);
    }
  };

  const deleteBookmark = async (id: number) => {
    try {
      const url = `/bookmarks/${id}`;
      const options: RequestInit = { method: 'DELETE' };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('ブックマークの削除に失敗しました。' + error);
    }
  };

  return {
    getBookmarkByBookId,
    getBookmarkPage,
    createBookmark,
    updateBookmark,
    deleteBookmark,
  };
};

------------------------------------------------------------
use-api-favorite.ts

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { Favorite, FavoriteInfo, FavoritePage, FavoriteRequest } from '@/types';

export const useApiFavorite = () => {
  const { fetcher, fetcherWithAuth, mutationWithAuth } = useApi();

  const getFavoriteByBookId = async (bookId: string) => {
    try {
      const url = `/favorites/${bookId}`;
      const favorite = await fetcherWithAuth<Favorite>(url);
      return favorite;
    } catch (error) {
      throw new Error('お気に入りの読み込みが失敗しました。' + error);
    }
  };

  const getFavoritePage = async (page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/favorites?&page=${basePage}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
      const favoritePage = await fetcherWithAuth<FavoritePage>(url);
      return favoritePage;
    } catch (error) {
      throw new Error('お気に入り一覧の読み込みが失敗しました。' + error);
    }
  };

  const getFavoriteInfo = async (bookId: string, userId: number | undefined) => {
    try {
      const query = userId ? `?userId=${userId}` : '';
      const url = `/books/${bookId}/favorites/info${query}`;
      const favoriteInfo = await fetcher<FavoriteInfo>(url);
      return favoriteInfo;
    } catch (error) {
      throw new Error('お気に入り情報の読み込みが失敗しました。' + error);
    }
  };

  const createFavorite = async (reqestBody: FavoriteRequest) => {
    try {
      const url = `/favorites`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(reqestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('お気に入りの作成に失敗しました。' + error);
    }
  };

  const deleteFavorite = async (bookId: string) => {
    try {
      const url = `/favorites/${bookId}`;
      const options: RequestInit = { method: 'DELETE' };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('お気に入りの削除に失敗しました。' + error);
    }
  };

  return {
    getFavoriteByBookId,
    getFavoritePage,
    getFavoriteInfo,
    createFavorite,
    deleteFavorite,
  };
};

------------------------------------------------------------
use-api-review.ts

import { FETCH_REVIEWS_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { ReviewPage, ReviewRequest, ReviewSummary, SelfReviewExists } from '@/types';

export const useApiRevew = () => {
  const { fetcher, fetcherWithAuth, mutationWithAuth } = useApi();

  const getReviewPage = async (bookId: string, page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/books/${bookId}/reviews?&page=${basePage}&maxResults=${FETCH_REVIEWS_MAX_RESULTS}`;
      const reviewPage = await fetcher<ReviewPage>(url);
      return reviewPage;
    } catch (error) {
      throw new Error('レビュー一覧の読み込みが失敗しました。' + error);
    }
  };

  const getReviewSummary = async (bookId: string) => {
    try {
      const url = `/books/${bookId}/reviews/summary`;
      const reviewSummary = await fetcher<ReviewSummary>(url);
      return reviewSummary;
    } catch (error) {
      throw new Error('レビュー情報の読み込みが失敗しました。' + error);
    }
  };

  const checkSelfReviewExists = async (bookId: string) => {
    try {
      const url = `/reviews/self-review-exists/${bookId}`;
      const data = await fetcherWithAuth<SelfReviewExists>(url);
      return data.exists;
    } catch (error) {
      throw new Error('レビューの存在チェックに失敗しました。' + error);
    }
  };

  const createReview = async (reqestBody: ReviewRequest) => {
    try {
      const url = `/reviews`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(reqestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('レビューの作成に失敗しました。' + error);
    }
  };

  const updateReview = async (id: number, reqestBody: ReviewRequest) => {
    try {
      const url = `/reviews/${id}`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(reqestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('レビューの更新に失敗しました。' + error);
    }
  };

  const deleteReview = async (id: number) => {
    try {
      const url = `/reviews/${id}`;
      const options: RequestInit = {
        method: 'DELETE',
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('レビューの削除に失敗しました。' + error);
    }
  };

  return {
    getReviewPage,
    getReviewSummary,
    checkSelfReviewExists,
    createReview,
    updateReview,
    deleteReview,
  };
};

------------------------------------------------------------
bookmarks/

import BookmarkList from '@/components/bookmark/bookmark-list';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { useSearchParams } from 'react-router-dom';

export default function Page() {
  const [searchParams] = useSearchParams();
  const page = Number(searchParams.get('page') || '1');

  return (
    <>
      <div className="m-4 flex h-10 items-center">
        <p>ブックマーク一覧</p>
      </div>
      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={<div>Loading...</div>}>
          <BookmarkList page={page} />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}

------------------------------------------------------------
discover/

import BookListByGenreId from '@/components/book-list/book-list-by-genre-id';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import GenreConditionSelector from '@/components/genre-list/genre-condition-selector';
import GenreIdsSelector from '@/components/genre-list/genre-ids-selector';
import { Separator } from '@/components/ui/separator';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { useSearchParams } from 'react-router-dom';

export default function Page() {
  const [searchParams] = useSearchParams();
  const genreIdsQuery = searchParams.get('genreIds') || '';
  const conditionQuery = searchParams.get('condition') || '';
  const page = Number(searchParams.get('page') || '1');

  return (
    <>
      <div className="m-4 flex h-10 items-center justify-between">
        <p>ジャンル</p>
        <GenreConditionSelector />
      </div>

      <Separator className="my-4 bg-foreground/10" />

      <GenreIdsSelector />

      <Separator className="my-4 bg-foreground/10" />

      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={<BookListSkeleton />}>
          <BookListByGenreId
            genreIdsQuery={genreIdsQuery}
            conditionQuery={conditionQuery}
            page={page}
          />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}

------------------------------------------------------------
favorites/

import BookListFavorites from '@/components/book-list/book-list-favorites';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { useSearchParams } from 'react-router-dom';

export default function Page() {
  const [searchParams] = useSearchParams();
  const page = Number(searchParams.get('page') || '1');

  return (
    <>
      <div className="m-4 flex h-10 items-center">
        <p>お気に入り一覧</p>
      </div>

      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={<BookListSkeleton />}>
          <BookListFavorites page={page} />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}

------------------------------------------------------------
login/

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { LoginRequest } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef } from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';

export default function Page() {
  const emailRef = useRef<HTMLInputElement | null>(null);

  const location = useLocation();
  const navigate = useNavigate();
  const { login, setUser } = useAuth();
  const { getCurrentUser } = useApiUser();
  const { toast } = useToast();

  const loginMutation = useMutation({
    mutationFn: (requestBody: LoginRequest) => login(requestBody),
    onSuccess: async () => {
      const user = await getCurrentUser();
      setUser(user);
    },
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    emailRef.current?.focus();
  }, []);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;

    const requestBody: LoginRequest = { email, password };
    loginMutation.mutate(requestBody, {
      onSuccess: () => {
        const pathname = location.state?.from?.pathname || '/';
        const query = location.state?.from?.search || '';
        navigate(pathname + query, { replace: true });
      },
      onError: () => {
        toast({
          title: 'ログインできませんでした',
          description: 'メールアドレスまたはパスワードが違います。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">ログイン</p>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="email">
                メールアドレス
              </Label>
              <Input
                ref={emailRef}
                className="my-2 rounded-full"
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
              />
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                パスワード
              </Label>
              <PasswordInput
                className="my-2 rounded-full"
                id="password"
                name="password"
              />
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={loginMutation.isPending}
            >
              {loginMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                'ログイン'
              )}
            </Button>
          </form>

          <div className="mt-6 flex justify-center gap-x-1 text-xs">
            <p className="text-muted-foreground">アカウントをお持ちでない方はこちら</p>
            <Link to={'/signup'} className="text-primary hover:underline">
              新規登録
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
read/[bookId]/chapter/[pageNumber]

import BookReadBackground from '@/components/book-read/book-read-background';
import BookReadContent from '@/components/book-read/book-read-content';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { useParams } from 'react-router-dom';

export default function Page() {
  const params = useParams();
  const bookId = params.bookId || '';
  const chapterNumber = Number(params.chapterNumber) || 0;
  const pageNumber = Number(params.pageNumber) || 1;

  return (
    <>
      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={null}>
          <BookReadBackground bookId={bookId} />
        </Suspense>
      </ErrorBoundary>

      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={null}>
          <BookReadContent
            bookId={bookId}
            chapterNumber={chapterNumber}
            pageNumber={pageNumber}
          />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}

------------------------------------------------------------
table-of-contents/

import BookReadBackground from '@/components/book-read/book-read-background';
import BookTableOfContents from '@/components/book-read/book-table-of-contents';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { useParams } from 'react-router-dom';

export default function Page() {
  const params = useParams();
  const bookId = params.bookId || '';

  return (
    <>
      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={null}>
          <BookReadBackground bookId={bookId} />
        </Suspense>
      </ErrorBoundary>

      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={null}>
          <BookTableOfContents bookId={bookId} />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}

------------------------------------------------------------
search/

import BookListByQuery from '@/components/book-list/book-list-by-query';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { useSearchParams } from 'react-router-dom';

export default function Page() {
  const [searchParams] = useSearchParams();
  const query = searchParams.get('q') || '';
  const page = Number(searchParams.get('page') || '1');

  return (
    <>
      <div className="m-4 flex h-10 items-center">
        <p>
          「 {query} 」<span className="text-sm text-muted-foreground">の検索結果</span>
        </p>
      </div>

      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={<BookListSkeleton />}>
          <BookListByQuery query={query} page={page} />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}

------------------------------------------------------------
change-email/

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/use-auth';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/util';
import { ChangeEmail } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function Page() {
  const [emailErrorMessage, setEmailErrorMessage] = useState('');
  const [passwordErrorMessage, setPasswordErrorMessage] = useState('');

  const emailRef = useRef<HTMLInputElement | null>(null);
  const passwordRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { changeEmail } = useApiUser();
  const { toast } = useToast();

  const { user, logout } = useAuth();
  const { confirmDialog } = useConfirmDialog();

  const updateMutation = useMutation({
    mutationFn: (requestBody: ChangeEmail) => changeEmail(requestBody),
    onSuccess: async () => {
      await logout();
    },
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    emailRef.current?.focus();
  }, []);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;

    const isEmailValid = validateEmail();
    const isPasswordValid = validatePassword();

    if (!isEmailValid || !isPasswordValid) {
      return;
    }

    const { isCancel } = await confirmDialog({
      icon: '?',
      title: '本当に変更しますか？',
      message: 'メールアドレス変更後、一度ログアウトします。',
    });
    if (isCancel) return;

    const requestBody: ChangeEmail = { email, password };
    updateMutation.mutate(requestBody, {
      onSuccess: async () => {
        toast({ title: 'メールアドレスを変更し、ログアウトしました', duration: 5000 });
        navigate('/login');
      },
      onError: () => {
        toast({
          title: 'メールアドレスを変更できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateEmail = () => {
    const email = emailRef.current?.value as string;
    setEmailErrorMessage('');

    if (email === '') {
      setEmailErrorMessage('メールアドレスは必須です。');
      return false;
    }

    const emailRegex = /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(email)) {
      setEmailErrorMessage('無効なメールアドレスです。');
      return false;
    }

    return true;
  };

  const validatePassword = () => {
    const password = passwordRef.current?.value as string;
    setPasswordErrorMessage('');

    if (password === '') {
      setPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    return true;
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">メールアドレス変更</p>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="name">
                現在のメールアドレス
              </Label>
              <p className="my-2 rounded-full border border-transparent px-3 py-2 text-sm">
                {user?.email}
              </p>
            </div>

            <div>
              <Label className="text-xs" htmlFor="name">
                新しいメールアドレス
              </Label>
              <Input
                ref={emailRef}
                className={cn(
                  'my-2 rounded-full',
                  emailErrorMessage && 'border-destructive'
                )}
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
              />
              {emailErrorMessage && (
                <p className="text-xs text-destructive">{emailErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                現在のパスワード
              </Label>
              <PasswordInput
                ref={passwordRef}
                className={cn(
                  'my-2 rounded-full',
                  passwordErrorMessage && 'border-destructive'
                )}
                id="password"
                name="password"
              />
              {passwordErrorMessage && (
                <p className="text-xs text-destructive">{passwordErrorMessage}</p>
              )}
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={updateMutation.isPending}
            >
              {updateMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '変更'
              )}
            </Button>

            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/settings/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
change-password/

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/util';
import { ChangePassword } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function Page() {
  const [currentPasswordErrorMessage, setCurrentPasswordErrorMessage] = useState('');
  const [newPasswordErrorMessage, setNewPasswordErrorMessage] = useState('');
  const [confirmPasswordErrorMessage, setConfirmPasswordErrorMessage] = useState('');

  const currentPasswordRef = useRef<HTMLInputElement | null>(null);
  const newPasswordRef = useRef<HTMLInputElement | null>(null);
  const confirmPasswordRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { changePassword } = useApiUser();
  const { toast } = useToast();

  const { confirmDialog } = useConfirmDialog();

  const updateMutation = useMutation({
    mutationFn: (requestBody: ChangePassword) => changePassword(requestBody),
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    currentPasswordRef.current?.focus();
  }, []);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const currentPassword = form.get('current-password') as string;
    const newPassword = form.get('new-password') as string;
    const confirmPassword = form.get('confirm-password') as string;

    const isCurrentPasswrdValid = validateCurrentPassword();
    const isNewPasswrdValid = validateNewPassword();
    const isConfirmPasswrdValid = validateConfirmPassword();

    if (!isCurrentPasswrdValid || !isNewPasswrdValid || !isConfirmPasswrdValid) {
      return;
    }

    const { isCancel } = await confirmDialog({
      icon: '?',
      title: '本当に変更しますか？',
      message: 'パスワードを変更します。',
    });
    if (isCancel) return;

    const requestBody: ChangePassword = {
      currentPassword,
      newPassword,
      confirmPassword,
    };
    updateMutation.mutate(requestBody, {
      onSuccess: () => {
        toast({ title: 'パスワードを変更しました' });
        navigate('/settings/profile');
      },
      onError: () => {
        toast({
          title: 'パスワードを変更できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateCurrentPassword = () => {
    setCurrentPasswordErrorMessage('');
    const password = currentPasswordRef.current?.value as string;

    if (password === '') {
      setCurrentPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    return true;
  };

  const validateNewPassword = () => {
    setNewPasswordErrorMessage('');
    const password = newPasswordRef.current?.value as string;

    if (password === '') {
      setNewPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    if (password.length < 4) {
      setNewPasswordErrorMessage('パスワードは4文字以上で設定してください。');
      return false;
    }

    return true;
  };

  const validateConfirmPassword = () => {
    setConfirmPasswordErrorMessage('');
    const newPassword = newPasswordRef.current?.value as string;
    const confirmPassword = confirmPasswordRef.current?.value as string;

    if (newPassword !== confirmPassword) {
      setConfirmPasswordErrorMessage(
        '新しいパスワードと確認用パスワードが一致していません。'
      );
      return false;
    }

    return true;
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">パスワード変更</p>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="current-password">
                現在のパスワード
              </Label>
              <PasswordInput
                ref={currentPasswordRef}
                className={cn(
                  'my-2 rounded-full',
                  currentPasswordErrorMessage && 'border-destructive'
                )}
                id="current-password"
                name="current-password"
              />
              {currentPasswordErrorMessage && (
                <p className="text-xs text-destructive">{currentPasswordErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="new-password">
                新しいパスワード
              </Label>
              <PasswordInput
                ref={newPasswordRef}
                className={cn(
                  'my-2 rounded-full',
                  newPasswordErrorMessage && 'border-destructive'
                )}
                id="new-password"
                name="new-password"
              />
              {newPasswordErrorMessage && (
                <p className="text-xs text-destructive">{newPasswordErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="confirm-password">
                新しいパスワード（確認用）
              </Label>
              <PasswordInput
                ref={confirmPasswordRef}
                className={cn(
                  'my-2 rounded-full',
                  confirmPasswordErrorMessage && 'border-destructive'
                )}
                id="confirm-password"
                name="confirm-password"
              />
              {confirmPasswordErrorMessage && (
                <p className="text-xs text-destructive">{confirmPasswordErrorMessage}</p>
              )}
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={updateMutation.isPending}
            >
              {updateMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '変更'
              )}
            </Button>

            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/settings/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
change-user-info/

import Logo from '@/components/layout/logo';
import AvatarCarousel from '@/components/settings/avatar-carousel';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/util';
import { UpdateCurrentUser } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function Page() {
  const [nameErrorMessage, setNameErrorMessage] = useState('');

  const nameRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { updateCurrentUser } = useApiUser();
  const { toast } = useToast();

  const { user, setUser } = useAuth();

  const [avatarUrl, setAvaterUrl] = useState(user?.avatarUrl || '');

  const updateMutation = useMutation({
    mutationFn: (requestBody: UpdateCurrentUser) => updateCurrentUser(requestBody),
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    if (nameRef.current && user) {
      nameRef.current.focus();
      nameRef.current.value = user.name || '';
    }
  }, [user]);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const name = form.get('name') as string;

    const isNameValid = validateName();

    if (!isNameValid) {
      return;
    }

    const requestBody: UpdateCurrentUser = { name, avatarUrl };
    updateMutation.mutate(requestBody, {
      onSuccess: () => {
        // 名前とアバターURLだけなので楽観的に更新しておく
        const newUser = user ? { ...user, name, avatarUrl } : null;
        setUser(newUser);

        toast({ title: 'ユーザー情報を変更しました' });
        navigate('/settings/profile');
      },
      onError: () => {
        toast({
          title: 'ユーザー情報を変更できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateName = () => {
    const name = nameRef.current?.value as string;
    setNameErrorMessage('');

    if (name === '') {
      setNameErrorMessage('ユーザー名は必須です。');
      return false;
    }

    return true;
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">ユーザー情報の編集</p>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="name">
                ユーザー名
              </Label>
              <Input
                ref={nameRef}
                className={cn(
                  'my-2 rounded-full',
                  nameErrorMessage && 'border-destructive'
                )}
                id="name"
                name="name"
                autoComplete="off"
                spellCheck="false"
              />
              {nameErrorMessage && (
                <p className="text-xs text-destructive">{nameErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="name">
                アバター画像
              </Label>
              <AvatarCarousel value={avatarUrl} onChange={setAvaterUrl} />
            </div>

            <Button
              className="w-full rounded-full"
              type="submit"
              disabled={updateMutation.isPending}
            >
              {updateMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '変更'
              )}
            </Button>

            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/settings/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
profile/

import Logo from '@/components/layout/logo';
import ProfileCounts from '@/components/settings/profile-counts';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { useAuth } from '@/hooks/use-auth';
import ErrorElement from '@/routes/error-element';
import { KeyRoundIcon, MailIcon, UserRoundIcon } from 'lucide-react';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { Link } from 'react-router-dom';

export default function Page() {
  const { user } = useAuth();

  if (!user) return null;

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">プロフィール</p>

      <Card className="w-80 overflow-hidden rounded-3xl sm:w-96">
        <CardHeader className="h-80 w-full bg-gradient-to-tr from-secondary to-primary">
          <div className="flex flex-col items-center pt-8">
            <Avatar className="mb-4 size-24">
              <AvatarImage
                className="bg-primary"
                src={user.avatarUrl}
                alt="avatar-image"
              />
              <AvatarFallback className="bg-primary text-5xl font-semibold">
                {user.name.slice(0, 1)}
              </AvatarFallback>
            </Avatar>
            <p className="text-xl font-semibold">{user.name}</p>
            <p className="text-sm">{user.email}</p>
          </div>

          <ErrorBoundary fallback={<ErrorElement />}>
            <Suspense fallback={null}>
              <ProfileCounts />
            </Suspense>
          </ErrorBoundary>
        </CardHeader>

        <CardContent className="relative p-6">
          <ul>
            <li className="flex items-center p-2">
              <UserRoundIcon className="mr-4" />
              <p>ユーザー情報</p>
              <div className="flex-1"></div>
              <Button className="rounded-full bg-transparent" variant="outline" asChild>
                <Link to="/settings/change-user-info">変更</Link>
              </Button>
            </li>
            <li className="flex items-center p-2">
              <MailIcon className="mr-4" />
              <p>メールアドレス</p>
              <div className="flex-1"></div>
              <Button className="rounded-full bg-transparent" variant="outline" asChild>
                <Link to="/settings/change-email">変更</Link>
              </Button>
            </li>
            <li className="flex items-center p-2">
              <KeyRoundIcon className="mr-4" />
              <p>パスワード</p>
              <div className="flex-1"></div>
              <Button className="rounded-full bg-transparent" variant="outline" asChild>
                <Link to="/settings/change-password">変更</Link>
              </Button>
            </li>
          </ul>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
signup/

import Logo from '@/components/layout/logo';
import AvatarCarousel from '@/components/settings/avatar-carousel';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/util';
import { SignupRequest } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import { useEffect, useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function Page() {
  const [emailErrorMessage, setEmailErrorMessage] = useState('');
  const [passwordErrorMessage, setPasswordErrorMessage] = useState('');
  const [nameErrorMessage, setNameErrorMessage] = useState('');

  const emailRef = useRef<HTMLInputElement | null>(null);
  const passwordRef = useRef<HTMLInputElement | null>(null);
  const nameRef = useRef<HTMLInputElement | null>(null);
  const [avatarUrl, setAvatarUrl] = useState('');

  const navigate = useNavigate();
  const { signup, setUser } = useAuth();
  const { getCurrentUser } = useApiUser();
  const { toast } = useToast();

  const signupMutation = useMutation({
    mutationFn: (requestBody: SignupRequest) => signup(requestBody),
    onSuccess: async () => {
      const user = await getCurrentUser();
      setUser(user);
    },
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    emailRef.current?.focus();
  }, []);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;
    const name = form.get('name') as string;

    const isEmailValid = validateEmail();
    const isPasswordValid = validatePassword();
    const isNameValid = validateName();

    if (!isEmailValid || !isPasswordValid || !isNameValid) {
      return;
    }

    const requestBody: SignupRequest = { email, password, name, avatarUrl };
    signupMutation.mutate(requestBody, {
      onSuccess: () => {
        navigate('/');
      },
      onError: () => {
        toast({
          title: '新規登録できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateEmail = () => {
    const email = emailRef.current?.value as string;
    setEmailErrorMessage('');

    if (email === '') {
      setEmailErrorMessage('メールアドレスは必須です。');
      return false;
    }

    const emailRegex = /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(email)) {
      setEmailErrorMessage('無効なメールアドレスです。');
      return false;
    }

    return true;
  };

  const validatePassword = () => {
    const password = passwordRef.current?.value as string;
    setPasswordErrorMessage('');

    if (password === '') {
      setPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    if (password.length < 4) {
      setPasswordErrorMessage('パスワードは4文字以上で設定してください。');
      return false;
    }

    return true;
  };

  const validateName = () => {
    const name = nameRef.current?.value as string;
    setNameErrorMessage('');

    if (name === '') {
      setNameErrorMessage('ユーザー名は必須です。');
      return false;
    }

    return true;
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">アカウントの作成</p>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="email">
                メールアドレス
              </Label>
              <Input
                ref={emailRef}
                className={cn(
                  'my-2 rounded-full',
                  emailErrorMessage && 'border-destructive'
                )}
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
              />
              {emailErrorMessage && (
                <p className="text-xs text-destructive">{emailErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                パスワード
              </Label>
              <PasswordInput
                ref={passwordRef}
                className={cn(
                  'my-2 rounded-full',
                  passwordErrorMessage && 'border-destructive'
                )}
                id="password"
                name="password"
              />
              {passwordErrorMessage && (
                <p className="text-xs text-destructive">{passwordErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="name">
                ユーザー名
              </Label>
              <Input
                ref={nameRef}
                className={cn(
                  'my-2 rounded-full',
                  nameErrorMessage && 'border-destructive'
                )}
                id="name"
                name="name"
                autoComplete="off"
                spellCheck="false"
              />
              {nameErrorMessage && (
                <p className="text-xs text-destructive">{nameErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="name">
                アバター画像
              </Label>
              <AvatarCarousel value={avatarUrl} onChange={setAvatarUrl} />
            </div>

            <Button
              className="w-full rounded-full"
              type="submit"
              disabled={signupMutation.isPending}
            >
              {signupMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '新規登録'
              )}
            </Button>
          </form>

          <div className="mt-6 flex justify-center gap-x-1 text-xs">
            <p className="text-muted-foreground">アカウントをお持ちですか？</p>
            <Link to={'/login'} className="text-primary hover:underline">
              ログイン
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
error-element.tsx

export default function ErrorElement() {
  return (
    <div className="flex h-24 w-full items-center justify-center">
      <p>読み込みエラー</p>
    </div>
  );
}

------------------------------------------------------------
page.tsx

import BookListNewReleases from '@/components/book-list/book-list-new-releases';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import GenreListSkeleton from '@/components/genre-list/genre-list-skeleton';
import GenreListTopPage from '@/components/genre-list/genre-list-top-page';
import Hero from '@/components/layout/hero';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';

export default function Page() {
  return (
    <>
      <Hero />

      <div className="flex flex-col">
        <p className="font-bold text-primary">ジャンル</p>

        <div className="my-4">
          <ErrorBoundary fallback={<ErrorElement />}>
            <Suspense fallback={<GenreListSkeleton />}>
              <GenreListTopPage />
            </Suspense>
          </ErrorBoundary>
        </div>
      </div>

      <div className="flex flex-col">
        <p className="mb-4 font-bold text-primary">ニューリリース</p>
        <ErrorBoundary fallback={<ErrorElement />}>
          <Suspense fallback={<BookListSkeleton />}>
            <BookListNewReleases />
          </Suspense>
        </ErrorBoundary>
      </div>
    </>
  );
}

------------------------------------------------------------
protected-route.tsx

import { useAuth } from '@/hooks/use-auth';
import { Navigate, Outlet, useLocation } from 'react-router-dom';

export const ProtectedRoute = () => {
  const location = useLocation();
  const { accessToken, isLoading } = useAuth();

  if (isLoading) return null;

  return (
    <>
      {accessToken ? (
        <Outlet />
      ) : (
        <Navigate to="/login" state={{ from: location }} replace />
      )}
    </>
  );
};

------------------------------------------------------------
route.tsx

import BookDetailPage from '@/routes/book/[bookId]/page';
import BookmarksPage from '@/routes/bookmarks/page';
import DiscoverPage from '@/routes/discover/page';
import FavoritesPage from '@/routes/favorites/page';
import RootLayout from '@/routes/layout';
import LoginPage from '@/routes/login/page';
import RootPage from '@/routes/page';
import { ProtectedRoute } from '@/routes/protected-route';
import BookReadPage from '@/routes/read/[bookId]/chapter/[chapterNumber]/page/[pageNumber]/page';
import BookReadTableOfContentsPage from '@/routes/read/[bookId]/table-of-contents/page';
import SearchPage from '@/routes/search/page';
import ChangeEmailPage from '@/routes/settings/change-email/page';
import ChangePasswordPage from '@/routes/settings/change-password/page';
import ChangeUserInfoPage from '@/routes/settings/change-user-info/page';
import ProfilePage from '@/routes/settings/profile/page';
import SignupPage from '@/routes/signup/page';
import { createBrowserRouter, createRoutesFromElements, Route } from 'react-router-dom';

export const router = createBrowserRouter(
  createRoutesFromElements(
    <Route>
      <Route path="/" element={<RootLayout />}>
        <Route index element={<RootPage />} />

        <Route path="book/:bookId" element={<BookDetailPage />} />

        <Route path="read/:bookId">
          <Route path="table-of-contents" element={<BookReadTableOfContentsPage />} />
        </Route>

        <Route path="search">
          <Route index element={<SearchPage />} />
        </Route>

        <Route path="discover">
          <Route index element={<DiscoverPage />} />
        </Route>

        <Route path="login">
          <Route index element={<LoginPage />} />
        </Route>

        <Route path="signup">
          <Route index element={<SignupPage />} />
        </Route>

        {/* 以下、認証が必要な画面 */}
        <Route element={<ProtectedRoute />}>
          <Route path="favorites">
            <Route index element={<FavoritesPage />} />
          </Route>

          <Route path="bookmarks">
            <Route index element={<BookmarksPage />} />
          </Route>

          <Route path="settings">
            <Route path="profile" element={<ProfilePage />} />
            <Route path="change-user-info" element={<ChangeUserInfoPage />} />
            <Route path="change-email" element={<ChangeEmailPage />} />
            <Route path="change-password" element={<ChangePasswordPage />} />
          </Route>

          <Route path="read/:bookId">
            <Route path="chapter/:chapterNumber">
              <Route path="page/:pageNumber" element={<BookReadPage />} />
            </Route>
          </Route>
        </Route>
      </Route>
    </Route>
  )
);

------------------------------------------------------------
auth-provider.tsx

import { BOOKS_API_ENDPOINT } from '@/constants/constants';
import { AccessToken, ErrorResponse, LoginRequest, SignupRequest, User } from '@/types';
import { createContext, useEffect, useState } from 'react';

type ContextType = {
  accessToken: string | null;
  isLoading: boolean;
  user: User | null;
  setUser: (user: User | null) => void;
  login: (requestBody: LoginRequest) => Promise<void>;
  signup: (requestBody: SignupRequest) => Promise<void>;
  logout: () => Promise<void>;
  refreshAccessToken: () => Promise<string | null>;
};

const AuthContext = createContext<ContextType | undefined>(undefined);

const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [accessToken, setAccessToken] = useState<string | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const login = async ({ email, password }: LoginRequest) => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/login`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        const data = (await response.json()) as ErrorResponse;
        throw new Error(
          `[STATUS] ${response.status} [MESSAGE] ${data.message} [URL] ${url}`
        );
      }

      const data = (await response.json()) as AccessToken;
      setAccessToken(data.accessToken);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      throw new Error('ログインできませんでした。' + error);
    }
  };

  const signup = async ({ email, password, name, avatarUrl }: SignupRequest) => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/signup`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password, name, avatarUrl }),
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        const data = (await response.json()) as ErrorResponse;
        throw new Error(
          `[STATUS] ${response.status} [MESSAGE] ${data.message} [URL] ${url}`
        );
      }

      const data = (await response.json()) as AccessToken;
      setAccessToken(data.accessToken);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      throw new Error('サインアップできませんでした。' + error);
    }
  };

  const logout = async () => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/logout`;
      const options: RequestInit = {
        method: 'POST',
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        const data = (await response.json()) as ErrorResponse;
        throw new Error(
          `[STATUS] ${response.status} [MESSAGE] ${data.message} [URL] ${url}`
        );
      }

      setAccessToken(null);
      setUser(null);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      throw new Error('ログアウトに失敗しました。' + error);
    }
  };

  const refreshAccessToken = async () => {
    const accessToken = await fetchAccessToken();
    setAccessToken(accessToken);
    if (!accessToken) {
      alert('セッションが切れたため、自動ログアウトしました。');
      setUser(null);
    }
    return accessToken;
  };

  const fetchAccessToken = async () => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/refresh-token`;
      const options: RequestInit = {
        method: 'POST',
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        throw new Error('Failed to refresh token');
      }

      const data = (await response.json()) as AccessToken;
      return data.accessToken;
    } catch {
      return null;
    }
  };

  useEffect(() => {
    // リロードするとアクセストークンがメモリから消えてしまうので
    // 初期読み込み時にリフレッシュトークンを使って再取得する
    const init = async () => {
      const accessToken = await fetchAccessToken();
      setAccessToken(accessToken);
      setIsLoading(false);
    };
    init();
  }, []);

  return (
    <AuthContext.Provider
      value={{
        accessToken,
        isLoading,
        user,
        setUser,
        login,
        signup,
        logout,
        refreshAccessToken,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export { AuthContext, AuthProvider };

------------------------------------------------------------
bookmark.ts

import { Book } from '@/types/book';

export interface Bookmark {
  id: number;
  userId: number;
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
  note: string;
  chapterTitle: string;
  updatedAt: string;
  book: Book;
}

export interface BookmarkPage {
  page: number;
  totalPages: number;
  totalItems: number;
  bookmarks: Bookmark[];
}

export interface BookmarkRequest {
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
  note: string;
}

------------------------------------------------------------
review.ts

import { Book } from '@/types';

export interface Review {
  id: number;
  userId: number;
  bookId: string;
  name: string;
  avatarUrl: string;
  comment: string;
  rating: number;
  createdAt: string;
  updatedAt: string;
  book: Book;
}

export interface ReviewPage {
  page: number;
  totalPages: number;
  totalItems: number;
  reviews: Review[];
}

export interface ReviewSummary {
  bookId: string;
  reviewCount: number;
  averageRating: number;
}

export interface ReviewRequest {
  bookId: string;
  comment: string;
  rating: number;
}

export interface SelfReviewExists {
  exists: boolean;
}

------------------------------------------------------------
user.ts

export interface User {
  id: number;
  email: string;
  roles: string[];
  name: string;
  avatarUrl: string;
}

export interface ProfileCounts {
  favoriteCount: number;
  bookmarkCount: number;
  reviewCount: number;
}

export interface UserDetails {
  user: User;
  profieleCounts: ProfileCounts;
}

export interface SimpleUserInfo {
  id: number;
  name: string;
  avatarUrl: string;
}

export interface UpdateCurrentUser {
  name: string;
  avatarUrl: string;
}

export interface ChangePassword {
  currentPassword: string;
  newPassword: string;
  confirmPassword: string;
}

export interface ChangeEmail {
  email: string;
  password: string;
}

------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------


book-read-skeleton.tsx
book-read.tsx
book-read-of-contents-skeleton.tsx
genre-selector.tsx
login-button.tsx

