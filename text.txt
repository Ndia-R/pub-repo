10

------------------------------------------------------------
auth.ts

import { fetchApi } from '@/api/client';
import { AccessToken, LoginRequest, SignupRequest, User } from '@/types';

export const login = async (requestBody: LoginRequest) => {
  try {
    const endpoint = `/login`;
    const options: RequestInit = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
      credentials: 'include',
    };
    const response = await fetchApi<AccessToken>(endpoint, options);
    return response.data;
  } catch (error) {
    console.error(error);
    throw new Error('ログインに失敗しました。');
  }
};

export const signup = async (requestBody: SignupRequest) => {
  try {
    const endpoint = `/signup`;
    const options: RequestInit = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
      credentials: 'include',
    };
    const response = await fetchApi<AccessToken>(endpoint, options);
    return response.data;
  } catch (error) {
    console.error(error);
    throw new Error('サインアップに失敗しました。');
  }
};

export const logout = async () => {
  try {
    const endpoint = `/logout`;
    const options: RequestInit = {
      method: 'POST',
      credentials: 'include',
    };
    await fetchApi(endpoint, options);
  } catch (error) {
    console.error(error);
    throw new Error('ログアウトに失敗しました。');
  }
};

export const getAccessToken = async () => {
  try {
    const endpoint = `/refresh-token`;
    const options: RequestInit = {
      method: 'POST',
      credentials: 'include',
    };
    const response = await fetchApi<AccessToken>(endpoint, options);
    return response.data.accessToken;
  } catch (error) {
    console.error(error);
    throw new Error('トークンの取得に失敗しました。');
  }
};

export const getUser = async (token: string | null) => {
  if (!token) return null;

  try {
    const endpoint = `/me`;
    const options: RequestInit = {
      headers: { Authorization: `Bearer ${token}` },
    };
    const response = await fetchApi<User>(endpoint, options);
    return response.data;
  } catch (error) {
    console.error(error);
    throw new Error('ユーザー情報の取得に失敗しました。');
  }
};

------------------------------------------------------------
client.ts

import { BOOKS_API_BASE_URL } from '@/constants/constants';
import { ApiResponse, ErrorResponse } from '@/types';

export const fetchApi = async <T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<ApiResponse<T>> => {
  const url = `${BOOKS_API_BASE_URL}${endpoint}`;
  const response = await fetch(url, { ...options });

  if (!response.ok) {
    throw new Error(await generateErrorMessage(url, response));
  }

  return await parseApiResponse<T>(response);
};

export const parseApiResponse = async <T>(
  response: Response
): Promise<ApiResponse<T>> => {
  const contentType = response.headers.get('content-type');
  const data = contentType?.includes('application/json')
    ? await response.json()
    : ((await response.text()) as unknown as T);
  return {
    data,
    status: response.status,
    statusText: response.statusText,
  };
};

export const generateErrorMessage = async (url: string, response: Response) => {
  let errorMessage = `[URL] ${url}`;
  try {
    const errorResponse = (await response.json()) as ErrorResponse;
    errorMessage += ` [MESSAGE] ${errorResponse.message} [STATUS] ${response.status}(${errorResponse.status})`;
  } catch {
    // JSON でない場合は無視
  }
  return errorMessage;
};

------------------------------------------------------------
constants.ts

export const TITLE_LOGO = 'My Books';

export const BOOKS_API_BASE_URL = `${import.meta.env.VITE_BASE_URL}/api/v1`;
export const IMAGE_BASE_URL = `${import.meta.env.VITE_BASE_URL}/images`;

export const BOOK_IMAGE_BASE_URL = `${IMAGE_BASE_URL}/my-books`;
export const AVATAR_IMAGE_BASE_URL = `${IMAGE_BASE_URL}/avatars`;

export const FETCH_BOOKS_MAX_RESULTS = 20;
export const FETCH_REVIEWS_MAX_RESULTS = 3;

export const FETCH_FAVORITES_MAX_RESULTS = 5;
export const FETCH_MY_REVIEWS_MAX_RESULTS = 5;
export const FETCH_BOOKMARKS_MAX_RESULTS = 5;

------------------------------------------------------------
auth-provider.tsx

import * as AuthApi from '@/api/auth';
import { generateErrorMessage, parseApiResponse } from '@/api/client';
import { BOOKS_API_BASE_URL } from '@/constants/constants';
import { ApiResponse, LoginRequest, SignupRequest, User } from '@/types';
import { createContext, useContext, useEffect, useState } from 'react';
import { toast } from 'sonner';

type AuthProviderProps = {
  children: React.ReactNode;
};

type AuthProviderState = {
  accessToken: string | null;
  user: User | null;
  isLoading: boolean;
  login: (requestBody: LoginRequest) => Promise<void>;
  signup: (requestBody: SignupRequest) => Promise<void>;
  logout: () => Promise<void>;
  refreshUserInfo: () => Promise<void>;
  fetchApiWithAuth: <T>(
    endpoint: string,
    options?: RequestInit
  ) => Promise<ApiResponse<T>>;
};

const AuthProviderContext = createContext<AuthProviderState | undefined>(
  undefined
);

export function AuthProvider({ children }: AuthProviderProps) {
  const [accessToken, setAccessToken] = useState<string | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const login = async (requestBody: LoginRequest) => {
    try {
      const response = await AuthApi.login(requestBody);
      setAccessToken(response.accessToken);
      const user = await AuthApi.getUser(response.accessToken);
      setUser(user);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      console.error(error);
      throw new Error('ログインに失敗しました。');
    }
  };

  const signup = async (requestBody: SignupRequest) => {
    try {
      const response = await AuthApi.signup(requestBody);
      setAccessToken(response.accessToken);
      const user = await AuthApi.getUser(response.accessToken);
      setUser(user);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      console.error(error);
      throw new Error('サインアップに失敗しました。');
    }
  };

  const logout = async () => {
    try {
      await AuthApi.logout();
    } catch (error) {
      console.error(error);
      throw new Error('ログアウトに失敗しました。');
    } finally {
      setAccessToken(null);
      setUser(null);
    }
  };

  const refreshUserInfo = async () => {
    try {
      const user = await AuthApi.getUser(accessToken);
      setUser(user);
    } catch (error) {
      setUser(null);
      console.error(error);
      throw new Error('ユーザー情報の取得に失敗しました。');
    }
  };

  const fetchApiWithAuth = async <T,>( // <T,>の「,」は<T>がJSXと解釈されないためにつけている
    endpoint: string,
    options: RequestInit = {}
  ) => {
    const url = `${BOOKS_API_BASE_URL}${endpoint}`;
    let response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${accessToken}`,
      },
    });

    if (response.status === 401) {
      try {
        const newAccessToken = await AuthApi.getAccessToken();
        setAccessToken(newAccessToken);

        response = await fetch(url, {
          ...options,
          headers: {
            ...options.headers,
            Authorization: `Bearer ${newAccessToken}`,
          },
        });
      } catch {
        logout();
        toast.error('ログインセッションの期限が切れました。', {
          description: '作業を続けるには再度ログインしてください。',
          duration: 5000,
        });
        throw new Error('ログインセッションの期限が切れました。');
      }
    }

    if (!response.ok) {
      throw new Error(await generateErrorMessage(endpoint, response));
    }

    return await parseApiResponse<T>(response);
  };

  useEffect(() => {
    // リロードするとメモリからアクセストークンが消えてしまうので
    // 初期読み込み時にリフレッシュトークンを使って再取得する
    const init = async () => {
      try {
        const accessToken = await AuthApi.getAccessToken();
        setAccessToken(accessToken);
        const user = await AuthApi.getUser(accessToken);
        setUser(user);
      } catch {
        setAccessToken(null);
        setUser(null);
        console.warn('自動ログインできませんでした。');
      }

      setIsLoading(false);
    };
    init();
  }, []);

  const value = {
    accessToken,
    user,
    isLoading,
    login,
    signup,
    logout,
    refreshUserInfo,
    fetchApiWithAuth,
  };

  return (
    <AuthProviderContext.Provider value={value}>
      {children}
    </AuthProviderContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthProviderContext);

  if (context === undefined)
    throw new Error('useAuth must be used within an AuthProvider');

  return context;
};

------------------------------------------------------------
api.ts

export interface ApiResponse<T> {
  data: T;
  status: number;
  statusText: string;
}

export interface ErrorResponse {
  message: string;
  status: string;
}

------------------------------------------------------------
auth.ts

export interface LoginRequest {
  email: string;
  password: string;
}

export interface SignupRequest {
  email: string;
  password: string;
  name: string;
  avatarPath: string;
}

export interface AccessToken {
  accessToken: string;
}

------------------------------------------------------------
index.ts

export * from './api';
export * from './auth';
export * from './book';
export * from './book-chapter';
export * from './book-content-page';
export * from './bookmark';
export * from './favorite';
export * from './genre';
export * from './review';
export * from './user';

------------------------------------------------------------
.env.development

VITE_BASE_URL=https://localhost

------------------------------------------------------------
.env.production

VITE_BASE_URL=https://vsv-emerald.skygroup.local
# VITE_BASE_URL=https://localhost

------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
