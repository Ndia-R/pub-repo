７７ファイル

------------------------------------------------------------
book-detail.tsx

import FavoriteCountIcon from '@/components/count-icon/favorite-count-icon';
import ReviewCountIcon from '@/components/count-icon/review-count-icon';
import GenreList from '@/components/genres/genre-list';
import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { BOOK_IMAGE_BASE_URL } from '@/constants/constants';
import { useApiBook } from '@/hooks/api/use-api-book';
import { usePageTitle } from '@/hooks/use-page-title';
import { formatDateJP, formatIsbn, formatPrice } from '@/lib/utils';
import { useSuspenseQuery } from '@tanstack/react-query';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
};

export default function BookDetail({ bookId }: Props) {
  const { getBookDetailsById } = useApiBook();

  const { data: book } = useSuspenseQuery({
    queryKey: ['getBookDetailsById', bookId],
    queryFn: () => getBookDetailsById(bookId),
  });

  usePageTitle(book.title);

  return (
    <div className="flex flex-col justify-center p-3 pt-10 sm:p-6 lg:flex-row">
      <div className="flex flex-col items-center justify-center lg:w-1/2">
        <Link to={`/read/${bookId}/table-of-contents`} className="size-fit">
          <img
            className="h-[360px] rounded object-cover sm:h-[480px]"
            src={BOOK_IMAGE_BASE_URL + book.imagePath}
            alt={book.title}
          />
        </Link>
        <div className="mt-2 flex flex-col items-center justify-around sm:w-[440px] sm:flex-row">
          <Rating rating={book.averageRating} readOnly />
          <div className="flex justify-center gap-x-2">
            <ReviewCountIcon reviewCount={book.reviewCount} />
            <FavoriteCountIcon bookId={bookId} showCount={true} />
          </div>
        </div>
        <div className="my-4 flex items-center">
          <Button
            className="w-44 rounded-full bg-transparent"
            variant="outline"
            asChild
          >
            <Link to={`/read/${bookId}/table-of-contents`}>目次を見る</Link>
          </Button>
        </div>
      </div>

      <div className="p-4 lg:w-1/2">
        <h1 className="text-3xl font-bold sm:text-4xl">{book.title}</h1>

        <div className="my-4 flex w-full flex-wrap items-center justify-end gap-x-3">
          <p>著者</p>
          {book.authors.map((author) => (
            <p className="text-lg font-bold sm:text-2xl" key={author}>
              {author}
            </p>
          ))}
        </div>

        <GenreList genres={book.genres} variant="outline" />

        <div className="my-6 md:my-10">{book.description}</div>

        <div className="flex flex-col justify-between gap-y-4 lg:flex-row">
          <div className="flex flex-col gap-y-1 text-muted-foreground">
            <div className="flex">
              <p className="min-w-20">ISBN</p>
              <p>{formatIsbn(book.isbn)}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">出版社</p>
              <p>{book.publisher}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">発売日</p>
              <time
                className="tracking-wide"
                dateTime={
                  Date.parse(book.publishedDate) ? book.publishedDate : ''
                }
              >
                {formatDateJP(book.publishedDate)}
              </time>
            </div>
            <div className="flex">
              <p className="min-w-20">ページ数</p>
              <p>{`${book.pageCount}ページ`}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">価格</p>
              <p>{formatPrice(book.price)}</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
book-read-content.tsx

import BookmarkCreateDialog from '@/components/bookmarks/bookmark-create-dialog';
import BookmarkUpdateDialog from '@/components/bookmarks/bookmark-update-dialog';
import { Button } from '@/components/ui/button';
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useApiBookmark } from '@/hooks/api/use-api-bookmark';
import { usePageTitle } from '@/hooks/use-page-title';
import {
  getCurrentPageText,
  getPageLink,
  getPagePosition,
} from '@/lib/book-read-content';
import { cn } from '@/lib/utils';
import { Bookmark, BookmarkRequest } from '@/types';
import {
  useMutation,
  useQueryClient,
  useSuspenseQueries,
} from '@tanstack/react-query';
import {
  BookmarkIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  TableOfContentsIcon,
} from 'lucide-react';
import { useState } from 'react';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
};

export default function BookReadContent({
  bookId,
  chapterNumber,
  pageNumber,
}: Props) {
  const [isOpenBookmarkCreateDialog, setIsOpenBookmarkCreateDialog] =
    useState(false);
  const [isOpenBookmarkUpdateDialog, setIsOpenBookmarkUpdateDialog] =
    useState(false);

  const { getBookTableOfContents, getBookContentPage } = useApiBook();
  const {
    getBookmarkByBookId,
    createBookmark,
    updateBookmark,
    deleteBookmark,
  } = useApiBookmark();

  const [
    { data: bookTableOfContents },
    { data: bookContentPage },
    { data: bookmark },
  ] = useSuspenseQueries({
    queries: [
      {
        queryKey: ['getBookTableOfContents', bookId],
        queryFn: () => getBookTableOfContents(bookId),
      },
      {
        queryKey: ['getBookContentPage', bookId, chapterNumber, pageNumber],
        queryFn: () => getBookContentPage(bookId, chapterNumber, pageNumber),
      },
      {
        queryKey: ['getBookmarkByBookId', bookId],
        queryFn: () => getBookmarkByBookId(bookId),
        select: (bookmarks: Bookmark[]) =>
          bookmarks.find(
            (bookmark) =>
              bookmark.bookId === bookId &&
              bookmark.chapterNumber === chapterNumber &&
              bookmark.pageNumber === pageNumber,
          ),
      },
    ],
  });

  const queryClient = useQueryClient();

  const onSuccess = () => {
    queryClient.invalidateQueries({
      queryKey: ['getBookmarkByBookId', bookId],
    });
  };

  const onError = (error: Error) => {
    console.error(error);
  };

  const createMutation = useMutation({
    mutationFn: (requestBody: BookmarkRequest) => createBookmark(requestBody),
    onSuccess,
    onError,
  });

  const updateMutation = useMutation({
    mutationFn: ({
      id,
      requestBody,
    }: {
      id: number;
      requestBody: BookmarkRequest;
    }) => updateBookmark(id, requestBody),
    onSuccess,
    onError,
  });

  const deleteMutation = useMutation({
    mutationFn: (bookmarkId: number) => deleteBookmark(bookmarkId),
    onSuccess,
    onError,
  });

  const handleClickCreate = () => {
    setIsOpenBookmarkCreateDialog(true);
  };

  const handleClickUpdate = () => {
    setIsOpenBookmarkUpdateDialog(true);
  };

  const currentPageText = getCurrentPageText(
    bookTableOfContents,
    chapterNumber,
    pageNumber,
  );

  const { isFirstPage, isLastPage } = getPagePosition(
    bookTableOfContents,
    chapterNumber,
    pageNumber,
  );

  const nextPageLink = getPageLink(
    bookTableOfContents,
    chapterNumber,
    pageNumber,
    'next',
  );

  const prevPageLink = getPageLink(
    bookTableOfContents,
    chapterNumber,
    pageNumber,
    'prev',
  );

  usePageTitle(`${bookContentPage.chapterTitle} (${currentPageText})`);

  return (
    <div className="delay-0 duration-200 animate-in fade-in-0">
      <div className="flex flex-col gap-y-12 px-4 pb-6 pt-12 sm:px-20">
        <div>
          <p className="mb-2 text-xs text-muted-foreground sm:text-sm">{`第 ${bookContentPage.chapterNumber} 章`}</p>
          <div className="flex flex-wrap items-center">
            <h1 className="text-wrap text-xl font-bold sm:text-2xl">
              {bookContentPage.chapterTitle}
            </h1>
            <p className="ml-4 mr-2 text-xs text-muted-foreground sm:text-sm">
              {currentPageText}
            </p>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  className="size-8 rounded-full"
                  variant="ghost"
                  size="icon"
                  asChild
                >
                  <Link
                    to={`/read/${bookId}/table-of-contents`}
                    className="flex items-center gap-x-2"
                    aria-label="目次に戻る"
                  >
                    <TableOfContentsIcon className="size-4" />
                  </Link>
                </Button>
              </TooltipTrigger>
              <TooltipContent>目次に戻る</TooltipContent>
            </Tooltip>
            <Tooltip>
              <TooltipTrigger asChild>
                {bookmark ? (
                  <Button
                    className={cn(
                      'rounded-full text-muted-foreground size-8',
                      bookmark && 'text-primary bg-transparent',
                    )}
                    variant="ghost"
                    size="icon"
                    aria-label="ブックマーク"
                    onClick={handleClickUpdate}
                  >
                    <BookmarkIcon
                      className="size-4"
                      style={{
                        fill: 'hsl(var(--primary))',
                      }}
                    />
                  </Button>
                ) : (
                  <Button
                    className="size-8 rounded-full text-muted-foreground"
                    variant="ghost"
                    size="icon"
                    aria-label="ブックマーク"
                    onClick={handleClickCreate}
                  >
                    <BookmarkIcon className="size-4" />
                  </Button>
                )}
              </TooltipTrigger>
              <TooltipContent>
                {bookmark
                  ? bookmark.note
                    ? `メモ「${bookmark.note}」`
                    : 'ブックマークからから削除'
                  : 'ブックマークに追加'}
              </TooltipContent>
            </Tooltip>

            {bookmark ? (
              <BookmarkUpdateDialog
                bookmark={bookmark}
                isOpen={isOpenBookmarkUpdateDialog}
                setIsOpen={setIsOpenBookmarkUpdateDialog}
                updateMutation={updateMutation}
                deleteMutation={deleteMutation}
              />
            ) : (
              <BookmarkCreateDialog
                bookId={bookId}
                chapterNumber={chapterNumber}
                pageNumber={pageNumber}
                isOpen={isOpenBookmarkCreateDialog}
                setIsOpen={setIsOpenBookmarkCreateDialog}
                createMutation={createMutation}
              />
            )}
          </div>
        </div>
        <p className="whitespace-pre-wrap">{bookContentPage.content}</p>
      </div>
      <div className="flex justify-between px-0 py-6 sm:px-12">
        <Button
          className={cn(
            'flex items-center gap-x-2 rounded-full hover:bg-transparent',
            isFirstPage && 'pointer-events-none text-muted-foreground',
          )}
          variant="ghost"
          asChild
        >
          <Link to={prevPageLink}>
            <ChevronLeftIcon />
            <span>前のページへ</span>
          </Link>
        </Button>
        <Button
          className={cn(
            'flex items-center gap-x-2 rounded-full hover:bg-transparent',
            isLastPage && 'pointer-events-none text-muted-foreground',
          )}
          variant="ghost"
          asChild
        >
          <Link to={nextPageLink}>
            <span>次のページへ</span>
            <ChevronRightIcon />
          </Link>
        </Button>
      </div>
    </div>
  );
}

------------------------------------------------------------
book-table-of-contents.tsx

import { Button } from '@/components/ui/button';
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { useApiBook } from '@/hooks/api/use-api-book';
import { usePageTitle } from '@/hooks/use-page-title';
import { cn } from '@/lib/utils';
import { useAuth } from '@/providers/auth-provider';
import { useSuspenseQuery } from '@tanstack/react-query';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
};

export default function BookTableOfContents({ bookId }: Props) {
  const { getBookTableOfContents } = useApiBook();
  const { user } = useAuth();

  const { data: bookTableOfContents } = useSuspenseQuery({
    queryKey: ['getBookTableOfContents', bookId],
    queryFn: () => getBookTableOfContents(bookId),
  });

  usePageTitle(bookTableOfContents.title);

  return (
    <div className="delay-0 duration-200 animate-in fade-in-0">
      <div className="flex flex-col gap-y-12 px-4 py-12 sm:px-20">
        <div className="flex w-full flex-col items-center gap-y-6 sm:items-start">
          <h1 className="text-3xl font-bold sm:text-5xl">
            {bookTableOfContents.title}
          </h1>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                className={cn(
                  'w-44 rounded-full bg-transparent',
                  (!user || !bookTableOfContents.chapters.length) &&
                    'pointer-events-none opacity-50',
                )}
                variant="outline"
                asChild
              >
                <Link to={`/read/${bookId}/chapter/1/page/1`}>
                  最初から読む
                </Link>
              </Button>
            </TooltipTrigger>
            {!user && (
              <TooltipContent>ログインしてこの本を読みましょう</TooltipContent>
            )}
          </Tooltip>
        </div>

        {bookTableOfContents.chapters.length ? (
          <ul className="flex w-full flex-col gap-y-8">
            {bookTableOfContents.chapters.map((chapter) => (
              <li
                className="w-full text-center sm:text-left"
                key={chapter.chapterNumber}
              >
                <p className="text-xs text-muted-foreground sm:text-sm">{`第 ${chapter.chapterNumber} 章`}</p>
                <Link
                  to={`/read/${bookId}/chapter/${chapter.chapterNumber}/page/1`}
                  className={cn(
                    'font-semibold hover:text-primary text-base sm:text-xl',
                    !user && 'pointer-events-none',
                  )}
                >
                  {chapter.chapterTitle}
                </Link>
              </li>
            ))}
          </ul>
        ) : (
          <p className="text-center sm:text-start">目次がありません</p>
        )}
      </div>
    </div>
  );
}

------------------------------------------------------------
bookmark-item.tsx

import BookmarkUpdateDialog from '@/components/bookmarks/bookmark-update-dialog';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { BOOK_IMAGE_BASE_URL } from '@/constants/constants';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { formatDateJP, formatTime } from '@/lib/utils';
import {
  Bookmark,
  BookmarkCreateMutation,
  BookmarkDeleteMutation,
  BookmarkUpdateMutation,
} from '@/types';
import { BookmarkIcon, SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';
import { Link } from 'react-router-dom';

type Props = {
  bookmark: Bookmark;
  createMutation?: BookmarkCreateMutation;
  updateMutation?: BookmarkUpdateMutation;
  deleteMutation?: BookmarkDeleteMutation;
};

export default function BookmarkItem({
  bookmark,
  updateMutation,
  deleteMutation,
}: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const handleClickUpdate = () => {
    setIsOpen(true);
  };

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: 'warning',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除',
    });
    if (isCancel) return;

    deleteMutation?.mutate(bookmark.id, {
      onSuccess: () => {
        toast({ title: 'ブックマークを削除しました' });
      },
    });
  };

  return (
    <Card>
      <CardContent>
        <div className="flex gap-x-4 px-3 py-4">
          <div className="flex min-w-20 justify-center sm:min-w-24">
            <Link
              to={`/read/${bookmark.bookId}/chapter/${bookmark.chapterNumber}/page/${bookmark.pageNumber}`}
              className="size-fit"
            >
              <img
                className="h-24 rounded object-cover sm:h-28"
                src={BOOK_IMAGE_BASE_URL + bookmark.book.imagePath}
                alt={bookmark.book.title}
              />
            </Link>
          </div>
          <div className="flex w-full flex-col justify-center">
            <div className="mb-2 flex flex-col items-start gap-x-4 sm:flex-row sm:items-center">
              <Link
                to={`/read/${bookmark.bookId}/chapter/${bookmark.chapterNumber}/page/${bookmark.pageNumber}`}
                className="size-fit"
              >
                <h2 className="text-base font-semibold hover:text-primary sm:text-xl">
                  {bookmark.book.title}
                </h2>
              </Link>
              <div className="flex flex-wrap items-center">
                <div className="flex size-8 items-center justify-center">
                  <BookmarkIcon
                    className="size-4 text-primary"
                    style={{ fill: 'hsl(var(--primary))' }}
                  />
                </div>
                <time
                  className="mr-2 whitespace-nowrap text-xs leading-8 tracking-wide text-muted-foreground sm:text-sm"
                  dateTime={
                    Date.parse(bookmark.updatedAt) ? bookmark.updatedAt : ''
                  }
                >
                  {formatDateJP(bookmark.updatedAt)}{' '}
                  {formatTime(bookmark.updatedAt)}
                </time>
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを編集"
                  onClick={handleClickUpdate}
                >
                  <SquarePenIcon className="size-4" />
                </Button>
                <BookmarkUpdateDialog
                  bookmark={bookmark}
                  isOpen={isOpen}
                  setIsOpen={setIsOpen}
                  updateMutation={updateMutation}
                />
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを削除"
                  onClick={handleClickDelete}
                >
                  <Trash2Icon className="size-4" />
                </Button>
              </div>
            </div>
            <p className="mb-4 text-xs text-muted-foreground sm:text-sm">
              第 {bookmark.chapterNumber} 章 : {bookmark.chapterTitle}（
              {bookmark.pageNumber}ページ目）
            </p>
            <p className="text-muted-foreground">
              {bookmark.note && <span>{bookmark.note}</span>}
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
bookmark-update-dialog.tsx

import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import {
  Bookmark,
  BookmarkDeleteMutation,
  BookmarkRequest,
  BookmarkUpdateMutation,
} from '@/types';
import { useEffect, useState } from 'react';
import { useLocation } from 'react-router-dom';

type Props = {
  bookmark: Bookmark;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  updateMutation?: BookmarkUpdateMutation;
  deleteMutation?: BookmarkDeleteMutation;
};

export default function BookmarkUpdateDialog({
  bookmark,
  isOpen,
  setIsOpen,
  updateMutation,
  deleteMutation,
}: Props) {
  const [note, setNote] = useState('');

  const location = useLocation();

  const { confirmDialog } = useConfirmDialog();
  const { toast } = useToast();

  useEffect(() => {
    if (isOpen) {
      setNote(bookmark.note);
    }
  }, [isOpen, bookmark.note]);

  const handleDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: 'warning',
      title: 'このブックマークを削除しますか？',
      message: 'ブックマークのメモも削除されます。',
    });
    if (isCancel) return;

    deleteMutation?.mutate(bookmark.id, {
      onSuccess: () => {
        toast({ title: 'ブックマークを削除しました' });
        setIsOpen(false);
      },
      onError: () => {
        toast({
          title: 'ブックマークの削除に失敗しました',
          description: '管理者へ連絡してください。',
          variant: 'destructive',
          duration: 5000,
        });
        setIsOpen(false);
      },
    });
  };

  const handleUpdate = () => {
    const requestBody: BookmarkRequest = {
      bookId: bookmark.bookId,
      chapterNumber: bookmark.chapterNumber,
      pageNumber: bookmark.pageNumber,
      note,
    };
    updateMutation?.mutate(
      { id: bookmark.id, requestBody },
      {
        onSuccess: () => {
          toast({ title: 'ブックマークのメモを更新しました' });
          setIsOpen(false);
        },
        onError: () => {
          toast({
            title: 'ブックマークのメモを更新に失敗しました',
            description: '管理者へ連絡してください。',
            variant: 'destructive',
            duration: 5000,
          });
          setIsOpen(false);
        },
      },
    );
  };

  const handleCloseDialog = () => {
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
      >
        <div>
          <p className="font-semibold leading-10">ブックマーク</p>
          <p className="text-xs text-muted-foreground sm:text-sm">
            メモを編集できます。メモが未入力でもブックマーク登録は消えません。
          </p>
        </div>

        <Textarea
          spellCheck={false}
          value={note}
          onChange={(e) => setNote(e.currentTarget.value)}
        />

        <DialogFooter className="gap-y-4 sm:gap-y-0">
          <Button
            className="min-w-24 rounded-full"
            variant="ghost"
            onClick={handleCloseDialog}
          >
            キャンセル
          </Button>
          {location.pathname.includes('read') && (
            <Button
              className="min-w-24 rounded-full"
              variant="outline"
              onClick={handleDelete}
            >
              削除
            </Button>
          )}
          <Button className="min-w-24 rounded-full" onClick={handleUpdate}>
            更新
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
bookmarks.tsx

import BookmarkList from '@/components/bookmarks/bookmark-list';
import SearchPagination from '@/components/search-pagination';
import { useApiBookmark } from '@/hooks/api/use-api-bookmark';
import { BookmarkRequest } from '@/types';
import {
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from '@tanstack/react-query';
import { useNavigate } from 'react-router-dom';

type Props = {
  page: number;
};

export default function Bookmarks({ page }: Props) {
  const navigate = useNavigate();
  const { getBookmarkPage, updateBookmark, deleteBookmark } = useApiBookmark();

  const { data: bookmarkPage } = useSuspenseQuery({
    queryKey: ['getBookmarkPage', page],
    queryFn: () => getBookmarkPage(page),
  });

  const queryClient = useQueryClient();

  const onSuccess = () => {
    queryClient.invalidateQueries({ queryKey: ['getBookmarkPage', page] });
    navigate('/bookmarks');
  };

  const onError = (error: Error) => {
    console.error(error);
  };

  const updateMutation = useMutation({
    mutationFn: ({
      id,
      requestBody,
    }: {
      id: number;
      requestBody: BookmarkRequest;
    }) => updateBookmark(id, requestBody),
    onSuccess,
    onError,
  });

  const deleteMutation = useMutation({
    mutationFn: (bookmarkId: number) => deleteBookmark(bookmarkId),
    onSuccess,
    onError,
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <p className="text-right">
        {bookmarkPage.totalItems}
        <span className="ml-1 mr-4 text-sm text-muted-foreground">件</span>
      </p>
      <BookmarkList
        bookmarks={bookmarkPage.bookmarks}
        updateMutation={updateMutation}
        deleteMutation={deleteMutation}
      />
      <SearchPagination totalPages={bookmarkPage.totalPages} />
    </div>
  );
}

------------------------------------------------------------
book-item.tsx

import AverageRatingIcon from '@/components/count-icon/average-rating-icon';
import ReviewCountIcon from '@/components/count-icon/review-count-icon';
import { Card, CardContent } from '@/components/ui/card';
import { BOOK_IMAGE_BASE_URL } from '@/constants/constants';
import { formatDateJP } from '@/lib/utils';
import { Book } from '@/types';
import { Link } from 'react-router-dom';

type Props = {
  book: Book;
};

export default function BookItem({ book }: Props) {
  return (
    <Card className="border-card-foreground/5 bg-card/70">
      <CardContent className="flex w-40 flex-col items-center gap-y-0 p-3 sm:w-48 sm:gap-y-1 sm:p-4">
        <Link to={`/book/${book.id}`} className="size-fit">
          <img
            className="mb-1 h-44 rounded object-cover sm:mb-0 sm:h-52"
            src={BOOK_IMAGE_BASE_URL + book.imagePath}
            alt={book.title}
          />
        </Link>
        <Link
          to={`/book/${book.id}`}
          className="flex h-8 items-center justify-center text-xs hover:text-primary sm:h-10 sm:text-sm"
        >
          <h2 className="line-clamp-2 text-center">{book.title}</h2>
        </Link>
        <time
          className="text-xs tracking-wide text-muted-foreground"
          dateTime={Date.parse(book.publishedDate) ? book.publishedDate : ''}
        >
          {formatDateJP(book.publishedDate)}
        </time>
        <div className="flex gap-x-3">
          <AverageRatingIcon size="sm" averageRating={book.averageRating} />
          <ReviewCountIcon size="sm" reviewCount={book.reviewCount} />
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
average-rating-icon.tsx

import { cn } from '@/lib/utils';
import { StarIcon } from 'lucide-react';

const BUTTON_SIZE = { sm: 'size-6', md: 'size-8' };
const ICON_SIZE = { sm: 'size-3', md: 'size-4' };
const TEXT_SIZE = { sm: 'text-xs', md: 'text-sm' };

type Props = {
  averageRating: number;
  size?: 'sm' | 'md';
};

export default function AverageRatingIcon({
  averageRating,
  size = 'md',
}: Props) {
  return (
    <div className="flex items-center text-muted-foreground">
      <div
        className={cn('flex items-center justify-center', BUTTON_SIZE[size])}
      >
        <StarIcon className={ICON_SIZE[size]} />
      </div>
      <div className={cn('flex min-w-4 justify-center', TEXT_SIZE[size])}>
        {averageRating.toFixed(1)}
      </div>
    </div>
  );
}

------------------------------------------------------------
favorite-count-icon.tsx

import { Button } from '@/components/ui/button';
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { useApiFavorite } from '@/hooks/api/use-api-favorite';
import { cn } from '@/lib/utils';
import { useAuth } from '@/providers/auth-provider';
import { FavoriteInfo, FavoriteRequest } from '@/types';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { HeartIcon } from 'lucide-react';

const BUTTON_SIZE = { sm: 'size-6', md: 'size-8' };
const ICON_SIZE = { sm: 'size-3', md: 'size-4' };
const TEXT_SIZE = { sm: 'text-xs', md: 'text-sm' };

type Props = {
  bookId: string;
  size?: 'sm' | 'md';
  showCount?: boolean;
};

export default function FavoriteCountIcon({
  bookId,
  size = 'md',
  showCount = false,
}: Props) {
  const { user } = useAuth();
  const { getFavoriteInfo, createFavorite, deleteFavorite } = useApiFavorite();

  const queryClient = useQueryClient();

  const queryKey = ['getFavoriteInfo', bookId, user?.id];
  const { data: favoriteInfo = { isFavorite: false, favoriteCount: 0 } } =
    useQuery({
      queryKey,
      queryFn: () => getFavoriteInfo(bookId, user?.id),
    });

  const {
    mutate: toggleMutation,
    variables,
    isPending,
  } = useMutation({
    mutationFn: async (newFavorite: FavoriteInfo) => {
      if (newFavorite.isFavorite) {
        const requestBody: FavoriteRequest = { bookId };
        await createFavorite(requestBody);
      } else {
        await deleteFavorite(bookId);
      }
    },
    onMutate: async (newFavoriteInfo: FavoriteInfo) => {
      await queryClient.cancelQueries({ queryKey });
      const previousFavoriteInfo = queryClient.getQueryData(queryKey);
      queryClient.setQueryData(queryKey, newFavoriteInfo);
      return { previousFavoriteInfo };
    },
    onSettled: (_newFavoriteInfo, error, _variables, context) => {
      if (error) {
        queryClient.setQueryData(queryKey, context?.previousFavoriteInfo);
      }
      queryClient.invalidateQueries({ queryKey });
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleClick = () => {
    if (!user) return;

    const newFavoriteInfo: FavoriteInfo = {
      isFavorite: !favoriteInfo.isFavorite,
      favoriteCount: favoriteInfo.isFavorite
        ? favoriteInfo.favoriteCount - 1
        : favoriteInfo.favoriteCount + 1,
    };
    toggleMutation(newFavoriteInfo);
  };

  const optimisticData = isPending ? variables : favoriteInfo;

  return (
    <div className="flex items-center text-muted-foreground">
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className={cn(
              'rounded-full text-muted-foreground',
              BUTTON_SIZE[size],
              optimisticData?.isFavorite && 'text-primary bg-transparent',
            )}
            variant="ghost"
            size="icon"
            aria-label={
              optimisticData?.isFavorite
                ? 'お気に入りから削除'
                : 'お気に入りに追加'
            }
            onClick={handleClick}
          >
            <HeartIcon
              className={ICON_SIZE[size]}
              style={{
                fill: optimisticData?.isFavorite ? 'hsl(var(--primary))' : '',
              }}
            />
          </Button>
        </TooltipTrigger>
        <TooltipContent>
          {user
            ? optimisticData?.isFavorite
              ? 'お気に入りから削除'
              : 'お気に入りに追加'
            : 'ログインしてこの本を「お気に入り」に加えましょう'}
        </TooltipContent>
      </Tooltip>

      {showCount && (
        <div className={cn('flex min-w-4 justify-center', TEXT_SIZE[size])}>
          {optimisticData?.favoriteCount}
        </div>
      )}
    </div>
  );
}

------------------------------------------------------------
review-count-icon.tsx

import { cn } from '@/lib/utils';
import { MessageSquareIcon } from 'lucide-react';

const BUTTON_SIZE = { sm: 'size-6', md: 'size-8' };
const ICON_SIZE = { sm: 'size-3', md: 'size-4' };
const TEXT_SIZE = { sm: 'text-xs', md: 'text-sm' };

type Props = {
  reviewCount: number;
  size?: 'sm' | 'md';
};

export default function ReviewCountIcon({ reviewCount, size = 'md' }: Props) {
  return (
    <div className="flex items-center text-muted-foreground">
      <div
        className={cn('flex items-center justify-center', BUTTON_SIZE[size])}
      >
        <MessageSquareIcon className={ICON_SIZE[size]} />
      </div>
      <div className={cn('flex min-w-4 justify-center', TEXT_SIZE[size])}>
        {reviewCount}
      </div>
    </div>
  );
}

------------------------------------------------------------
favorite-item.tsx

import FavoriteCountIcon from '@/components/count-icon/favorite-count-icon';
import { Card, CardContent } from '@/components/ui/card';
import { BOOK_IMAGE_BASE_URL } from '@/constants/constants';
import { formatDateJP, formatTime } from '@/lib/utils';
import { Favorite } from '@/types';
import { Link } from 'react-router-dom';

type Props = {
  favorite: Favorite;
};

export default function FavoriteItem({ favorite }: Props) {
  return (
    <Card>
      <CardContent>
        <div className="flex gap-x-4 px-3 py-4">
          <div className="flex min-w-20 justify-center sm:min-w-24">
            <Link to={`/book/${favorite.book.id}`} className="size-fit">
              <img
                className="h-24 rounded object-cover sm:h-28"
                src={BOOK_IMAGE_BASE_URL + favorite.book.imagePath}
                alt={favorite.book.title}
              />
            </Link>
          </div>
          <div className="flex w-full flex-col justify-center">
            <div className="mb-2 flex flex-col items-start gap-x-4 sm:flex-row sm:items-center">
              <Link to={`/book/${favorite.book.id}`} className="size-fit">
                <h2 className="text-base font-semibold hover:text-primary sm:text-xl">
                  {favorite.book.title}
                </h2>
              </Link>
              <div className="flex items-center">
                <FavoriteCountIcon bookId={favorite.bookId} />
                <time
                  className="mr-2 whitespace-nowrap text-xs leading-8 tracking-wide text-muted-foreground sm:text-sm"
                  dateTime={
                    Date.parse(favorite.updatedAt) ? favorite.updatedAt : ''
                  }
                >
                  {formatDateJP(favorite.updatedAt)}{' '}
                  {formatTime(favorite.updatedAt)}
                </time>
              </div>
            </div>
            <div className="mb-4 flex w-full flex-wrap items-center gap-x-3 text-muted-foreground">
              <p className="text-xs">著者</p>
              {favorite.book.authors.map((author) => (
                <p className="text-sm" key={author}>
                  {author}
                </p>
              ))}
            </div>
            <p className="text-muted-foreground">{favorite.book.description}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
genre-item.tsx

import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { Genre } from '@/types';
import { useNavigate } from 'react-router-dom';

type Props = {
  genre: Genre;
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost';
  isActive?: boolean;
  onClick?: (genreId: number) => void;
};

export default function GenreItem({
  genre,
  variant = 'ghost',
  isActive = false,
  onClick,
}: Props) {
  const navigate = useNavigate();

  const handleClick = (genreId: number) => {
    if (onClick) {
      onClick(genreId);
    } else {
      navigate(`/discover?genreIds=${genreId}&condition=SINGLE`);
    }
  };

  return (
    <Button
      className={cn(
        'rounded-full m-1 text-muted-foreground text-xs sm:text-sm',
        isActive && 'text-foreground',
        variant === 'outline' && 'text-primary bg-transparent',
      )}
      variant={isActive ? 'secondary' : variant}
      size="sm"
      onClick={() => handleClick(genre.id)}
    >
      {genre.name}
    </Button>
  );
}

------------------------------------------------------------
genre-list.tsx

import GenreItem from '@/components/genres/genre-item';
import { Genre } from '@/types';

type Props = {
  genres: Genre[];
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost';
  activeIds?: number[];
  onClick?: (genreId: number) => void;
};

export default function GenreList({
  genres,
  variant,
  activeIds,
  onClick,
}: Props) {
  return (
    <ul className="flex flex-wrap">
      {genres.map((genre) => (
        <li key={genre.id}>
          <GenreItem
            genre={genre}
            variant={variant}
            isActive={activeIds?.includes(genre.id)}
            onClick={onClick}
          />
        </li>
      ))}
    </ul>
  );
}

------------------------------------------------------------
genres-condition-selector.tsx

import { Label } from '@/components/ui/label';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { useSearchFilters } from '@/hooks/use-search-filters';

const CONDITION_LIST = [
  { text: '単一選択', value: 'SINGLE' },
  { text: 'AND条件', value: 'AND' },
  { text: 'OR条件', value: 'OR' },
];

export default function GenresConditionSelector() {
  const { genreIds, condition, updateQueryParams } = useSearchFilters();

  const handleChange = (condition: string) => {
    // SINGLE選択以外は複数ジャンル選択可能OKだが
    // SINGLE選択の場合、複数ジャンルの中の最初の値（単一の値）とする
    const ids = condition === 'SINGLE' ? genreIds.split(',')[0] : undefined;
    updateQueryParams({ genreIds: ids, condition, page: 1 });
  };

  return (
    <RadioGroup
      className="flex gap-x-4"
      value={condition}
      onValueChange={handleChange}
    >
      {CONDITION_LIST.map((item) => (
        <div
          className="flex flex-col-reverse items-center sm:flex-row"
          key={item.value}
        >
          <RadioGroupItem value={item.value} id={item.value} />
          <Label
            className="cursor-pointer select-none p-2 text-xs sm:text-sm"
            htmlFor={item.value}
          >
            {item.text}
          </Label>
        </div>
      ))}
    </RadioGroup>
  );
}

------------------------------------------------------------
genres-selector.tsx

import GenreList from '@/components/genres/genre-list';
import { useApiGenre } from '@/hooks/api/use-api-genre';
import { useSearchFilters } from '@/hooks/use-search-filters';
import { useSuspenseQuery } from '@tanstack/react-query';

export default function GenresSelector() {
  const { genreIds, condition, updateQueryParams } = useSearchFilters();
  const { getGenres } = useApiGenre();

  const { data: genres } = useSuspenseQuery({
    queryKey: ['getGenres'],
    queryFn: () => getGenres(),
  });

  // クエリ文字列から配列へ
  const selectedGenreIds = genreIds
    .split(',')
    .map((genreId) => Number(genreId));

  const handleClick = (genreId: number) => {
    let newGenreIds = selectedGenreIds.includes(genreId)
      ? selectedGenreIds.filter((id) => id !== genreId)
      : [...selectedGenreIds, genreId].sort((a, b) => a - b);

    // 最後の一つをクリックした場合、空配列になるので必ず１つは選択になるようにする
    // SINGLE選択に関しては必ず１つの選択になる
    if (newGenreIds.length === 0 || condition === 'SINGLE') {
      newGenreIds = [genreId];
    }
    updateQueryParams({ genreIds: newGenreIds.join(','), page: 1 });
  };

  return (
    <GenreList
      genres={genres}
      activeIds={selectedGenreIds}
      onClick={handleClick}
    />
  );
}

------------------------------------------------------------
footer.tsx

import Logo from '@/components/layout/logo';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import {
  FacebookIcon,
  InstagramIcon,
  TwitterIcon,
  YoutubeIcon,
} from 'lucide-react';
import { Link } from 'react-router-dom';

const SNS_LIST = [
  { label: 'Youtube', icon: YoutubeIcon, url: 'https://www.youtube.com' },
  { label: 'Twitter', icon: TwitterIcon, url: 'https://x.com' },
  { label: 'Instagram', icon: InstagramIcon, url: 'https://www.instagram.com' },
  { label: 'Facebook', icon: FacebookIcon, url: 'https://www.facebook.com' },
];

type Props = {
  className?: string;
};

export default function Footer({ className }: Props) {
  return (
    <footer className={cn('bg-card', className)}>
      <div className="mx-auto max-w-7xl px-3 sm:px-6">
        <div className="flex flex-col items-center justify-between py-4 sm:flex-row">
          <ul className="flex">
            {SNS_LIST.map((item) => (
              <li key={item.label}>
                <Button
                  className="rounded-full"
                  variant="ghost"
                  size="icon"
                  asChild
                >
                  <Link
                    to={item.url}
                    aria-label={item.label}
                    target="_blank"
                    rel="noopener noreferrer"
                  >
                    <item.icon className="size-5" />
                  </Link>
                </Button>
              </li>
            ))}
          </ul>
          <p className="flex h-7 items-center text-sm">© 2025 Xxxxx, Inc.</p>
          <Logo size="sm" />
        </div>
      </div>
    </footer>
  );
}

------------------------------------------------------------
header.tsx

import Menu from '@/components/layout/menu';
import ThemeToggleButton from '@/components/layout/theme-toggle-button';
import UserIconButton from '@/components/layout/user-icon-button';
import SearchInput from '@/components/search-input';
import { cn } from '@/lib/utils';

type Props = {
  className?: string;
};

export default function Header({ className }: Props) {
  return (
    <header className={cn('backdrop-blur', className)}>
      <div className="mx-auto max-w-7xl px-3 sm:px-6">
        <div className="delay-0 duration-500 animate-in fade-in-0 slide-in-from-top-10 fill-mode-both">
          <div className="flex h-16 w-full items-center justify-between sm:gap-x-2">
            <Menu />
            <div className="flex">
              <SearchInput />
              <UserIconButton />
              <ThemeToggleButton />
            </div>
          </div>
        </div>
      </div>
    </header>
  );
}

------------------------------------------------------------
hero.tsx

import mainVisualImage from '@/assets/main-visual.webp';
import SearchInput from '@/components/search-input';

export default function Hero() {
  return (
    <div className="relative flex h-[500px] items-center">
      <div className="absolute right-0 top-10 overflow-hidden sm:right-8">
        <div className="delay-500 duration-500 animate-in fade-in-0 slide-in-from-right-10 fill-mode-both">
          <img
            className="w-[400px] opacity-25 lg:w-[450px] lg:opacity-100"
            src={mainVisualImage}
            alt="main-visual-image"
          />
        </div>
      </div>

      <div className="flex w-3/4 flex-col gap-y-6 lg:w-3/5">
        <div className="delay-0 duration-500 animate-in fade-in-0 slide-in-from-bottom-10 fill-mode-both">
          <h1 className="text-5xl font-bold sm:text-6xl xl:text-7xl">
            Let’s search for <span className="text-primary">Books</span> to
            discover new knowledge.
            <span className="sr-only" lang="ja">
              新たな知識を発見するために、本を探しましょう。
            </span>
          </h1>
        </div>
        <div className="delay-150 duration-500 animate-in fade-in-0 slide-in-from-bottom-10 fill-mode-both">
          <p className="text-sm text-muted-foreground">
            本の探索サイトへようこそ。多様なコレクションから、新しい知識を発見しましょう。厳選された書籍で、あなたの次の読書を見つけてください。知識の旅に一緒に出かけましょう。
          </p>
        </div>
        <div className="delay-300 duration-500 animate-in fade-in-0 slide-in-from-bottom-10 fill-mode-both">
          <SearchInput />
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
logo.tsx

import { Button } from '@/components/ui/button';
import { TITLE_LOGO } from '@/constants/constants';
import { cn } from '@/lib/utils';
import { Link } from 'react-router-dom';

type Props = {
  className?: string;
  size?: 'sm' | 'md' | 'lg';
  disableLink?: boolean;
  onClick?: () => void;
};

export default function Logo({
  className,
  size = 'md',
  disableLink = false,
  onClick,
}: Props) {
  const SIZE = {
    sm: 'text-xl',
    md: 'text-3xl',
    lg: 'text-5xl',
  };

  return (
    <Button
      className={cn(
        "select-none whitespace-nowrap font-['Alfa_Slab_One'] tracking-tighter text-primary hover:bg-transparent",
        disableLink && 'pointer-events-none cursor-default',
        SIZE[size],
        className,
      )}
      variant="ghost"
      asChild
    >
      <Link
        to="/"
        aria-label="タイトルロゴ"
        aria-disabled={disableLink}
        onClick={onClick}
      >
        {TITLE_LOGO}
      </Link>
    </Button>
  );
}

------------------------------------------------------------
menu.tsx

import Logo from '@/components/layout/logo';
import NavList from '@/components/layout/nav-list';
import { Button } from '@/components/ui/button';
import { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet';
import { useWindowSize } from '@/hooks/use-window-size';
import { MenuIcon } from 'lucide-react';
import { useState } from 'react';

export default function Menu() {
  const [isOpen, setIsOpen] = useState(false);

  const DEBOUNCED_DELAY = 100;
  const { width } = useWindowSize(DEBOUNCED_DELAY);

  const TABLET_WIDTH = 1024;
  if (isOpen && width >= TABLET_WIDTH) {
    setIsOpen(false);
  }

  return (
    <>
      <div className="hidden lg:flex lg:items-center lg:gap-x-8">
        <Logo />
        <NavList />
      </div>

      <div className="lg:hidden">
        <Sheet open={isOpen} onOpenChange={setIsOpen}>
          <SheetTrigger asChild>
            <Button
              className="rounded-full"
              variant="ghost"
              size="icon"
              aria-label="メニュー"
            >
              <MenuIcon className="size-5" />
            </Button>
          </SheetTrigger>
          <SheetContent className="w-fit p-8" side="left">
            <Logo className="mb-4" onClick={() => setIsOpen(false)} />
            <NavList onClick={() => setIsOpen(false)} />
          </SheetContent>
        </Sheet>
      </div>
    </>
  );
}

------------------------------------------------------------
nav-list.tsx

import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { Link, useLocation } from 'react-router-dom';

const NAV_LIST = [
  {
    href: '/discover?genreIds=1&condition=SINGLE',
    title: 'ジャンル',
  },
  { href: '/ranking', title: 'ランキング' },
  { href: '/special-features', title: '特集' },
];

type Props = {
  onClick?: () => void;
};

export default function NavList({ onClick }: Props) {
  const location = useLocation();

  return (
    <nav>
      <ul className="flex flex-col gap-y-2 lg:flex-row">
        {NAV_LIST.map((item) => (
          <li className="w-full" key={item.href}>
            <Button
              className={cn(
                'rounded-full w-full hover:bg-transparent hover:text-foreground/50',
                location.pathname !== '/' &&
                  item.href.includes(location.pathname) &&
                  'text-primary',
              )}
              variant="ghost"
              asChild
            >
              <Link to={item.href} onClick={onClick}>
                {item.title}
              </Link>
            </Button>
          </li>
        ))}
      </ul>
    </nav>
  );
}

------------------------------------------------------------
theme-toggle-button.tsx

import { Button } from '@/components/ui/button';
import { useTheme } from '@/providers/theme-provider';
import { MoonIcon, SunIcon } from 'lucide-react';

export default function ThemeToggleButton() {
  const { theme, setTheme } = useTheme();

  const handleClick = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };

  return (
    <Button
      className="rounded-full"
      variant="ghost"
      size="icon"
      aria-label={
        theme === 'light' ? 'ダークモードに切り替え' : 'ライトモードに切り替え'
      }
      onClick={handleClick}
    >
      {theme === 'light' ? (
        <MoonIcon className="size-4" />
      ) : (
        <SunIcon className="size-4" />
      )}
    </Button>
  );
}

------------------------------------------------------------
user-icon-button.tsx

import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { AVATAR_IMAGE_BASE_URL } from '@/constants/constants';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/utils';
import { useAuth } from '@/providers/auth-provider';
import { useMutation } from '@tanstack/react-query';
import {
  BookmarkIcon,
  HeartIcon,
  LogOutIcon,
  MessageSquareIcon,
  UserRoundIcon,
} from 'lucide-react';
import { useEffect, useState } from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';

const MENU_LIST = [
  { href: '/favorites', title: 'お気に入り', icon: HeartIcon },
  { href: '/bookmarks', title: 'ブックマーク', icon: BookmarkIcon },
  { href: '/my-reviews', title: 'マイレビュー', icon: MessageSquareIcon },
  { href: '/profile', title: 'プロフィール', icon: UserRoundIcon },
];

export default function UserIconButton() {
  const [isOpen, setIsOpen] = useState(false);

  const navigate = useNavigate();
  const location = useLocation();
  const pathname = location.pathname;

  const { accessToken, user, setUser, logout } = useAuth();
  const { getCurrentUser } = useApiUser();
  const { toast } = useToast();

  const logoutMutation = useMutation({
    mutationFn: () => logout(),
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    const init = async () => {
      if (accessToken && !user) {
        const currentUser = await getCurrentUser();
        setUser(currentUser);
      }
    };
    init();
  }, [accessToken, getCurrentUser, setUser, user]);

  const handleClickLogout = async () => {
    logoutMutation.mutate(undefined, {
      onSuccess: () => {
        toast({ title: 'ログアウトしました' });
        setIsOpen(false);
        navigate('/');
      },
    });
  };

  const handleClickMenuItem = (href: string) => {
    navigate(href);
    setIsOpen(false);
  };

  if (!user)
    return (
      <Button className="rounded-full" variant="ghost" asChild>
        <Link to="/login" state={{ from: location }}>
          ログイン
        </Link>
      </Button>
    );

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger
        className="ml-2 flex items-center justify-center"
        asChild
      >
        <Button
          className="rounded-full"
          variant="ghost"
          size="icon"
          aria-label="アバター画像"
        >
          <Avatar>
            <AvatarImage
              className="bg-primary/50"
              src={AVATAR_IMAGE_BASE_URL + user.avatarPath}
              alt="avatar-image"
            />
            <AvatarFallback className="text-lg font-semibold">
              {user.name.slice(0, 1)}
            </AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-48 p-2" side="bottom" align="end">
        <DropdownMenuLabel>
          <div className="flex items-center gap-x-2">
            <Avatar className="size-8">
              <AvatarImage
                className="bg-primary/50"
                src={AVATAR_IMAGE_BASE_URL + user.avatarPath}
                alt="avatar-image"
              />
              <AvatarFallback className="font-semibold">
                {user.name.slice(0, 1)}
              </AvatarFallback>
            </Avatar>
            <div className="flex-1 overflow-hidden">
              <p className="truncate">{user.name}</p>
              <p className="truncate text-xs font-normal text-muted-foreground">
                {user.email}
              </p>
            </div>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        {MENU_LIST.map((item) => (
          <DropdownMenuItem
            className={cn(
              pathname !== '/' &&
                item.href.includes(pathname) &&
                'text-primary',
            )}
            key={item.href}
            onClick={() => handleClickMenuItem(item.href)}
          >
            <item.icon className="mr-1" />
            {item.title}
          </DropdownMenuItem>
        ))}
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={handleClickLogout}>
          <LogOutIcon className="mr-1" />
          ログアウト
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

------------------------------------------------------------
my-review-item.tsx

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/reviews/review-update-dialog';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { BOOK_IMAGE_BASE_URL } from '@/constants/constants';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { formatDateJP, formatTime } from '@/lib/utils';
import {
  Review,
  ReviewCreateMutation,
  ReviewDeleteMutation,
  ReviewUpdateMutation,
} from '@/types';
import { SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';
import { Link } from 'react-router-dom';

type Props = {
  review: Review;
  createMutation?: ReviewCreateMutation;
  updateMutation?: ReviewUpdateMutation;
  deleteMutation?: ReviewDeleteMutation;
};

export default function MyReviewItem({
  review,
  updateMutation,
  deleteMutation,
}: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const handleClickUpdate = () => {
    setIsOpen(true);
  };

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: 'warning',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除',
    });
    if (isCancel) return;

    deleteMutation?.mutate(review.id, {
      onSuccess: () => {
        toast({ title: 'レビューを削除しました' });
      },
    });
  };

  return (
    <Card>
      <CardContent>
        <div className="flex gap-x-4 px-3 py-4">
          <div className="flex min-w-20 justify-center sm:min-w-24">
            <Link to={`/book/${review.book.id}`} className="size-fit">
              <img
                className="h-24 rounded object-cover sm:h-28"
                src={BOOK_IMAGE_BASE_URL + review.book.imagePath}
                alt={review.book.title}
              />
            </Link>
          </div>
          <div className="flex w-full flex-col justify-center">
            <Link to={`/book/${review.book.id}`} className="size-fit">
              <h2 className="text-base font-semibold hover:text-primary sm:text-xl">
                {review.book.title}
              </h2>
            </Link>
            <div className="mb-2 flex flex-col items-start sm:flex-row sm:items-center">
              <div className="mr-2">
                <Rating rating={review.rating} readOnly />
              </div>
              <div className="flex flex-wrap items-center">
                <time
                  className="mr-2 whitespace-nowrap text-xs leading-8 tracking-wide text-muted-foreground sm:text-sm"
                  dateTime={
                    Date.parse(review.updatedAt) ? review.updatedAt : ''
                  }
                >
                  {formatDateJP(review.updatedAt)}{' '}
                  {formatTime(review.updatedAt)}
                </time>
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを編集"
                  onClick={handleClickUpdate}
                >
                  <SquarePenIcon className="size-4" />
                </Button>
                <ReviewUpdateDialog
                  review={review}
                  isOpen={isOpen}
                  setIsOpen={setIsOpen}
                  updateMutation={updateMutation}
                />
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを削除"
                  onClick={handleClickDelete}
                >
                  <Trash2Icon className="size-4" />
                </Button>
              </div>
            </div>
            <p className="text-muted-foreground">{review.comment}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
my-reviews.tsx

import MyReviewList from '@/components/my-reviews/my-review-list';
import SearchPagination from '@/components/search-pagination';
import { useApiReview } from '@/hooks/api/use-api-review';
import { ReviewRequest } from '@/types';
import {
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from '@tanstack/react-query';
import { useNavigate } from 'react-router-dom';

type Props = {
  page: number;
};

export default function MyReviews({ page }: Props) {
  const navigate = useNavigate();

  const { getReviewPageByUser, updateReview, deleteReview } = useApiReview();

  const { data: reviewPage } = useSuspenseQuery({
    queryKey: ['getReviewPageByUser', page],
    queryFn: () => getReviewPageByUser(page),
  });

  const queryClient = useQueryClient();

  const onSuccess = () => {
    queryClient.invalidateQueries({
      queryKey: ['getReviewPageByUser', page],
    });
    navigate('/my-reviews');
  };

  const onError = (error: Error) => {
    console.error(error);
  };

  const updateMutation = useMutation({
    mutationFn: ({
      id,
      requestBody,
    }: {
      id: number;
      requestBody: ReviewRequest;
    }) => updateReview(id, requestBody),
    onSuccess,
    onError,
  });

  const deleteMutation = useMutation({
    mutationFn: (id: number) => deleteReview(id),
    onSuccess,
    onError,
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <p className="text-right">
        {reviewPage.totalItems}
        <span className="ml-1 mr-4 text-sm text-muted-foreground">件</span>
      </p>
      <MyReviewList
        reviews={reviewPage.reviews}
        updateMutation={updateMutation}
        deleteMutation={deleteMutation}
      />
      <SearchPagination totalPages={reviewPage.totalPages} />
    </div>
  );
}

------------------------------------------------------------
avatar-carousel.tsx

import SwipeArea from '@/components/profile/swipe-area';
import { Avatar, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { AVATAR_IMAGE_BASE_URL } from '@/constants/constants';
import { cn } from '@/lib/utils';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { useRef, useState } from 'react';

const AVATAR_PATHS = [...Array(41)].map(
  (_, index) => `/avatar${String(index).padStart(2, '0')}.png`,
);

type Props = {
  value: string;
  onChange: (avatarPath: string) => void;
};

export default function AvatarCarousel({ value, onChange }: Props) {
  // 座標など調整用の値
  const itemWidth = 70;
  const frameWidth = 192;
  const paddingItem = 2;
  const marginLeft = Math.floor(frameWidth / 2) - Math.floor(itemWidth / 2);

  // 配列の最初と最後の切れ目部分にアイテムを追加しておく
  // 循環参照するときの見た目の調整のため
  const extendedAvatarPaths = [
    ...AVATAR_PATHS.slice(-paddingItem),
    ...AVATAR_PATHS,
    ...AVATAR_PATHS.slice(0, paddingItem),
  ];

  // 引数のvalueが見つからなかった場合、findIndex()は-1を返すので、
  // Math.max()で最小でも0になるようにする
  const defaultIndex = Math.max(
    0,
    AVATAR_PATHS.findIndex((avatarPath) => avatarPath === value),
  );

  // インデックス番号でカルーセルを制御
  // innerIndexは内部的なインデックスとして使用（スクロールアニメーション用）
  const [currentIndex, setCurrentIndex] = useState(defaultIndex);
  const [innerIndex, setInnerIndex] = useState(defaultIndex);

  const [isScrolling, setIsScrolling] = useState(false);
  const carouselRef = useRef<HTMLUListElement>(null);

  const handlePrev = () => {
    if (isScrolling) return;
    setIsScrolling(true);
    setInnerIndex(innerIndex - 1);

    const prevIndex =
      (currentIndex - 1 + AVATAR_PATHS.length) % AVATAR_PATHS.length;
    setCurrentIndex(prevIndex);
    onChange(AVATAR_PATHS[prevIndex]);
  };

  const handleNext = () => {
    if (isScrolling) return;
    setIsScrolling(true);
    setInnerIndex(innerIndex + 1);

    const nextIndex = (currentIndex + 1) % AVATAR_PATHS.length;
    setCurrentIndex(nextIndex);
    onChange(AVATAR_PATHS[nextIndex]);
  };

  const handleTransitonEnd = () => {
    setIsScrolling(false);
    setInnerIndex(currentIndex);

    // 循環スクロールのために、先頭から終端などに座標を変化させるとスクロールの
    // ちらつきが発生してしまうので、切れ目の変化ではアニメーションをいったんOffにする
    if (currentIndex === 0 || currentIndex === AVATAR_PATHS.length - 1) {
      setIsScrolling(true);
      carouselRef.current!.style.transitionProperty = 'none';
      setTimeout(() => {
        carouselRef.current!.style.transitionProperty = 'transform';
        setIsScrolling(false);
      }, 75);
    }
  };

  return (
    <div className="flex items-center justify-center">
      <Button
        className="rounded-full"
        type="button"
        variant="ghost"
        size="icon"
        aria-label="前へ"
        onClick={handlePrev}
      >
        <ChevronLeft className="size-4" />
      </Button>

      <div
        className="relative w-full select-none overflow-hidden"
        style={{ width: `${frameWidth}px` }}
      >
        <ul
          ref={carouselRef}
          className="flex transition-transform duration-200"
          style={{
            transform: `translateX(-${(innerIndex + paddingItem) * itemWidth}px)`,
            marginLeft: `${marginLeft}px`,
          }}
          onTransitionEnd={handleTransitonEnd}
        >
          {extendedAvatarPaths.map((avatarPath, index) => (
            <li
              key={index}
              className={`flex shrink-0 items-center justify-center`}
              style={{ width: `${itemWidth}px` }}
            >
              <div className="relative flex h-24 items-center">
                <Avatar
                  className={cn(
                    'transition-all duration-200',
                    'size-12 opacity-25 scale-100',
                    avatarPath === AVATAR_PATHS[currentIndex] &&
                      'opacity-100 scale-150 outline-1 outline-offset-1 outline outline-primary',
                  )}
                >
                  <AvatarImage
                    className="bg-primary"
                    src={AVATAR_IMAGE_BASE_URL + avatarPath}
                    alt="avatar-image"
                    draggable={false}
                  />
                </Avatar>
              </div>
            </li>
          ))}
        </ul>
        <SwipeArea
          className="absolute left-0 top-0 h-24 w-full"
          onSwipeLeft={handleNext}
          onSwipeRight={handlePrev}
        />
      </div>

      <Button
        className="rounded-full"
        type="button"
        variant="ghost"
        size="icon"
        aria-label="次へ"
        onClick={handleNext}
      >
        <ChevronRight className="size-4" />
      </Button>
    </div>
  );
}

------------------------------------------------------------
password-input.tsx

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { EyeIcon, EyeOffIcon } from 'lucide-react';
import React, { useState } from 'react';

const PasswordInput = React.forwardRef<
  HTMLInputElement,
  React.ComponentProps<'input'>
>(({ className, ...props }, ref) => {
  const [isShownPassword, setIsShownPassword] = useState(false);

  return (
    <div className="relative">
      <Input
        ref={ref}
        className={className}
        type={isShownPassword ? 'text' : 'password'}
        {...props}
      />
      <Button
        className="absolute right-0 top-0 rounded-full hover:bg-transparent hover:text-foreground"
        variant="ghost"
        size="icon"
        aria-label={isShownPassword ? 'パスワードを非表示' : 'パスワードを表示'}
        type="button"
        onClick={() => setIsShownPassword(!isShownPassword)}
      >
        {isShownPassword ? (
          <EyeIcon className="size-4" />
        ) : (
          <EyeOffIcon className="size-4" />
        )}
      </Button>
    </div>
  );
});

export default PasswordInput;

------------------------------------------------------------
review-item.tsx

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/reviews/review-update-dialog';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { AVATAR_IMAGE_BASE_URL } from '@/constants/constants';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { formatDateJP, formatTime } from '@/lib/utils';
import { useAuth } from '@/providers/auth-provider';
import {
  Review,
  ReviewCreateMutation,
  ReviewDeleteMutation,
  ReviewUpdateMutation,
} from '@/types';
import { SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';

type Props = {
  review: Review;
  createMutation?: ReviewCreateMutation;
  updateMutation?: ReviewUpdateMutation;
  deleteMutation?: ReviewDeleteMutation;
};

export default function ReviewItem({
  review,
  updateMutation,
  deleteMutation,
}: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const { user } = useAuth();
  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const handleClickUpdate = () => {
    setIsOpen(true);
  };

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: 'warning',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除',
    });
    if (isCancel) return;

    deleteMutation?.mutate(review.id, {
      onSuccess: () => {
        toast({ title: 'レビューを削除しました' });
      },
    });
  };

  return (
    <div className="p-4">
      <div className="flex flex-col items-center justify-between sm:flex-row">
        <div className="flex w-full items-center gap-x-4">
          <Avatar className="size-16">
            <AvatarImage
              className="bg-primary/50"
              src={AVATAR_IMAGE_BASE_URL + review.avatarPath}
              alt="avatar-image"
            />
            <AvatarFallback className="font-semibold">
              {review.name.slice(0, 1)}
            </AvatarFallback>
          </Avatar>
          <div>
            <p className="-mb-1 text-lg font-semibold">{review.name}</p>
            <div className="flex items-center">
              <time
                className="whitespace-nowrap text-sm leading-8 tracking-wide text-muted-foreground"
                dateTime={Date.parse(review.updatedAt) ? review.updatedAt : ''}
              >
                {formatDateJP(review.updatedAt)} {formatTime(review.updatedAt)}
              </time>
              <div className="ml-2 flex w-16">
                {user?.id === review.userId && (
                  <>
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      aria-label="レビューを編集"
                      onClick={handleClickUpdate}
                    >
                      <SquarePenIcon className="size-4" />
                    </Button>
                    <ReviewUpdateDialog
                      review={review}
                      isOpen={isOpen}
                      setIsOpen={setIsOpen}
                      updateMutation={updateMutation}
                    />
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      aria-label="レビューを削除"
                      onClick={handleClickDelete}
                    >
                      <Trash2Icon className="size-4" />
                    </Button>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
        <Rating rating={review.rating} readOnly />
      </div>
      <p className="mt-2 text-muted-foreground sm:pl-20">{review.comment}</p>
    </div>
  );
}

------------------------------------------------------------
review-update-dialog.tsx

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/hooks/use-toast';
import { Review, ReviewRequest, ReviewUpdateMutation } from '@/types';
import { useEffect, useState } from 'react';

type Props = {
  review: Review;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  updateMutation?: ReviewUpdateMutation;
};

export default function ReviewUpdateDialog({
  review,
  isOpen,
  setIsOpen,
  updateMutation,
}: Props) {
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const { toast } = useToast();

  useEffect(() => {
    if (isOpen) {
      setRating(review.rating);
      setComment(review.comment);
    }
  }, [isOpen, review.comment, review.rating]);

  const handleClickUpdate = () => {
    const requestBody: ReviewRequest = {
      bookId: review.bookId,
      comment,
      rating,
    };
    updateMutation?.mutate(
      { id: review.id, requestBody },
      {
        onSuccess: () => {
          toast({ title: 'レビューを更新しました' });
          setIsOpen(false);
        },
        onError: () => {
          toast({
            title: 'レビューの更新に失敗しました',
            description: '管理者へ連絡してください。',
            variant: 'destructive',
            duration: 5000,
          });
          setIsOpen(false);
        },
      },
    );
  };

  const handleClickCancel = async () => {
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleClickCancel}
        onPointerDownOutside={handleClickCancel}
      >
        <div className="flex items-start justify-between">
          <div>
            <p className="font-semibold leading-10">レビュー</p>
            <p className="text-xs text-muted-foreground sm:text-sm">
              レビュー内容を編集できます。
            </p>
          </div>
          <div>
            <Rating rating={rating} onChange={setRating} />
            <p className="text-center text-xs text-muted-foreground sm:text-sm">
              星をクリックして決定
            </p>
          </div>
        </div>

        <Textarea
          spellCheck={false}
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />

        <DialogFooter className="gap-y-4 sm:gap-y-0">
          <Button
            className="min-w-24 rounded-full"
            variant="ghost"
            onClick={handleClickCancel}
          >
            キャンセル
          </Button>
          <Button
            className="min-w-24 rounded-full"
            disabled={comment === ''}
            onClick={handleClickUpdate}
          >
            更新
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
reviews-book-detail.tsx

import ReviewCreateDialog from '@/components/reviews/review-create-dialog';
import ReviewList from '@/components/reviews/review-list';
import { Button } from '@/components/ui/button';
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { useApiReview } from '@/hooks/api/use-api-review';
import { useAuth } from '@/providers/auth-provider';
import { Review, ReviewRequest } from '@/types';
import {
  useMutation,
  useQuery,
  useQueryClient,
  useSuspenseQuery,
} from '@tanstack/react-query';
import { useEffect, useState } from 'react';

type Props = {
  bookId: string;
};

export default function ReviewsBookDetail({ bookId }: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const [currentPage, setCurrentPage] = useState(1);
  const [reviews, setReviews] = useState<Review[]>([]);
  const [totalPages, setTotalPages] = useState(0);

  const { user } = useAuth();
  const {
    getReviewPage,
    checkSelfReviewExists,
    createReview,
    updateReview,
    deleteReview,
  } = useApiReview();

  const { data: initialReviewPage } = useSuspenseQuery({
    queryKey: ['getReviewPage', bookId, 1],
    queryFn: () => getReviewPage(bookId, 1),
  });

  // ログインしていない場合は、enabledオプションを指定して
  // queryFnを呼び出さないようにする（この指定はuseSuspenseQueryでは出来ない模様）
  const { data: reviewExists = false } = useQuery({
    queryKey: ['checkSelfReviewExists', bookId],
    queryFn: () => checkSelfReviewExists(bookId),
    enabled: !!user,
    retry: false,
  });

  const queryClient = useQueryClient();

  const onSuccess = () => {
    queryClient.invalidateQueries({ queryKey: ['getReviewPage', bookId, 1] });
    queryClient.invalidateQueries({ queryKey: ['getBookDetailsById', bookId] });
    queryClient.invalidateQueries({
      queryKey: ['checkSelfReviewExists', bookId],
    });
  };

  const onError = (error: Error) => {
    console.error(error);
  };

  const createMutation = useMutation({
    mutationFn: (requestBody: ReviewRequest) => createReview(requestBody),
    onSuccess,
    onError,
  });

  const updateMutation = useMutation({
    mutationFn: ({
      id,
      requestBody,
    }: {
      id: number;
      requestBody: ReviewRequest;
    }) => updateReview(id, requestBody),
    onSuccess,
    onError,
  });

  const deleteMutation = useMutation({
    mutationFn: (id: number) => deleteReview(id),
    onSuccess,
    onError,
  });

  useEffect(() => {
    if (initialReviewPage) {
      setCurrentPage(1);
      setReviews(initialReviewPage.reviews);
      setTotalPages(initialReviewPage.totalPages);
    }
  }, [initialReviewPage]);

  const loadMoreReviews = async () => {
    const nextPage = currentPage + 1;
    const nextReviewPage = await getReviewPage(bookId, nextPage);
    setReviews((prevReviews) => [...prevReviews, ...nextReviewPage.reviews]);
    setCurrentPage(nextPage);
  };

  return (
    <div className="mx-auto w-full pb-4 lg:w-3/4">
      <div className="flex flex-col-reverse items-center justify-end gap-y-4 sm:flex-row sm:gap-x-4 sm:px-6">
        <p>レビュー {initialReviewPage.totalItems} 件</p>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              className="w-44 rounded-full bg-transparent"
              variant="outline"
              disabled={user ? reviewExists : true}
              onClick={() => user && setIsOpen(true)}
            >
              {user && reviewExists ? 'レビュー済み' : 'レビューする'}
            </Button>
          </TooltipTrigger>
          {!user && (
            <TooltipContent>
              ログインしてこの本の「レビュー」を書きましょう
            </TooltipContent>
          )}
        </Tooltip>
        <ReviewCreateDialog
          bookId={bookId}
          page={currentPage}
          isOpen={isOpen}
          setIsOpen={setIsOpen}
          createMutation={createMutation}
        />
      </div>

      <ReviewList
        reviews={reviews}
        updateMutation={updateMutation}
        deleteMutation={deleteMutation}
      />

      {currentPage < totalPages && (
        <div className="flex justify-center">
          <Button
            className="w-44 rounded-full text-muted-foreground"
            variant="ghost"
            onClick={loadMoreReviews}
          >
            もっと見る
          </Button>
        </div>
      )}
    </div>
  );
}

------------------------------------------------------------
avatar.tsx

import { cn } from '@/lib/utils';
import React, { useContext, useEffect, useState } from 'react';

interface AvatarContextType {
  imageError: boolean;
  setImageError: (value: boolean) => void;
}

const AvatarContext = React.createContext<AvatarContextType | undefined>(
  undefined,
);

// ----------------------------------------------------------------------------
// Avatar
// ----------------------------------------------------------------------------
type AvatarProps = React.HTMLAttributes<HTMLDivElement>;

const Avatar = React.forwardRef<HTMLDivElement, AvatarProps>(
  ({ children, className, ...props }, ref) => {
    const [imageError, setImageError] = useState(false);

    useEffect(() => {
      // AvatarImageがなければ画像読み込みエラーとする
      const image = React.Children.toArray(children).find(
        (child) => React.isValidElement(child) && child.type === AvatarImage,
      );
      if (!image) setImageError(true);
    }, [children]);

    return (
      <AvatarContext.Provider value={{ imageError, setImageError }}>
        <div
          ref={ref}
          className={cn(
            'relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full',
            className,
          )}
          {...props}
        >
          {React.Children.map(children, (child) => {
            if (React.isValidElement(child)) {
              switch (child.type) {
                case AvatarImage:
                case AvatarFallback:
                  return child;
                default:
                  return null;
              }
            }
          })}
        </div>
      </AvatarContext.Provider>
    );
  },
);

// ----------------------------------------------------------------------------
// AvatarImage
// ----------------------------------------------------------------------------
interface AvatarImageProps extends React.HTMLAttributes<HTMLImageElement> {
  src: string;
  alt: string;
}

const AvatarImage = React.forwardRef<HTMLImageElement, AvatarImageProps>(
  ({ className, ...props }, ref) => {
    const context = useContext(AvatarContext);
    if (!context) throw new Error('AvatarImage must be used within Avatar');

    const { imageError, setImageError } = context;

    if (imageError) return null;

    return (
      <img
        ref={ref}
        className={cn('aspect-square h-full w-full', className)}
        {...props}
        onError={() => setImageError(true)}
      />
    );
  },
);

// ----------------------------------------------------------------------------
// AvatarFallback
// ----------------------------------------------------------------------------
type AvatarFallbackProps = React.HTMLAttributes<HTMLDivElement>;

const AvatarFallback = React.forwardRef<HTMLDivElement, AvatarFallbackProps>(
  ({ className, ...props }, ref) => {
    const context = useContext(AvatarContext);
    if (!context) throw new Error('AvatarFallback must be used within Avatar');

    const { imageError } = context;

    if (!imageError) return null;

    return (
      <div
        ref={ref}
        className={cn(
          'flex h-full w-full items-center justify-center rounded-full bg-primary/50',
          className,
        )}
        {...props}
      />
    );
  },
);

export { Avatar, AvatarFallback, AvatarImage };

------------------------------------------------------------
button.tsx

import { cn } from '@/lib/utils';
import React, { ButtonHTMLAttributes } from 'react';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className,
      children,
      variant = 'default',
      size = 'default',
      asChild = false,
      ...props
    },
    ref,
  ) => {
    const VARIANT = {
      default: 'bg-primary text-primary-foreground hover:bg-primary/90',
      destructive:
        'bg-destructive text-destructive-foreground hover:bg-destructive/90',
      outline:
        'border border-primary/50 text-primary bg-background hover:bg-primary/20 hover:border-primary',
      secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
      ghost:
        'bg-transparent text-foreground hover:bg-primary/20 hover:text-primary',
    };

    const SIZE = {
      default: 'h-10 px-4 py-2',
      sm: 'h-9 rounded-md px-3',
      lg: 'h-11 rounded-md px-8',
      icon: 'size-10',
    };

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
        className: cn(
          'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
          VARIANT[variant],
          SIZE[size],
          className,
        ),
      };
      return React.cloneElement(children, { ...mergeChildProps, ref });
    }

    return (
      <button
        ref={ref}
        className={cn(
          'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
          VARIANT[variant],
          SIZE[size],
          className,
        )}
        {...props}
      >
        {children}
      </button>
    );
  },
);

export { Button };

------------------------------------------------------------
card.tsx

import { cn } from '@/lib/utils';
import React from 'react';

// ----------------------------------------------------------------------------
// Card
// ----------------------------------------------------------------------------
const Card = ({
  className,
  children,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => {
  return (
    <div
      className={cn(
        'rounded-lg border bg-card text-card-foreground shadow-sm',
        className,
      )}
      {...props}
    >
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case CardHeader:
            case CardTitle:
            case CardDescription:
            case CardContent:
            case CardFooter:
              return child;
            default:
              return null;
          }
        }
      })}
    </div>
  );
};

// ----------------------------------------------------------------------------
// CardHeader
// ----------------------------------------------------------------------------
const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
));

// ----------------------------------------------------------------------------
// CardTitle
// ----------------------------------------------------------------------------
const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'text-2xl font-semibold leading-none tracking-tight',
      className,
    )}
    {...props}
  />
));

// ----------------------------------------------------------------------------
// CardDescription
// ----------------------------------------------------------------------------
const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));

// ----------------------------------------------------------------------------
// CardContent
// ----------------------------------------------------------------------------
const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('', className)} {...props} />
));

// ----------------------------------------------------------------------------
// CardFooter
// ----------------------------------------------------------------------------
const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex items-center p-6 pt-0', className)}
    {...props}
  />
));

export {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
};

------------------------------------------------------------
dialog.tsx

import { cn } from '@/lib/utils';
import React, {
  useCallback,
  useContext,
  useEffect,
  useRef,
  useState,
} from 'react';
import ReactDOM from 'react-dom';

interface DialogContextType {
  isOpen: boolean;
  openDialog: () => void;
  closeDialog: () => void;
}

const DialogContext = React.createContext<DialogContextType | undefined>(
  undefined,
);

// ----------------------------------------------------------------------------
// Dialog
// ----------------------------------------------------------------------------
interface DialogProps extends React.DialogHTMLAttributes<HTMLDialogElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const Dialog = ({ children, open, onOpenChange }: DialogProps) => {
  // 外部からの状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openDialog = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeDialog = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  return (
    <DialogContext.Provider value={{ isOpen, openDialog, closeDialog }}>
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case DialogTrigger:
            case DialogContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </DialogContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// DialogTrigger
// ----------------------------------------------------------------------------
interface DialogTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const DialogTrigger = React.forwardRef<HTMLButtonElement, DialogTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    const context = useContext(DialogContext);
    if (!context) throw new Error('DialogTrigger must be used within Dialog');

    const { openDialog } = context;

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
        onClick: (e: React.MouseEvent) => {
          children.props.onClick?.(e);
          openDialog();
        },
      };
      return React.cloneElement(children, { ...mergeChildProps, ref });
    }

    const mergeProps = {
      ...props,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        props.onClick?.(e);
        openDialog();
      },
    };

    return (
      <button ref={ref} {...mergeProps}>
        {children}
      </button>
    );
  },
);

// ----------------------------------------------------------------------------
// DialogOverlay
// ----------------------------------------------------------------------------
type DialogOverlayProps = React.HTMLAttributes<HTMLDivElement>;

const DialogOverlay = ({ className, ...props }: DialogOverlayProps) => {
  const context = useContext(DialogContext);
  if (!context) throw new Error('DialogOverlay must be used within Dialog');

  const { isOpen } = context;

  return (
    <div
      className={cn(
        'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
        'fill-mode-both',
        className,
      )}
      data-state={isOpen ? 'open' : 'closed'}
      {...props}
    ></div>
  );
};

// ----------------------------------------------------------------------------
// DialogContent
// ----------------------------------------------------------------------------
interface DialogContentProps extends React.HTMLAttributes<HTMLDivElement> {
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
}
const DialogContent = ({
  className,
  children,
  onEscapeKeyDown,
  onPointerDownOutside,
  ...props
}: DialogContentProps) => {
  const context = useContext(DialogContext);
  if (!context) throw new Error('DialogContent must be used within Dialog');

  const { isOpen, closeDialog } = context;
  const [isVisible, setIsVisible] = useState(false);
  const dialogRef = useRef<HTMLDivElement>(null);

  const handleWheel = useCallback((e: WheelEvent) => {
    const isInsideDialog =
      e.target instanceof Node && dialogRef.current?.contains(e.target);

    if (!isInsideDialog) {
      e.preventDefault();
      return;
    }

    let target = e.target as HTMLElement;
    while (target && target !== dialogRef.current) {
      const { overflowY } = window.getComputedStyle(target);
      const isScrollable = overflowY === 'auto' || overflowY === 'scroll';
      const hasScrollableContent = target.scrollHeight > target.clientHeight;

      if (isScrollable && hasScrollableContent) {
        const scrollTop = target.scrollTop;
        const scrollHeight = target.scrollHeight;
        const clientHeight = target.clientHeight;

        if (scrollTop === 0 && e.deltaY < 0) {
          e.preventDefault();
        } else if (scrollTop + clientHeight >= scrollHeight && e.deltaY > 0) {
          e.preventDefault();
        }
        return;
      }
      target = target.parentElement as HTMLElement;
    }

    e.preventDefault();
  }, []);

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (!isOpen) return;

      if (e.key === 'Escape') {
        if (onEscapeKeyDown) {
          onEscapeKeyDown();
        } else {
          closeDialog();
        }
      }
    },
    [closeDialog, isOpen, onEscapeKeyDown],
  );

  useEffect(() => {
    if (isOpen) {
      setIsVisible(true);
      document.addEventListener('wheel', handleWheel, { passive: false });
      document.addEventListener('keydown', handleKeyDown);
    } else {
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    }
    return () => {
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown, handleWheel, isOpen]);

  const handlePointerDownOutside = () => {
    if (onPointerDownOutside) {
      onPointerDownOutside();
    } else {
      closeDialog();
    }
  };

  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit') {
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      props.onAnimationEnd?.(e);
      handleAnimationEnd(e);
    },
  };

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <DialogOverlay onClick={handlePointerDownOutside} />
          <div
            ref={dialogRef}
            className={cn(
              'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
              'fill-mode-both',
              className,
            )}
            data-state={isOpen ? 'open' : 'closed'}
            {...mergeProps}
          >
            {children}
          </div>
        </>
      )}
    </>,
    document.body,
  );
};

// ----------------------------------------------------------------------------
// DialogHeader
// ----------------------------------------------------------------------------
const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-1.5 text-center sm:text-left',
      className,
    )}
    {...props}
  />
);

// ----------------------------------------------------------------------------
// DialogFooter
// ----------------------------------------------------------------------------
const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className,
    )}
    {...props}
  />
);

// ----------------------------------------------------------------------------
// DialogTitle
// ----------------------------------------------------------------------------
type DialogTitleProps = React.HTMLAttributes<HTMLDivElement>;
const DialogTitle = React.forwardRef<HTMLDivElement, DialogTitleProps>(
  ({ className, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          'text-lg font-semibold leading-none tracking-tight',
          className,
        )}
        {...props}
      />
    );
  },
);

// ----------------------------------------------------------------------------
// DialogDescription
// ----------------------------------------------------------------------------
type DialogDescriptionProps = React.HTMLAttributes<HTMLDivElement>;
const DialogDescription = React.forwardRef<
  HTMLDivElement,
  DialogDescriptionProps
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      className={cn('text-sm text-muted-foreground', className)}
      {...props}
    />
  );
});

export {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogTitle,
  DialogTrigger,
};

------------------------------------------------------------
dropdown-menu.tsx

import { cn } from '@/lib/utils';
import React, {
  useCallback,
  useContext,
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
} from 'react';
import ReactDOM from 'react-dom';

type DropdownMenuSideType = 'top' | 'right' | 'bottom' | 'left';
type DropdownMenuAlignType = 'start' | 'center' | 'end';

const DEFAULT_SIDE: DropdownMenuSideType = 'bottom';
const DEFAULT_ALIGN: DropdownMenuAlignType = 'center';
const DEFAULT_SIDE_OFFSET = 4;

interface DropdownMenuContextType {
  isOpen: boolean;
  openDropdownMenu: () => void;
  closeDropdownMenu: () => void;
  triggerRef: React.MutableRefObject<HTMLDivElement | HTMLButtonElement | null>;
  focusedIndex: number;
  setFocusedIndex: (index: number) => void;
  itemsRef: React.MutableRefObject<HTMLButtonElement[]>;
}

const DropdownMenuContext = React.createContext<
  DropdownMenuContextType | undefined
>(undefined);

// ----------------------------------------------------------------------------
// DropdownMenu
// ----------------------------------------------------------------------------
interface DropdownMenuProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const DropdownMenu = ({ children, open, onOpenChange }: DropdownMenuProps) => {
  // 外部からの状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const itemsRef = useRef<HTMLButtonElement[]>([]);

  // propsが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openDropdownMenu = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeDropdownMenu = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  const triggerRef = useRef<HTMLDivElement | null>(null);

  return (
    <DropdownMenuContext.Provider
      value={{
        isOpen,
        openDropdownMenu,
        closeDropdownMenu,
        triggerRef,
        focusedIndex,
        setFocusedIndex,
        itemsRef,
      }}
    >
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case DropdownMenuTrigger:
            case DropdownMenuContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </DropdownMenuContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// DropdownMenuTrigger
// ----------------------------------------------------------------------------
interface DropdownMenuTriggerProps
  extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const DropdownMenuTrigger = React.forwardRef<
  HTMLButtonElement,
  DropdownMenuTriggerProps
>(({ className, children, asChild = false, ...props }, ref) => {
  const context = useContext(DropdownMenuContext);
  if (!context)
    throw new Error('DropdownMenuContent must be used within DropdownMenu');

  const { openDropdownMenu, triggerRef } = context;

  if (asChild && React.isValidElement(children)) {
    const mergeChildProps = {
      ...children.props,
      onClick: (e: React.MouseEvent) => {
        children.props.onClick?.(e);
        openDropdownMenu();
      },
    };
    return (
      <div
        ref={triggerRef as React.MutableRefObject<HTMLDivElement>}
        className={cn('w-fit', className)}
      >
        {React.cloneElement(children, { ...mergeChildProps, ref })}
      </div>
    );
  }
  const mergeProps = {
    ...props,
    onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
      props.onClick?.(e);
      openDropdownMenu();
    },
  };

  return (
    <button
      ref={triggerRef as React.MutableRefObject<HTMLButtonElement>}
      className={cn('w-fit', className)}
      {...mergeProps}
    >
      {children}
    </button>
  );
});

// ----------------------------------------------------------------------------
// DropdownMenuContent
// ----------------------------------------------------------------------------
interface DropdownMenuContentProps
  extends React.HTMLAttributes<HTMLDivElement> {
  side?: DropdownMenuSideType;
  align?: DropdownMenuAlignType;
  sideOffset?: number;
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
}

const DropdownMenuContent = ({
  children,
  className,
  side = DEFAULT_SIDE,
  align = DEFAULT_ALIGN,
  sideOffset = DEFAULT_SIDE_OFFSET,
  onEscapeKeyDown,
  onPointerDownOutside,
  ...props
}: DropdownMenuContentProps) => {
  const context = useContext(DropdownMenuContext);
  if (!context)
    throw new Error('DropdownMenuContent must be used within DropdownMenu');

  const {
    isOpen,
    closeDropdownMenu,
    triggerRef,
    focusedIndex,
    itemsRef,
    setFocusedIndex,
  } = context;

  const [isVisible, setIsVisible] = useState(false);

  const handleArrawNavigation = useCallback(
    (key: string) => {
      const isArrowUp = key === 'ArrowUp';
      const itemCount = itemsRef.current.length;

      let newIndex = focusedIndex;

      if (focusedIndex === -1) {
        newIndex = isArrowUp ? itemCount - 1 : 0;
      } else {
        newIndex = isArrowUp
          ? (focusedIndex - 1 + itemCount) % itemCount
          : (focusedIndex + 1) % itemCount;
      }

      setFocusedIndex(newIndex);
      itemsRef.current[newIndex].focus();
    },
    [focusedIndex, itemsRef, setFocusedIndex],
  );

  const handleWheel = useCallback((e: WheelEvent) => {
    e.preventDefault();
  }, []);

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (!isOpen) return;

      switch (e.key) {
        case 'Escape':
          if (onEscapeKeyDown) {
            onEscapeKeyDown();
          } else {
            closeDropdownMenu();
          }
          break;

        case 'Tab':
          e.preventDefault();
          break;

        case 'ArrowUp':
        case 'ArrowDown':
          e.preventDefault();
          handleArrawNavigation(e.key);
          break;
      }
    },
    [closeDropdownMenu, handleArrawNavigation, isOpen, onEscapeKeyDown],
  );

  useEffect(() => {
    if (isOpen) {
      setIsVisible(true);
      document.addEventListener('wheel', handleWheel, { passive: false });
      document.addEventListener('keydown', handleKeyDown);
    } else {
      setFocusedIndex(-1);
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    }
    return () => {
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown, handleWheel, isOpen, setFocusedIndex]);

  const handlePointerDownOutside = () => {
    if (onPointerDownOutside) {
      onPointerDownOutside();
    } else {
      closeDropdownMenu();
    }
  };

  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit') {
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      props.onAnimationEnd?.(e);
      handleAnimationEnd(e);
    },
  };

  const [transformStyle, setTransformStyle] = useState('');

  useLayoutEffect(() => {
    // triggerとなる要素からDropdownMenuを表示する座標を計算する
    // （style属性に指定する文字列作成）
    if (triggerRef.current) {
      const { left, top, right, bottom, width, height } =
        triggerRef.current.getBoundingClientRect();

      const getOffset = (align: DropdownMenuAlignType, size: number) => {
        switch (align) {
          case 'start':
            return `0% - ${size / 2}px`;
          case 'end':
            return `-100% + ${size / 2}px`;
          default:
            return '-50%';
        }
      };

      const offsetX = getOffset(align, width);
      const offsetY = getOffset(align, height);

      const positions = {
        top: {
          x: left + width / 2,
          y: top,
          offset: { x: offsetX, y: `-100% - ${sideOffset}px` },
        },
        bottom: {
          x: left + width / 2,
          y: bottom,
          offset: { x: offsetX, y: `0% + ${sideOffset}px` },
        },
        left: {
          x: left,
          y: top + height / 2,
          offset: { x: `-100% - ${sideOffset}px`, y: offsetY },
        },
        right: {
          x: right,
          y: top + height / 2,
          offset: { x: `0% + ${sideOffset}px`, y: offsetY },
        },
      };
      const pos = positions[side];

      setTransformStyle(
        `translate(calc(${pos.x}px + ${pos.offset.x}), calc(${pos.y}px + ${pos.offset.y}))`,
      );
    }
  }, [context, triggerRef, side, sideOffset, align]);

  let itemIndex = 0;
  const innerChildren = React.Children.map(children, (child) => {
    if (React.isValidElement(child)) {
      switch (child.type) {
        case DropdownMenuItem:
          return React.cloneElement(child, {
            ...child.props,
            index: itemIndex++,
          });
        default:
          return child;
      }
    }
  });

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <div
            className="fixed inset-0 z-50"
            onClick={handlePointerDownOutside}
          />
          <div
            className="fixed left-0 top-0 z-50"
            style={{ transform: transformStyle }}
          >
            <div
              className={cn(
                'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
                'fill-mode-both',
                className,
              )}
              data-state={isOpen ? 'open' : 'closed'}
              data-side={side}
              {...mergeProps}
            >
              {innerChildren}
            </div>
          </div>
        </>
      )}
    </>,
    document.body,
  );
};

// ----------------------------------------------------------------------------
// DropdownMenuItem
// ----------------------------------------------------------------------------
interface DropdownMenuItemProps
  extends React.HTMLAttributes<HTMLButtonElement> {
  index?: number;
  inset?: boolean;
}
const DropdownMenuItem = ({
  className,
  children,
  index = 0,
  inset,
  ...props
}: DropdownMenuItemProps) => {
  const context = useContext(DropdownMenuContext);
  if (!context)
    throw new Error('DropdownMenuItem must be used within DropdownMenu');

  const { itemsRef, closeDropdownMenu } = context;

  const mergeProps = {
    ...props,
    onMouseEnter: (e: React.MouseEvent<HTMLButtonElement>) => {
      props.onMouseEnter?.(e);
      itemsRef.current[index].focus();
    },
    onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
      if (props.onClick) {
        props.onClick(e);
        return;
      }
      closeDropdownMenu();
    },
  };

  return (
    <button
      ref={(el) => (itemsRef.current[index] = el as HTMLButtonElement)}
      className={cn(
        'relative w-full flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0',
        inset && 'pl-8',
        className,
      )}
      tabIndex={-1}
      {...mergeProps}
    >
      {children}
    </button>
  );
};

// ----------------------------------------------------------------------------
// DropdownMenuSeparator
// ----------------------------------------------------------------------------
type DropdownMenuSeparatorProps = React.HTMLAttributes<HTMLDivElement>;
const DropdownMenuSeparator = React.forwardRef<
  HTMLDivElement,
  DropdownMenuSeparatorProps
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));

// ----------------------------------------------------------------------------
// DropdownMenuLabel
// ----------------------------------------------------------------------------
interface DropdownMenuLabelProps extends React.HTMLAttributes<HTMLDivElement> {
  inset?: boolean;
}
const DropdownMenuLabel = React.forwardRef<
  HTMLDivElement,
  DropdownMenuLabelProps
>(({ className, inset, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold',
      inset && 'pl-8',
      className,
    )}
    {...props}
  />
));

export {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
};

------------------------------------------------------------
input.tsx

import { cn } from '@/lib/utils';
import React from 'react';

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<'input'>>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        ref={ref}
        className={cn(
          'flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className,
        )}
        type={type}
        {...props}
      />
    );
  },
);

export { Input };

------------------------------------------------------------
label.tsx

import { cn } from '@/lib/utils';
import React, { LabelHTMLAttributes } from 'react';

type LabelProps = LabelHTMLAttributes<HTMLLabelElement>;

const Label = React.forwardRef<HTMLLabelElement, LabelProps>(
  ({ className, ...props }, ref) => (
    <label
      ref={ref}
      className={cn(
        'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70',
        className,
      )}
      {...props}
    />
  ),
);

export { Label };

------------------------------------------------------------
radio-group.tsx

import { cn } from '@/lib/utils';
import { Circle } from 'lucide-react';
import React, {
  ButtonHTMLAttributes,
  useCallback,
  useContext,
  useEffect,
  useState,
} from 'react';

interface RadioGroupContextType {
  checkedId: string | undefined;
  setCheckedId: (value: string | undefined) => void;
  innerValue: string;
  setValue: (value: string) => void;
}

const RadioGroupContext = React.createContext<
  RadioGroupContextType | undefined
>(undefined);

interface RadioGroupProps extends React.HTMLAttributes<HTMLDivElement> {
  value?: string;
  onValueChange?: (value: string) => void;
  defaultValue?: string;
}

const RadioGroup = ({
  className,
  children,
  value,
  onValueChange,
  ...props
}: RadioGroupProps) => {
  // 外部からの状態を優先し、指定がない場合は内部状態を利用
  const [innerValue, setInnerValue] = useState(value ?? '');

  // propsが更新されたら内部状態も更新
  useEffect(() => {
    if (value !== undefined) {
      setInnerValue(value);
    }
  }, [value]);

  const setValue = useCallback(
    (value: string) => {
      if (onValueChange) {
        onValueChange(value);
      } else {
        setInnerValue(value);
      }
    },
    [onValueChange],
  );

  const [checkedId, setCheckedId] = useState<string | undefined>(undefined);

  return (
    <RadioGroupContext.Provider
      value={{
        checkedId,
        setCheckedId,
        innerValue,
        setValue,
      }}
    >
      <div className={cn('grid gap-2', className)} {...props}>
        {children}
      </div>
    </RadioGroupContext.Provider>
  );
};

type RadioGroupItemProps = ButtonHTMLAttributes<HTMLButtonElement>;

const RadioGroupItem = React.forwardRef<HTMLButtonElement, RadioGroupItemProps>(
  ({ className, ...props }, ref) => {
    const context = useContext(RadioGroupContext);
    if (!context) throw new Error('DialogTrigger must be used within Dialog');

    const { setCheckedId, setValue, innerValue } = context;

    const handleClick = () => {
      setCheckedId(props.id);

      const value = typeof props.value === 'string' ? props.value : '';
      setValue(value);
    };

    return (
      <button
        ref={ref}
        className={cn(
          'aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className,
        )}
        type="button"
        {...props}
        onClick={handleClick}
      >
        {innerValue === props.value && (
          <span className="flex items-center justify-center">
            <Circle className="size-2.5 fill-current text-current" />
          </span>
        )}
      </button>
    );
  },
);

export { RadioGroup, RadioGroupItem };

------------------------------------------------------------
select.tsx

import { cn } from '@/lib/utils';
import { CheckIcon, ChevronDownIcon } from 'lucide-react';
import React, {
  useCallback,
  useContext,
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
} from 'react';
import ReactDOM from 'react-dom';

type SelectSideType = 'top' | 'right' | 'bottom' | 'left';
type SelectAlignType = 'start' | 'center' | 'end';

const DEFAULT_SIDE: SelectSideType = 'bottom';
const DEFAULT_ALIGN: SelectAlignType = 'center';
const DEFAULT_SIDE_OFFSET = 4;

interface SelectContextType {
  isOpen: boolean;
  openSelect: () => void;
  closeSelect: () => void;
  triggerRef: React.MutableRefObject<HTMLDivElement | HTMLButtonElement | null>;
  focusedIndex: number;
  setFocusedIndex: (index: number) => void;
  itemsRef: React.MutableRefObject<HTMLButtonElement[]>;
  innerValue: string;
  setValue: (value: string) => void;
}

const SelectContext = React.createContext<SelectContextType | undefined>(
  undefined,
);

// ----------------------------------------------------------------------------
// Select
// ----------------------------------------------------------------------------
interface SelectProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
  value?: string;
  onValueChange?: (value: string) => void;
}

const Select = ({
  children,
  open,
  onOpenChange,
  value,
  onValueChange,
}: SelectProps) => {
  // 外部からの状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const itemsRef = useRef<HTMLButtonElement[]>([]);
  const [innerValue, setInnerValue] = useState(value ?? '');

  // propsが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  useEffect(() => {
    if (value !== undefined) {
      setInnerValue(value);
    }
  }, [value]);

  const openSelect = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeSelect = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  const setValue = useCallback(
    (value: string) => {
      if (onValueChange) {
        onValueChange(value);
      } else {
        setInnerValue(value);
      }
    },
    [onValueChange],
  );

  const triggerRef = useRef<HTMLDivElement | null>(null);

  return (
    <SelectContext.Provider
      value={{
        isOpen,
        openSelect,
        closeSelect,
        triggerRef,
        focusedIndex,
        setFocusedIndex,
        itemsRef,
        innerValue,
        setValue,
      }}
    >
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case SelectTrigger:
            case SelectContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </SelectContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// SelectTrigger
// ----------------------------------------------------------------------------
interface SelectTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const SelectTrigger = React.forwardRef<HTMLButtonElement, SelectTriggerProps>(
  ({ className, children, asChild = false, ...props }, ref) => {
    const context = useContext(SelectContext);
    if (!context) throw new Error('SelectContent must be used within Select');

    const { openSelect, triggerRef } = context;

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
        onClick: (e: React.MouseEvent) => {
          children.props.onClick?.(e);
          openSelect();
        },
      };
      return (
        <div
          ref={triggerRef as React.MutableRefObject<HTMLDivElement>}
          className={cn('w-fit', className)}
        >
          {React.cloneElement(children, { ...mergeChildProps, ref })}
        </div>
      );
    }

    const mergeProps = {
      ...props,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        props.onClick?.(e);
        openSelect();
      },
    };

    return (
      <button
        ref={triggerRef as React.MutableRefObject<HTMLButtonElement>}
        className={cn(
          'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
          className,
        )}
        {...mergeProps}
      >
        {React.Children.map(children, (child) => {
          if (React.isValidElement(child)) {
            switch (child.type) {
              case SelectValue:
                return child;
              default:
                return null;
            }
          }
        })}
        <ChevronDownIcon className="size-4 opacity-50" />
      </button>
    );
  },
);

// ----------------------------------------------------------------------------
// SelectContent
// ----------------------------------------------------------------------------
interface SelectContentProps extends React.HTMLAttributes<HTMLDivElement> {
  side?: SelectSideType;
  align?: SelectAlignType;
  sideOffset?: number;
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
  position?: 'item-aligned' | 'popper';
}

const SelectContent = ({
  children,
  className,
  side = DEFAULT_SIDE,
  align = DEFAULT_ALIGN,
  sideOffset = DEFAULT_SIDE_OFFSET,
  onEscapeKeyDown,
  onPointerDownOutside,
  position = 'item-aligned',
  ...props
}: SelectContentProps) => {
  const context = useContext(SelectContext);
  if (!context) throw new Error('SelectContent must be used within Select');

  const {
    isOpen,
    closeSelect,
    triggerRef,
    focusedIndex,
    itemsRef,
    setFocusedIndex,
  } = context;

  const [isVisible, setIsVisible] = useState(false);

  const handleArrawNavigation = useCallback(
    (key: string) => {
      const isArrowUp = key === 'ArrowUp';
      const itemCount = itemsRef.current.length;

      const newIndex = isArrowUp
        ? (focusedIndex - 1 + itemCount) % itemCount
        : (focusedIndex + 1) % itemCount;

      setFocusedIndex(newIndex);
      itemsRef.current[newIndex].focus();
    },
    [focusedIndex, itemsRef, setFocusedIndex],
  );

  const handleWheel = useCallback((e: WheelEvent) => {
    e.preventDefault();
  }, []);

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (!isOpen) return;

      switch (e.key) {
        case 'Escape':
          if (onEscapeKeyDown) {
            onEscapeKeyDown();
          } else {
            closeSelect();
          }
          break;

        case 'Tab':
          e.preventDefault();
          break;

        case 'ArrowUp':
        case 'ArrowDown':
          e.preventDefault();
          handleArrawNavigation(e.key);
          break;
      }
    },
    [closeSelect, handleArrawNavigation, isOpen, onEscapeKeyDown],
  );

  useEffect(() => {
    if (isOpen) {
      setIsVisible(true);
      document.addEventListener('wheel', handleWheel, { passive: false });
      document.addEventListener('keydown', handleKeyDown);
    } else {
      setFocusedIndex(-1);
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    }
    return () => {
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown, handleWheel, isOpen, setFocusedIndex]);

  const handlePointerDownOutside = () => {
    if (onPointerDownOutside) {
      onPointerDownOutside();
    } else {
      closeSelect();
    }
  };

  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit') {
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      props.onAnimationEnd?.(e);
      handleAnimationEnd(e);
    },
  };

  const [transformStyle, setTransformStyle] = useState('');

  useLayoutEffect(() => {
    // triggerとなる要素からSelectを表示する座標を計算する
    // （style属性に指定する文字列作成）
    if (triggerRef.current) {
      const { left, top, right, bottom, width, height } =
        triggerRef.current.getBoundingClientRect();

      const getOffset = (align: SelectAlignType, size: number) => {
        switch (align) {
          case 'start':
            return `0% - ${size / 2}px`;
          case 'end':
            return `-100% + ${size / 2}px`;
          default:
            return '-50%';
        }
      };

      const offsetX = getOffset(align, width);
      const offsetY = getOffset(align, height);

      const positions = {
        top: {
          x: left + width / 2,
          y: top,
          offset: { x: offsetX, y: `-100% - ${sideOffset}px` },
        },
        bottom: {
          x: left + width / 2,
          y: bottom,
          offset: { x: offsetX, y: `0% + ${sideOffset}px` },
        },
        left: {
          x: left,
          y: top + height / 2,
          offset: { x: `-100% - ${sideOffset}px`, y: offsetY },
        },
        right: {
          x: right,
          y: top + height / 2,
          offset: { x: `0% + ${sideOffset}px`, y: offsetY },
        },
      };
      const pos = positions[side];

      setTransformStyle(
        `translate(calc(${pos.x}px + ${pos.offset.x}), calc(${pos.y}px + ${pos.offset.y}))`,
      );
    }
  }, [context, triggerRef, side, sideOffset, align]);

  let itemIndex = 0;
  const innerChildren = React.Children.map(children, (child) => {
    if (React.isValidElement(child)) {
      switch (child.type) {
        case SelectItem:
          return React.cloneElement(child, {
            ...child.props,
            index: itemIndex++,
          });
        default:
          return child;
      }
    }
  });

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <div
            className="fixed inset-0 z-50"
            onClick={handlePointerDownOutside}
          />
          <div
            className="fixed left-0 top-0 z-50"
            style={{ transform: transformStyle }}
          >
            <div
              className={cn(
                'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
                'fill-mode-both',
                position === 'popper' &&
                  'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
                className,
              )}
              style={{ minWidth: `${triggerRef.current?.offsetWidth}px` }}
              data-state={isOpen ? 'open' : 'closed'}
              data-side={side}
              {...mergeProps}
            >
              <div
                className={cn(
                  'p-1',
                  position === 'popper' &&
                    'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]',
                )}
              >
                {innerChildren}
              </div>
            </div>
          </div>
        </>
      )}
    </>,
    document.body,
  );
};

// ----------------------------------------------------------------------------
// SelectItem
// ----------------------------------------------------------------------------
interface SelectItemProps extends React.HTMLAttributes<HTMLButtonElement> {
  index?: number;
  value?: string;
}
const SelectItem = ({
  className,
  children,
  index = 0,
  value,
  ...props
}: SelectItemProps) => {
  const context = useContext(SelectContext);
  if (!context) throw new Error('SelectItem must be used within Select');

  const { innerValue, itemsRef, setFocusedIndex, setValue, closeSelect } =
    context;

  useEffect(() => {
    if (innerValue === value) {
      itemsRef.current[index].focus();
      setFocusedIndex(index);
    }
  }, [index, innerValue, itemsRef, setFocusedIndex, value]);

  const mergeProps = {
    ...props,
    onMouseEnter: (e: React.MouseEvent<HTMLButtonElement>) => {
      props.onMouseEnter?.(e);
      itemsRef.current[index].focus();
    },
    onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
      if (props.onClick) {
        props.onClick(e);
        return;
      }
      setValue(value ?? '');
      closeSelect();
    },
  };

  return (
    <button
      ref={(el) => (itemsRef.current[index] = el as HTMLButtonElement)}
      className={cn(
        'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
        className,
      )}
      tabIndex={-1}
      {...mergeProps}
    >
      <span className="absolute left-2 flex size-3.5 items-center justify-center">
        {innerValue === value && <CheckIcon className="size-4" />}
      </span>
      {children}
    </button>
  );
};
// ----------------------------------------------------------------------------
// SelectSeparator
// ----------------------------------------------------------------------------
type SelectSeparatorProps = React.HTMLAttributes<HTMLDivElement>;
const SelectSeparator = React.forwardRef<HTMLDivElement, SelectSeparatorProps>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('-mx-1 my-1 h-px bg-muted', className)}
      {...props}
    />
  ),
);

// ----------------------------------------------------------------------------
// SelectLabel
// ----------------------------------------------------------------------------
type SelectLabelProps = React.HTMLAttributes<HTMLDivElement>;
const SelectLabel = React.forwardRef<HTMLDivElement, SelectLabelProps>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
      {...props}
    />
  ),
);

// ----------------------------------------------------------------------------
// SelectValue
// ----------------------------------------------------------------------------
interface SelectValueProps extends React.HTMLAttributes<HTMLDivElement> {
  placeholder?: string;
}
const SelectValue = React.forwardRef<HTMLDivElement, SelectValueProps>(
  ({ className, placeholder, ...props }, ref) => {
    const context = useContext(SelectContext);
    if (!context) throw new Error('SelectValue must be used within Select');

    const { innerValue } = context;

    return (
      <span ref={ref} className={cn('', className)} {...props}>
        {innerValue || placeholder}
      </span>
    );
  },
);

export {
  Select,
  SelectContent,
  SelectItem,
  SelectLabel,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};

------------------------------------------------------------
separator.tsx

import { cn } from '@/lib/utils';
import React from 'react';

interface SeparatorProps extends React.HTMLAttributes<HTMLDivElement> {
  orientation?: 'horizontal' | 'vertical';
}

const Separator = React.forwardRef<HTMLDivElement, SeparatorProps>(
  ({ className, orientation = 'horizontal', ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        'shrink-0 bg-border',
        orientation === 'horizontal' ? 'h-[1px] w-full' : 'h-full w-[1px]',
        className,
      )}
      {...props}
    />
  ),
);

export { Separator };

------------------------------------------------------------
sheet.tsx

import { cn } from '@/lib/utils';
import React, {
  useCallback,
  useContext,
  useEffect,
  useRef,
  useState,
} from 'react';
import ReactDOM from 'react-dom';

type SheetSideType = 'top' | 'right' | 'bottom' | 'left';

const DEFAULT_SIDE: SheetSideType = 'right';

interface SheetContextType {
  isOpen: boolean;
  openSheet: () => void;
  closeSheet: () => void;
}

const SheetContext = React.createContext<SheetContextType | undefined>(
  undefined,
);

// ----------------------------------------------------------------------------
// Sheet
// ----------------------------------------------------------------------------
interface SheetProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const Sheet = ({ children, open, onOpenChange }: SheetProps) => {
  // 外部からの状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openSheet = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeSheet = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  return (
    <SheetContext.Provider value={{ isOpen, openSheet, closeSheet }}>
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case SheetTrigger:
            case SheetContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </SheetContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// SheetTrigger
// ----------------------------------------------------------------------------
interface SheetTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}
const SheetTrigger = React.forwardRef<HTMLButtonElement, SheetTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    const context = useContext(SheetContext);
    if (!context) throw new Error('SheetTrigger must be used within Sheet');

    const { openSheet } = context;

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
        onClick: (e: React.MouseEvent) => {
          children.props.onClick?.(e);
          openSheet();
        },
      };
      return React.cloneElement(children, { ...mergeChildProps, ref });
    }

    const mergeProps = {
      ...props,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        props.onClick?.(e);
        openSheet();
      },
    };

    return (
      <button ref={ref} {...mergeProps}>
        {children}
      </button>
    );
  },
);

// ----------------------------------------------------------------------------
// SheetOverlay
// ----------------------------------------------------------------------------
type SheetOverlayProps = React.HTMLAttributes<HTMLDivElement>;

const SheetOverlay = ({ className, ...props }: SheetOverlayProps) => {
  const context = useContext(SheetContext);
  if (!context) throw new Error('SheetOverlay must be used within Sheet');

  const { isOpen } = context;

  return (
    <div
      className={cn(
        'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
        'fill-mode-both',
        className,
      )}
      data-state={isOpen ? 'open' : 'closed'}
      {...props}
    ></div>
  );
};
// ----------------------------------------------------------------------------
// SheetContent
// ----------------------------------------------------------------------------
interface SheetContentProps extends React.HTMLAttributes<HTMLDivElement> {
  side?: SheetSideType;
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
}

const POSITION_LIST = {
  top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
  bottom:
    'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
  left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
  right:
    'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
};

const SheetContent = ({
  className,
  children,
  side = DEFAULT_SIDE,
  onEscapeKeyDown,
  onPointerDownOutside,
  ...props
}: SheetContentProps) => {
  const context = useContext(SheetContext);
  if (!context) throw new Error('SheetContent must be used within Sheet');

  const { isOpen, closeSheet } = context;
  const [isVisible, setIsVisible] = useState(false);
  const sheetRef = useRef<HTMLDivElement>(null);

  const handleWheel = useCallback((e: WheelEvent) => {
    const isInsideDialog =
      e.target instanceof Node && sheetRef.current?.contains(e.target);

    if (!isInsideDialog) {
      e.preventDefault();
      return;
    }

    let target = e.target as HTMLElement;
    while (target && target !== sheetRef.current) {
      const { overflowY } = window.getComputedStyle(target);
      const isScrollable = overflowY === 'auto' || overflowY === 'scroll';
      const hasScrollableContent = target.scrollHeight > target.clientHeight;

      if (isScrollable && hasScrollableContent) {
        const scrollTop = target.scrollTop;
        const scrollHeight = target.scrollHeight;
        const clientHeight = target.clientHeight;

        if (scrollTop === 0 && e.deltaY < 0) {
          e.preventDefault();
        } else if (scrollTop + clientHeight >= scrollHeight && e.deltaY > 0) {
          e.preventDefault();
        }
        return;
      }
      target = target.parentElement as HTMLElement;
    }

    e.preventDefault();
  }, []);

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (!isOpen) return;

      if (e.key === 'Escape') {
        if (onEscapeKeyDown) {
          onEscapeKeyDown();
        } else {
          closeSheet();
        }
      }
    },
    [closeSheet, isOpen, onEscapeKeyDown],
  );

  useEffect(() => {
    if (isOpen) {
      setIsVisible(true);
      document.addEventListener('wheel', handleWheel, { passive: false });
      document.addEventListener('keydown', handleKeyDown);
    } else {
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    }
    return () => {
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown, handleWheel, isOpen]);

  const handlePointerDownOutside = () => {
    if (onPointerDownOutside) {
      onPointerDownOutside();
    } else {
      closeSheet();
    }
  };

  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit') {
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      props.onAnimationEnd?.(e);
      handleAnimationEnd(e);
    },
  };

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <SheetOverlay onClick={handlePointerDownOutside} />
          <div
            ref={sheetRef}
            className={cn(
              'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
              'fill-mode-both',
              POSITION_LIST[side],
              className,
            )}
            data-state={isOpen ? 'open' : 'closed'}
            {...mergeProps}
          >
            {children}
          </div>
        </>
      )}
    </>,
    document.body,
  );
};

export { Sheet, SheetContent, SheetOverlay, SheetTrigger };

------------------------------------------------------------
skeleton.tsx

import { cn } from '@/lib/utils';

const Skeleton = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => {
  return (
    <div
      className={cn('animate-pulse rounded-md bg-muted', className)}
      {...props}
    />
  );
};

export { Skeleton };

------------------------------------------------------------
textarea.tsx

import { cn } from '@/lib/utils';
import React from 'react';

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<'textarea'>
>(({ className, ...props }, ref) => {
  return (
    <textarea
      ref={ref}
      className={cn(
        'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    />
  );
});

export { Textarea };

------------------------------------------------------------
toast.tsx

import { cn } from '@/lib/utils';
import { XIcon } from 'lucide-react';
import { HTMLAttributes, useEffect, useState } from 'react';

interface ToastProps extends HTMLAttributes<HTMLDivElement> {
  title?: string;
  description?: string;
  duration?: number;
  variant?: 'default' | 'destructive';
  onRemove: () => void;
}

const Toast = ({
  className,
  title,
  description,
  duration = 3000,
  variant = 'default',
  onRemove,
  ...props
}: ToastProps) => {
  const VARIANT = {
    default: '',
    destructive:
      'bg-destructive text-destructive-foreground hover:bg-destructive/90',
  };

  const [isOpen, setIsOpen] = useState(false);
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    setIsOpen(true);
    setIsVisible(true);
  }, []);

  useEffect(() => {
    setTimeout(() => {
      handleClose();
    }, duration);
  }, [duration]);

  const handleClose = () => {
    setIsOpen(false);
  };

  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit') {
      onRemove();
    }
  };

  return (
    <>
      {isVisible && (
        <div
          className={cn(
            'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
            'border bg-accent text-accent-foreground fill-mode-both',
            VARIANT[variant],
            className,
          )}
          data-state={isOpen ? 'open' : 'closed'}
          {...props}
          onAnimationEnd={handleAnimationEnd}
        >
          <div className="grid gap-1">
            {title && <p className="text-sm font-semibold">{title}</p>}
            {description && <p className="text-sm opacity-90">{description}</p>}
            <button
              className={cn(
                'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none group-hover:opacity-100',
                'ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
              )}
              onClick={handleClose}
            >
              <XIcon className="size-4" />
            </button>
          </div>
        </div>
      )}
    </>
  );
};

export { Toast };

------------------------------------------------------------
tooltip.tsx

import { cn } from '@/lib/utils';
import React, {
  useCallback,
  useContext,
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
} from 'react';

type TooltipSideType = 'top' | 'right' | 'bottom' | 'left';
type TooltipAlignType = 'start' | 'center' | 'end';

const DEFAULT_SIDE: TooltipSideType = 'top';
const DEFAULT_ALIGN: TooltipAlignType = 'center';
const DEFAULT_SIDE_OFFSET = 8;

interface TooltipContextType {
  isOpen: boolean;
  openTooltip: () => void;
  closeTooltip: () => void;
  triggerRef: React.MutableRefObject<HTMLDivElement | null>;
}

const TooltipContext = React.createContext<TooltipContextType | undefined>(
  undefined,
);

// ----------------------------------------------------------------------------
// Tooltip
// ----------------------------------------------------------------------------
interface TooltipProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const Tooltip = ({ children, open, onOpenChange }: TooltipProps) => {
  // 外部からの状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openTooltip = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeTooltip = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  const triggerRef = useRef<HTMLDivElement | null>(null);

  return (
    <TooltipContext.Provider
      value={{ isOpen, openTooltip, closeTooltip, triggerRef }}
    >
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case TooltipTrigger:
            case TooltipContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </TooltipContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// TooltipTrigger
// ----------------------------------------------------------------------------
interface TooltipTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const TooltipTrigger = React.forwardRef<HTMLButtonElement, TooltipTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    const context = useContext(TooltipContext);
    if (!context) throw new Error('TooltipContent must be used within Tooltip');

    const { triggerRef, openTooltip, closeTooltip } = context;

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
      };
      return (
        <div
          ref={triggerRef}
          className="w-fit"
          onPointerEnter={openTooltip}
          onPointerLeave={closeTooltip}
          onPointerDown={closeTooltip}
        >
          {React.cloneElement(children, { ...mergeChildProps, ref })}
        </div>
      );
    }

    return (
      <div
        ref={triggerRef}
        className="w-fit"
        onPointerEnter={openTooltip}
        onPointerLeave={closeTooltip}
        onPointerDown={closeTooltip}
      >
        <button ref={ref} {...props}>
          {children}
        </button>
      </div>
    );
  },
);

// ----------------------------------------------------------------------------
// TooltipContent
// ----------------------------------------------------------------------------
interface TooltipContentProps extends React.HTMLAttributes<HTMLDivElement> {
  side?: TooltipSideType;
  align?: TooltipAlignType;
  sideOffset?: number;
}

const TooltipContent = React.forwardRef<HTMLDivElement, TooltipContentProps>(
  (
    {
      children,
      className,
      side = DEFAULT_SIDE,
      align = DEFAULT_ALIGN,
      sideOffset = DEFAULT_SIDE_OFFSET,
      ...props
    },
    ref,
  ) => {
    const context = useContext(TooltipContext);
    if (!context) throw new Error('TooltipContent must be used within Tooltip');

    const { isOpen, closeTooltip, triggerRef } = context;

    const [transformStyle, setTransformStyle] = useState('');

    const handleWheel = useCallback(
      (e: WheelEvent) => {
        e.preventDefault();
        closeTooltip();
      },
      [closeTooltip],
    );

    useEffect(() => {
      if (isOpen) {
        document.addEventListener('wheel', handleWheel, { passive: false });
      } else {
        document.removeEventListener('wheel', handleWheel);
      }
      return () => {
        document.removeEventListener('wheel', handleWheel);
      };
    }, [handleWheel, isOpen]);

    useLayoutEffect(() => {
      // triggerとなる要素からTooltipを表示する座標を計算する
      // （style属性に指定する文字列作成）
      if (triggerRef.current) {
        const { left, top, right, bottom, width, height } =
          triggerRef.current.getBoundingClientRect();

        const getOffset = (align: TooltipAlignType, size: number) => {
          switch (align) {
            case 'start':
              return `0% - ${size / 2}px`;
            case 'end':
              return `-100% + ${size / 2}px`;
            default:
              return '-50%';
          }
        };

        const offsetX = getOffset(align, width);
        const offsetY = getOffset(align, height);

        const positions = {
          top: {
            x: left + width / 2,
            y: top,
            offset: { x: offsetX, y: `-100% - ${sideOffset}px` },
          },
          bottom: {
            x: left + width / 2,
            y: bottom,
            offset: { x: offsetX, y: `0% + ${sideOffset}px` },
          },
          left: {
            x: left,
            y: top + height / 2,
            offset: { x: `-100% - ${sideOffset}px`, y: offsetY },
          },
          right: {
            x: right,
            y: top + height / 2,
            offset: { x: `0% + ${sideOffset}px`, y: offsetY },
          },
        };
        const pos = positions[side];

        setTransformStyle(
          `translate(calc(${pos.x}px + ${pos.offset.x}), calc(${pos.y}px + ${pos.offset.y}))`,
        );
      }
    }, [context, triggerRef, side, sideOffset, align]);

    return (
      <>
        {isOpen && (
          <div
            className="fixed left-0 top-0 z-50"
            style={{ transform: transformStyle }}
          >
            <div
              ref={ref}
              className={cn(
                'z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
                className,
              )}
              data-state={isOpen ? 'open' : 'closed'}
              data-side={side}
              {...props}
            >
              {children}
            </div>
          </div>
        )}
      </>
    );
  },
);

export { Tooltip, TooltipContent, TooltipTrigger };

------------------------------------------------------------
confirm-dialog.tsx

import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import {
  CONFIRM_DIALOG_EVENT,
  ConfirmDialogOptions,
} from '@/hooks/use-confirm-dialog';
import { cn } from '@/lib/utils';
import {
  AlertTriangleIcon,
  CheckCircle2Icon,
  HelpCircleIcon,
  InfoIcon,
} from 'lucide-react';
import { useEffect, useRef, useState } from 'react';

const ICON_COMPONENTS = {
  info: InfoIcon,
  question: HelpCircleIcon,
  warning: AlertTriangleIcon,
  check: CheckCircle2Icon,
};

const DEFAULT_OPTION_VALUE: ConfirmDialogOptions = {
  icon: 'info',
  title: '',
  message: '',
  actionLabel: 'OK',
  actionOnly: false,
  persistent: false,
  showInput: false,
  inputLabel: '',
  inputPlaceholder: '',
  inputRows: 1,
};

export default function ConfirmDialog() {
  const [isOpen, setIsOpen] = useState(false);
  const [options, setOptions] =
    useState<ConfirmDialogOptions>(DEFAULT_OPTION_VALUE);
  const [isPersistentAnimation, setIsPersistentAnimation] = useState(false);

  const refTextarea = useRef<HTMLTextAreaElement>(null);

  const IconComponent = ICON_COMPONENTS[options.icon];

  // hooksから呼ぶためにイベントリスナー登録
  useEffect(() => {
    const handleEvent = (event: CustomEvent<ConfirmDialogOptions>) => {
      setIsOpen(true);
      setOptions({ ...DEFAULT_OPTION_VALUE, ...event.detail });
    };
    document.addEventListener(
      CONFIRM_DIALOG_EVENT,
      handleEvent as EventListener,
    );
    return () => {
      document.removeEventListener(
        CONFIRM_DIALOG_EVENT,
        handleEvent as EventListener,
      );
    };
  }, []);

  const handleCloseDialog = () => {
    // アニメーションフラグ（閉じれないことを伝えるためにぶるっとする）
    if (options.persistent) {
      setIsPersistentAnimation(true);
      setTimeout(() => {
        setIsPersistentAnimation(false);
      }, 50);
      return;
    }
    handleClickCancel();
  };

  const handleClickAction = () => {
    setIsOpen(false);
    options.resolve?.({
      isAction: true,
      isCancel: false,
      text: refTextarea.current?.value || '',
    });
  };

  const handleClickCancel = () => {
    setIsOpen(false);
    options.resolve?.({
      isAction: false,
      isCancel: true,
      text: '',
    });
  };

  return (
    <Dialog open={isOpen}>
      <DialogContent
        className={cn(
          'w-[360px] sm:w-[400px] transition-transform ease-in-out [transition-duration:25ms]',
          isPersistentAnimation && 'scale-[1.02] transform',
        )}
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
      >
        <DialogHeader>
          <DialogTitle className="my-2 flex items-center">
            <IconComponent
              className={cn(
                'mr-3 min-w-fit',
                options.icon === 'warning' && 'text-destructive',
              )}
            />
            <p className="leading-6">{options.title}</p>
          </DialogTitle>
          {options.message && (
            <DialogDescription className="pt-2 text-left">
              {options.message}
            </DialogDescription>
          )}
        </DialogHeader>

        {options.showInput && (
          <div className="mb-4 grid w-full items-center gap-1.5">
            <p className="text-xs">{options.inputLabel}</p>
            <Textarea
              ref={refTextarea}
              className="min-h-4 resize-none"
              placeholder={options.inputPlaceholder}
              rows={options.inputRows}
            />
          </div>
        )}

        <DialogFooter className="flex justify-end gap-y-4 sm:gap-y-0">
          {!options.actionOnly && (
            <Button
              className="min-w-24 rounded-full"
              variant="ghost"
              onClick={handleClickCancel}
            >
              キャンセル
            </Button>
          )}
          <Button
            className="min-w-24 rounded-full"
            variant={options.icon === 'warning' ? 'destructive' : 'default'}
            onClick={handleClickAction}
          >
            {options.actionLabel}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
count-up-number.tsx

import { useCallback, useEffect, useState } from 'react';

type Props = {
  className?: string;
  start?: number;
  end: number;
  minInterval?: number; // 最小間隔
  maxInterval?: number; // 最大間隔
  normalInterval?: number; // 高速カウントアップ時の間隔
  delay?: number; // カウントアップ開始までの遅延時間（ミリ秒）
};

export default function CountUpNumber({
  className,
  start,
  end,
  minInterval = 20,
  maxInterval = 300,
  normalInterval = 20,
  delay = 0,
}: Props) {
  const initialStart = start ?? Math.max(0, end - 30);

  const [count, setCount] = useState(initialStart);
  const [isDelayComplete, setIsDelayComplete] = useState(delay === 0);
  const [countUpFinished, setCountUpFinished] = useState(false);

  // 遅延処理
  useEffect(() => {
    if (delay === 0) return;

    const delayTimeout = setTimeout(() => {
      setIsDelayComplete(true);
    }, delay);

    return () => clearTimeout(delayTimeout);
  }, [delay]);

  // イージング関数：最後の10カウント用
  const easeInOut = useCallback((progress: number): number => {
    return progress < 0.5
      ? 4 * progress ** 3 // 前半は加速 (ease-in)
      : 1 - Math.pow(-3 * progress + 3, 7) / 2; // 後半を非常に緩やかに減速
  }, []);

  useEffect(() => {
    // 遅延が完了していない場合は何もしない
    if (!isDelayComplete) return;
    if (count >= end) {
      setCountUpFinished(true);
      return; // カウント終了
    }

    const isFinalPhase = count >= end - 10; // 最後の10カウントかどうかを判定

    let currentInterval: number;

    if (isFinalPhase) {
      // 最後の10カウントの場合、イージングを適用
      const progress = (count - (end - 10)) / 10; // 進捗率 (0 ~ 1)
      const easedProgress = easeInOut(progress);
      currentInterval =
        minInterval + (maxInterval - minInterval) * easedProgress;
    } else {
      // 高速カウントアップ
      currentInterval = normalInterval;
    }

    const timeout = setTimeout(() => {
      setCount((prev) => prev + 1);

      // カウントアップアニメーションが完了したらフラグ変更
      if (count + 1 >= end) {
        setCountUpFinished(true);
      }
    }, currentInterval);

    return () => clearTimeout(timeout);
  }, [
    count,
    easeInOut,
    end,
    isDelayComplete,
    maxInterval,
    minInterval,
    normalInterval,
  ]);

  return <span className={className}>{countUpFinished ? end : count}</span>;
}

------------------------------------------------------------
pagination.tsx

import { Button } from '@/components/ui/button';
import { createPageNumbers } from '@/lib/pagination';
import { cn } from '@/lib/utils';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { HTMLAttributes } from 'react';

interface Props extends HTMLAttributes<HTMLDivElement> {
  total: number;
  page: number;
  onChangePage: (page: number) => void;
}

export default function Pagination({
  total,
  page,
  onChangePage,
  className,
  ...props
}: Props) {
  const pageNumbers = createPageNumbers(page, total);

  return (
    <div className={cn('flex', className)} {...props}>
      <Button
        className="size-8 rounded-full"
        variant="ghost"
        size="icon"
        aria-label="前のページへ"
        disabled={page <= 1}
        onClick={() => onChangePage(page - 1)}
      >
        <ChevronLeft className="size-5" />
      </Button>

      <ul className="flex">
        {pageNumbers.map((pageNumber, index) => (
          <li key={`${pageNumber}-${index}`}>
            {pageNumber === 0 ? (
              <div className="size-8 text-center">...</div>
            ) : (
              <Button
                className="size-8 rounded-full"
                variant={page === pageNumber ? 'secondary' : 'ghost'}
                size="icon"
                aria-label="ページ番号"
                onClick={() => {
                  if (page !== pageNumber) {
                    onChangePage(pageNumber);
                  }
                }}
              >
                {pageNumber}
              </Button>
            )}
          </li>
        ))}
      </ul>

      <Button
        className="size-8 rounded-full"
        variant="ghost"
        size="icon"
        aria-label="次のページへ"
        disabled={page >= total}
        onClick={() => onChangePage(page + 1)}
      >
        <ChevronRight className="size-5" />
      </Button>
    </div>
  );
}

------------------------------------------------------------
rating.tsx

import { cn } from '@/lib/utils';
import { StarHalfIcon, StarIcon } from 'lucide-react';
import { useEffect, useState } from 'react';

type Props = {
  rating: number;
  max?: number;
  readOnly?: boolean;
  onChange?: (rating: number) => void;
};

export default function Rating({
  rating,
  max = 5,
  readOnly = false,
  onChange,
}: Props) {
  // 現在の評価点と表示上の評価点は別で管理
  // 表示上の評価点はマウスでホバーしたときに変化する値として使用する
  const [currentRating, setCurrentRating] = useState(0);
  const [dispRating, setDispRating] = useState(0);

  useEffect(() => {
    const initRating = rating > max ? max : rating;
    setDispRating(initRating);
    setCurrentRating(initRating);
  }, [max, rating]);

  const handleMouseClick = (newDispRating: number) => {
    if (readOnly) return;

    setDispRating(newDispRating);
    setCurrentRating(newDispRating);
    if (onChange) {
      onChange(newDispRating);
    }
  };

  const handleMouseEnter = (newDispRating: number) => {
    if (readOnly) return;
    setDispRating(newDispRating);
  };

  const handleMouseLeave = () => {
    if (readOnly) return;
    setDispRating(currentRating);
  };

  return (
    <div className="flex h-10 items-center text-foreground">
      <div
        className={cn(
          'w-8',
          currentRating !== dispRating
            ? 'text-muted-foreground/50'
            : 'text-muted-foreground',
          !readOnly && 'cursor-pointer',
        )}
        onClick={() => handleMouseClick(0)}
        onMouseEnter={() => handleMouseEnter(0)}
        onMouseLeave={() => handleMouseLeave()}
      >
        {dispRating.toFixed(1)}
      </div>

      <div className="relative">
        <div className="flex">
          {[...Array<number>(max)].map((_, index) => (
            <StarIcon
              key={index}
              style={{ fill: 'hsl(var(--foreground) / 0.1)' }}
              strokeWidth={0}
            />
          ))}
        </div>

        <div className="absolute left-0 top-0 flex">
          {[...Array<number>(Math.floor(dispRating))].map((_, index) => (
            <StarIcon
              key={index}
              style={{ fill: 'hsl(var(--primary))' }}
              strokeWidth={0}
            />
          ))}
          {dispRating % 1 >= 0.5 && (
            <StarHalfIcon
              style={{ fill: 'hsl(var(--primary))' }}
              strokeWidth={0}
            />
          )}
        </div>

        <div className="absolute left-0 top-0 flex">
          {[...Array<number>(max)].map((_, index) => (
            <div className="flex" key={index}>
              <div
                className={cn(
                  'w-3 h-6 bg-transparent',
                  !readOnly && 'cursor-pointer',
                )}
                onClick={() => handleMouseClick(index + 1 - 0.5)}
                onMouseEnter={() => handleMouseEnter(index + 1 - 0.5)}
                onMouseLeave={() => handleMouseLeave()}
              />
              <div
                className={cn(
                  'w-3 h-6 bg-transparent',
                  !readOnly && 'cursor-pointer',
                )}
                onClick={() => handleMouseClick(index + 1)}
                onMouseEnter={() => handleMouseEnter(index + 1)}
                onMouseLeave={() => handleMouseLeave()}
              />
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
search-pagination.tsx

import Pagination from '@/components/pagination';
import { useSearchFilters } from '@/hooks/use-search-filters';

type Props = {
  totalPages: number;
};

export default function SearchPagination({ totalPages }: Props) {
  const { page, updateQueryParams } = useSearchFilters();

  const handleChange = (newPage: number) => {
    updateQueryParams({ page: newPage });
  };

  return (
    <div className="flex justify-center">
      {totalPages > 1 && (
        <Pagination
          total={totalPages}
          page={page}
          onChangePage={handleChange}
        />
      )}
    </div>
  );
}

------------------------------------------------------------
use-api-book.ts

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import {
  BookContentPage,
  BookDetails,
  BookPage,
  BookTableOfContents,
} from '@/types';

export const useApiBook = () => {
  const { fetcher, fetcherWithAuth } = useApi();

  const getBookDetailsById = async (bookId: string) => {
    try {
      const url = `/books/${bookId}`;
      const book = await fetcher<BookDetails>(url);
      return book;
    } catch (error) {
      throw new Error('書籍情報の読み込みが失敗しました。' + error);
    }
  };

  const getBookPageByQuery = async (query: string, page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/books/search?q=${query}&page=${basePage}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
      const bookPage = await fetcher<BookPage>(url);
      return bookPage;
    } catch (error) {
      throw new Error('書籍検索が失敗しました。' + error);
    }
  };

  const getBookPageByGenreId = async (
    genreIdsQuery: string,
    conditionQuery: string,
    page: number = 0,
  ) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/books/discover?genreIds=${genreIdsQuery}&condition=${conditionQuery}&page=${basePage}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
      const bookPage = await fetcher<BookPage>(url);
      return bookPage;
    } catch (error) {
      throw new Error('ジャンル検索が失敗しました。' + error);
    }
  };

  const getNewBooks = async () => {
    try {
      const url = `/books/new-books`;
      const bookPage = await fetcher<BookPage>(url);
      return bookPage;
    } catch (error) {
      throw new Error('ニューリリース一覧の読み込みが失敗しました。' + error);
    }
  };

  const getBookTableOfContents = async (bookId: string) => {
    try {
      const url = `/books/${bookId}/table-of-contents`;
      const bookTableOfContents = await fetcher<BookTableOfContents>(url);
      return bookTableOfContents;
    } catch (error) {
      throw new Error('書籍の目次の読み込みが失敗しました。' + error);
    }
  };

  const getBookContentPage = async (
    bookId: string,
    chapterNumber: number,
    pageNumber: number,
  ) => {
    try {
      const url = `/read/books/${bookId}/chapters/${chapterNumber}/pages/${pageNumber}`;
      const bookContentPage = await fetcherWithAuth<BookContentPage>(url);
      return bookContentPage;
    } catch (error) {
      throw new Error('書籍のページ情報の読み込みが失敗しました。' + error);
    }
  };

  return {
    getBookDetailsById,
    getBookPageByQuery,
    getBookPageByGenreId,
    getNewBooks,
    getBookTableOfContents,
    getBookContentPage,
  };
};

------------------------------------------------------------
use-api-favorite.ts

import { FETCH_FAVORITES_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { Favorite, FavoriteInfo, FavoritePage, FavoriteRequest } from '@/types';

export const useApiFavorite = () => {
  const { fetcher, fetcherWithAuth, mutationWithAuth } = useApi();

  const getFavoriteByBookId = async (bookId: string) => {
    try {
      const url = `/favorites/${bookId}`;
      const favorite = await fetcherWithAuth<Favorite>(url);
      return favorite;
    } catch (error) {
      throw new Error('お気に入りの読み込みが失敗しました。' + error);
    }
  };

  const getFavoritePage = async (page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/favorites?&page=${basePage}&maxResults=${FETCH_FAVORITES_MAX_RESULTS}`;
      const favoritePage = await fetcherWithAuth<FavoritePage>(url);
      return favoritePage;
    } catch (error) {
      throw new Error('お気に入り一覧の読み込みが失敗しました。' + error);
    }
  };

  const getFavoriteInfo = async (
    bookId: string,
    userId: number | undefined,
  ) => {
    try {
      const query = userId ? `?userId=${userId}` : '';
      const url = `/books/${bookId}/favorites/info${query}`;
      const favoriteInfo = await fetcher<FavoriteInfo>(url);
      return favoriteInfo;
    } catch (error) {
      throw new Error('お気に入り情報の読み込みが失敗しました。' + error);
    }
  };

  const createFavorite = async (requestBody: FavoriteRequest) => {
    try {
      const url = `/favorites`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('お気に入りの作成に失敗しました。' + error);
    }
  };

  const deleteFavorite = async (bookId: string) => {
    try {
      const url = `/favorites/${bookId}`;
      const options: RequestInit = { method: 'DELETE' };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('お気に入りの削除に失敗しました。' + error);
    }
  };

  return {
    getFavoriteByBookId,
    getFavoritePage,
    getFavoriteInfo,
    createFavorite,
    deleteFavorite,
  };
};

------------------------------------------------------------
use-api-review.ts

import {
  FETCH_MY_REVIEWS_MAX_RESULTS,
  FETCH_REVIEWS_MAX_RESULTS,
} from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import {
  ReviewPage,
  ReviewRequest,
  ReviewSummary,
  SelfReviewExists,
} from '@/types';

export const useApiReview = () => {
  const { fetcher, fetcherWithAuth, mutationWithAuth } = useApi();

  const getReviewPage = async (bookId: string, page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/books/${bookId}/reviews?&page=${basePage}&maxResults=${FETCH_REVIEWS_MAX_RESULTS}`;
      const reviewPage = await fetcher<ReviewPage>(url);
      return reviewPage;
    } catch (error) {
      throw new Error('レビュー一覧の読み込みが失敗しました。' + error);
    }
  };

  const getReviewSummary = async (bookId: string) => {
    try {
      const url = `/books/${bookId}/reviews/summary`;
      const reviewSummary = await fetcher<ReviewSummary>(url);
      return reviewSummary;
    } catch (error) {
      throw new Error('レビュー情報の読み込みが失敗しました。' + error);
    }
  };

  const checkSelfReviewExists = async (bookId: string) => {
    try {
      const url = `/reviews/self-review-exists/${bookId}`;
      const data = await fetcherWithAuth<SelfReviewExists>(url);
      return data.exists;
    } catch (error) {
      throw new Error('レビューの存在チェックに失敗しました。' + error);
    }
  };

  const getReviewPageByUser = async (page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/reviews?&page=${basePage}&maxResults=${FETCH_MY_REVIEWS_MAX_RESULTS}`;
      const reviewPage = await fetcherWithAuth<ReviewPage>(url);
      return reviewPage;
    } catch (error) {
      throw new Error('マイレビュー一覧の読み込みが失敗しました。' + error);
    }
  };

  const createReview = async (requestBody: ReviewRequest) => {
    try {
      const url = `/reviews`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('レビューの作成に失敗しました。' + error);
    }
  };

  const updateReview = async (id: number, requestBody: ReviewRequest) => {
    try {
      const url = `/reviews/${id}`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('レビューの更新に失敗しました。' + error);
    }
  };

  const deleteReview = async (id: number) => {
    try {
      const url = `/reviews/${id}`;
      const options: RequestInit = {
        method: 'DELETE',
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('レビューの削除に失敗しました。' + error);
    }
  };

  return {
    getReviewPage,
    getReviewSummary,
    checkSelfReviewExists,
    getReviewPageByUser,
    createReview,
    updateReview,
    deleteReview,
  };
};

------------------------------------------------------------
use-api-user.ts

import { useApi } from '@/hooks/api/use-api';
import {
  ChangeEmail,
  ChangePassword,
  ProfileCounts,
  UpdateCurrentUser,
  User,
} from '@/types';

export const useApiUser = () => {
  const { fetcherWithAuth, mutationWithAuth } = useApi();

  const getCurrentUser = async () => {
    try {
      const url = `/me`;
      const user = await fetcherWithAuth<User>(url);
      return user;
    } catch (error) {
      throw new Error('ユーザー情報の読み込みが失敗しました。' + error);
    }
  };

  const getProfileCounts = async () => {
    try {
      const url = `/me/profile-counts`;
      const profieleCounts = await fetcherWithAuth<ProfileCounts>(url);
      return profieleCounts;
    } catch (error) {
      throw new Error(
        'ユーザーのプロフィール情報の読み込みが失敗しました。' + error,
      );
    }
  };

  const updateCurrentUser = async (requestBody: UpdateCurrentUser) => {
    try {
      const url = `/me`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('ユーザー情報の更新に失敗しました。' + error);
    }
  };

  const changePassword = async (requestBody: ChangePassword) => {
    try {
      const url = `/me/password`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('パスワードの更新に失敗しました。' + error);
    }
  };

  const changeEmail = async (requestBody: ChangeEmail) => {
    try {
      const url = `/me/email`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('メールアドレスの更新に失敗しました。' + error);
    }
  };

  return {
    getCurrentUser,
    getProfileCounts,
    updateCurrentUser,
    changePassword,
    changeEmail,
  };
};

------------------------------------------------------------
use-api.ts

import { BOOKS_API_ENDPOINT } from '@/constants/constants';
import { useAuth } from '@/providers/auth-provider';
import { ErrorResponse } from '@/types';

export const useApi = () => {
  const { accessToken, refreshAccessToken } = useAuth();

  const fetcher = async <T>(url: string, options: RequestInit = {}) => {
    const response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, options);
    if (!response.ok) {
      throw new Error(await generateErrorMessage(url, response));
    }
    return response.json() as Promise<T>;
  };

  const fetcherWithAuth = async <T>(url: string, options: RequestInit = {}) => {
    let response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${accessToken}`,
      },
    });

    if (response.status === 401) {
      const newAccessToken = await refreshAccessToken();
      response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
        ...options,
        headers: {
          ...options.headers,
          Authorization: `Bearer ${newAccessToken}`,
        },
      });
    }

    if (!response.ok) {
      throw new Error(await generateErrorMessage(url, response));
    }

    return response.json() as Promise<T>;
  };

  const mutationWithAuth = async (url: string, options: RequestInit = {}) => {
    let response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${accessToken}`,
      },
    });

    if (response.status === 401) {
      const newAccessToken = await refreshAccessToken();
      response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
        ...options,
        headers: {
          ...options.headers,
          Authorization: `Bearer ${newAccessToken}`,
        },
      });
    }

    if (!response.ok) {
      throw new Error(await generateErrorMessage(url, response));
    }
  };

  const generateErrorMessage = async (url: string, response: Response) => {
    let errorMessage = `[URL] ${url}`;
    try {
      const errorResponse = (await response.json()) as ErrorResponse;
      errorMessage += ` [MESSAGE] ${errorResponse.message} [STATUS] ${response.status}(${errorResponse.status})`;
    } catch {
      // JSON でない場合は無視
    }
    return errorMessage;
  };

  return { fetcher, fetcherWithAuth, mutationWithAuth };
};

------------------------------------------------------------
use-confirm-dialog.ts

type IconType = 'info' | 'question' | 'warning' | 'check';

// 確認ダイアログの引数
export type ConfirmDialogOptions = {
  icon: IconType; // アイコンの種類（「i」「?」「!」「✓」）
  title: string; // タイトル
  message?: string; // メッセージ
  actionLabel?: string; // アクションボタンの文字（デフォルト「OK」）
  actionOnly?: boolean; // 「キャンセル」ボタンをなくす
  persistent?: boolean; // 永続化するか（要素外クリック、ESCキーでも閉じないようにするか）
  showInput?: boolean; // 入力欄を表示するか
  inputLabel?: string; // 入力欄のラベル
  inputPlaceholder?: string; // 入力欄のプレースホルダー
  inputRows?: number; // 入力欄の行数
  resolve?: (value: ConfirmDialogResult) => void;
};

// 確認ダイアログの戻り値
export type ConfirmDialogResult = {
  isAction: boolean;
  isCancel: boolean;
  text: string;
};

export const CONFIRM_DIALOG_EVENT = 'CONFIRM_DIALOG_EVENT';

export const useConfirmDialog = () => {
  const confirmDialog = (
    options: ConfirmDialogOptions,
  ): Promise<ConfirmDialogResult> => {
    return new Promise((resolve) => {
      const event = new CustomEvent(CONFIRM_DIALOG_EVENT, {
        detail: { ...options, resolve },
      });
      document.dispatchEvent(event);
    });
  };
  return { confirmDialog };
};

------------------------------------------------------------
book-read-content.ts

import { BookTableOfContents } from '@/types';

// 「現在のページ/総ページ数」を表す文字列を返す
export const getCurrentPageText = (
  bookTableOfContents: BookTableOfContents,
  chapterNumber: number,
  pageNumber: number,
) => {
  // 章番号が見つからなかった場合でも chapterIndex は少なくとも1にする
  const chapterIndex = Math.max(
    1,
    bookTableOfContents.chapters.findIndex(
      (chapter) => chapter.chapterNumber === chapterNumber,
    ),
  );

  const totalPage =
    bookTableOfContents.chapters[chapterIndex]?.pageNumbers.length ?? 1;
  return `${pageNumber}/${totalPage}`;
};

// 現在のページが最初か最後かを判定する
export const getPagePosition = (
  bookTableOfContents: BookTableOfContents,
  chapterNumber: number,
  pageNumber: number,
) => {
  const isFirstPage = chapterNumber === 1 && pageNumber === 1;
  const isLastPage =
    chapterNumber === bookTableOfContents.chapters.length &&
    pageNumber ===
      bookTableOfContents.chapters.find(
        (chapter) => chapter.chapterNumber === chapterNumber,
      )?.pageNumbers.length;

  return { isFirstPage, isLastPage };
};

// 指定方向（次 or 前）のページのリンク先を返す
export const getPageLink = (
  bookTableOfContents: BookTableOfContents,
  chapterNumber: number,
  pageNumber: number,
  direction: 'next' | 'prev',
) => {
  const chapterIndex = bookTableOfContents.chapters.findIndex(
    (chapter) => chapter.chapterNumber === chapterNumber,
  );

  if (chapterIndex === -1) {
    return `/read/${bookTableOfContents.bookId}/chapter/${chapterNumber}/page/${pageNumber}`;
  }

  const totalPages =
    bookTableOfContents.chapters[chapterIndex]?.pageNumbers.length ?? 1;
  const isMovingForward = direction === 'next';

  const isLastPage = pageNumber >= totalPages;
  const isFirstPage = pageNumber <= 1;
  const isLastChapter = chapterIndex >= bookTableOfContents.chapters.length - 1;
  const isFirstChapter = chapterIndex <= 0;

  let newChapterNumber = chapterNumber;
  let newPageNumber = pageNumber;

  if (isMovingForward) {
    if (isLastPage) {
      // 最終章の最後のページなら、それ以上進めない
      if (isLastChapter) {
        newPageNumber = totalPages; // 現在の最後のページのまま
      } else {
        // 次のチャプターの最初のページへ
        newChapterNumber = chapterNumber + 1;
        newPageNumber = 1;
      }
    } else {
      newPageNumber = pageNumber + 1;
    }
  } else {
    if (isFirstPage) {
      // 最初の章の最初のページなら、それ以上戻れない
      if (isFirstChapter) {
        newPageNumber = 1; // 現在の最初のページのまま
      } else {
        // 前のチャプターの最後のページへ
        newChapterNumber = chapterNumber - 1;
        newPageNumber =
          bookTableOfContents.chapters[chapterIndex - 1].pageNumbers.length;
      }
    } else {
      newPageNumber = pageNumber - 1;
    }
  }

  return `/read/${bookTableOfContents.bookId}/chapter/${newChapterNumber}/page/${newPageNumber}`;
};

------------------------------------------------------------
utils.ts

import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

/**
 * sleep関数
 * @param msec ミリ秒
 *
 * await sleep(3000);  // ３秒待つ
 */
export const sleep = (msec: number) =>
  new Promise((resolve) => setTimeout(resolve, msec));

/**
 * yyyy-MM-ddTHH:mm:ss形式の文字列を変換
 * @param dateString
 * @returns yyyy年M月d日の文字列
 */
export const formatDateJP = (dateString: string) => {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat('ja-JP', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  }).format(date);
};

/**
 * yyyy-MM-ddTHH:mm:ss形式の文字列を変換
 * @param dateString
 * @returns yyyy/MM/dd日の文字列
 */
export const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat('ja-JP', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
  })
    .format(date)
    .replace(/\./g, '/'); // '.'区切りを '/' に変換
};

/**
 * yyyy-MM-ddTHH:mm:ss形式の文字列を変換
 * @param dateString
 * @returns HH:mmの文字列
 */
export const formatTime = (dateString: string) => {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat('ja-JP', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
  }).format(date);
};

/**
 * 価格をカンマ区切り数字文字列へ変換
 * @param price 価格
 * @returns カンマ区切り数字文字列
 */
export const formatPrice = (price: number) => {
  return price === 0 ? '-' : `${Number(price).toLocaleString()}円`;
};

/**
 * ISBNの文字列をハイフンを含めたISBN文字列へ変換
 * @param isbn isbn文字列
 * @returns ハイフンを含めたISBN文字列
 */
export const formatIsbn = (isbnString: string) => {
  const country = isbnString.slice(0, 3);
  const area = isbnString.slice(3, 4);
  const publisher = isbnString.slice(4, 7);
  const book = isbnString.slice(7, 12);
  const check = isbnString.slice(12, 13);

  return country + '-' + area + '-' + publisher + '-' + book + '-' + check;
};

------------------------------------------------------------
providers/auth-provider.tsx

import { BOOKS_API_ENDPOINT } from '@/constants/constants';
import {
  AccessToken,
  ErrorResponse,
  LoginRequest,
  SignupRequest,
  User,
} from '@/types';
import { createContext, useContext, useEffect, useState } from 'react';

type AuthProviderProps = {
  children: React.ReactNode;
};

type AuthProviderState = {
  accessToken: string | null;
  isLoading: boolean;
  user: User | null;
  setUser: (user: User | null) => void;
  login: (requestBody: LoginRequest) => Promise<void>;
  signup: (requestBody: SignupRequest) => Promise<void>;
  logout: () => Promise<void>;
  refreshAccessToken: () => Promise<string | null>;
};

const AuthProviderContext = createContext<AuthProviderState | undefined>(
  undefined,
);

export function AuthProvider({ children }: AuthProviderProps) {
  const [accessToken, setAccessToken] = useState<string | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const login = async (requestBody: LoginRequest) => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/login`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        const data = (await response.json()) as ErrorResponse;
        throw new Error(
          `[STATUS] ${response.status} [MESSAGE] ${data.message} [URL] ${url}`,
        );
      }

      const data = (await response.json()) as AccessToken;
      setAccessToken(data.accessToken);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      throw new Error('ログインできませんでした。' + error);
    }
  };

  const signup = async (requestBody: SignupRequest) => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/signup`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        const data = (await response.json()) as ErrorResponse;
        throw new Error(
          `[STATUS] ${response.status} [MESSAGE] ${data.message} [URL] ${url}`,
        );
      }

      const data = (await response.json()) as AccessToken;
      setAccessToken(data.accessToken);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      throw new Error('サインアップできませんでした。' + error);
    }
  };

  const logout = async () => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/logout`;
      const options: RequestInit = {
        method: 'POST',
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        const data = (await response.json()) as ErrorResponse;
        throw new Error(
          `[STATUS] ${response.status} [MESSAGE] ${data.message} [URL] ${url}`,
        );
      }

      setAccessToken(null);
      setUser(null);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      throw new Error('ログアウトに失敗しました。' + error);
    }
  };

  const refreshAccessToken = async () => {
    const accessToken = await fetchAccessToken();
    setAccessToken(accessToken);
    if (!accessToken) {
      alert('セッションが切れたため、自動ログアウトしました。');
      setUser(null);
    }
    return accessToken;
  };

  const fetchAccessToken = async () => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/refresh-token`;
      const options: RequestInit = {
        method: 'POST',
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        throw new Error('Failed to refresh token');
      }

      const data = (await response.json()) as AccessToken;
      return data.accessToken;
    } catch {
      return null;
    }
  };

  useEffect(() => {
    // リロードするとメモリからアクセストークンが消えてしまうので
    // 初期読み込み時にリフレッシュトークンを使って再取得する
    const init = async () => {
      const accessToken = await fetchAccessToken();
      setAccessToken(accessToken);
      setIsLoading(false);
    };
    init();
  }, []);

  const value = {
    accessToken,
    isLoading,
    user,
    setUser,
    login,
    signup,
    logout,
    refreshAccessToken,
  };

  return (
    <AuthProviderContext.Provider value={value}>
      {children}
    </AuthProviderContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthProviderContext);

  if (context === undefined)
    throw new Error('useAuth must be used within an AuthProvider');

  return context;
};

------------------------------------------------------------
theme-provider.tsx

import { createContext, useContext, useEffect, useState } from 'react';

type Theme = 'dark' | 'light' | 'system';

type ThemeProviderProps = {
  children: React.ReactNode;
  defaultTheme?: Theme;
  storageKey?: string;
};

type ThemeProviderState = {
  theme: Theme;
  setTheme: (theme: Theme) => void;
};

const initialState: ThemeProviderState = {
  theme: 'system',
  setTheme: () => null,
};

const ThemeProviderContext = createContext<ThemeProviderState>(initialState);

export function ThemeProvider({
  children,
  defaultTheme = 'system',
  storageKey = 'vite-ui-theme',
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme,
  );

  useEffect(() => {
    const root = window.document.documentElement;

    root.classList.remove('light', 'dark');

    if (theme === 'system') {
      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)')
        .matches
        ? 'dark'
        : 'light';

      root.classList.add(systemTheme);
      return;
    }

    root.classList.add(theme);
  }, [theme]);

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme);
      setTheme(theme);
    },
  };

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  );
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext);

  if (context === undefined)
    throw new Error('useTheme must be used within a ThemeProvider');

  return context;
};

------------------------------------------------------------
discover

import BooksDiscover from '@/components/books/books-discover';
import BooksSkeleton from '@/components/books/books-skeleton';
import GenresConditionSelector from '@/components/genres/genres-condition-selector';
import GenresSelector from '@/components/genres/genres-selector';
import GenresSkeleton from '@/components/genres/genres-skeleton';
import { Separator } from '@/components/ui/separator';
import { usePageTitle } from '@/hooks/use-page-title';
import { useSearchFilters } from '@/hooks/use-search-filters';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';

type Props = {
  title: string;
};

export default function Page({ title }: Props) {
  usePageTitle(title);

  const { genreIds, condition, page } = useSearchFilters();

  return (
    <>
      <div className="m-4 flex h-10 items-center justify-between">
        <h1 className="font-bold">ジャンル</h1>
        <GenresConditionSelector />
      </div>

      <Separator className="my-4 bg-foreground/10" />

      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={<GenresSkeleton />}>
          <GenresSelector />
        </Suspense>
      </ErrorBoundary>

      <Separator className="my-4 bg-foreground/10" />

      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={<BooksSkeleton />}>
          <BooksDiscover
            genreIds={genreIds}
            condition={condition}
            page={page}
          />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}

------------------------------------------------------------
login

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/profile/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { usePageTitle } from '@/hooks/use-page-title';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/providers/auth-provider';
import { LoginRequest } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';

type Props = {
  title: string;
};

export default function Page({ title }: Props) {
  usePageTitle(title);

  const location = useLocation();
  const navigate = useNavigate();
  const { login, setUser } = useAuth();
  const { getCurrentUser } = useApiUser();
  const { toast } = useToast();

  const loginMutation = useMutation({
    mutationFn: (requestBody: LoginRequest) => login(requestBody),
    onSuccess: async () => {
      const user = await getCurrentUser();
      setUser(user);
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;

    const requestBody: LoginRequest = { email, password };
    loginMutation.mutate(requestBody, {
      onSuccess: () => {
        const pathname = location.state?.from?.pathname || '/';
        const query = location.state?.from?.search || '';
        navigate(pathname + query, { replace: true });
      },
      onError: () => {
        toast({
          title: 'ログインできませんでした',
          description: 'メールアドレスまたはパスワードが違います。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">ログイン</h1>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form
            className="flex w-full flex-col gap-y-4"
            onSubmit={handleSubmit}
          >
            <div>
              <Label className="text-xs" htmlFor="email">
                メールアドレス
              </Label>
              <Input
                className="my-2 rounded-full"
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
              />
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                パスワード
              </Label>
              <PasswordInput
                className="my-2 rounded-full"
                id="password"
                name="password"
              />
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={loginMutation.isPending}
            >
              {loginMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                'ログイン'
              )}
            </Button>
          </form>

          <div className="mt-6 flex justify-center gap-x-1 text-xs">
            <p className="text-muted-foreground">
              アカウントをお持ちでない方はこちら
            </p>
            <Link to={'/signup'} className="text-primary hover:underline">
              新規登録
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
change-email

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/profile/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { usePageTitle } from '@/hooks/use-page-title';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/utils';
import { useAuth } from '@/providers/auth-provider';
import { ChangeEmail } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React, { useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

type Props = {
  title: string;
};

export default function Page({ title }: Props) {
  usePageTitle(title);

  const [emailErrorMessage, setEmailErrorMessage] = useState('');
  const [passwordErrorMessage, setPasswordErrorMessage] = useState('');

  const emailRef = useRef<HTMLInputElement | null>(null);
  const passwordRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { changeEmail } = useApiUser();
  const { toast } = useToast();

  const { user, logout } = useAuth();
  const { confirmDialog } = useConfirmDialog();

  const updateMutation = useMutation({
    mutationFn: (requestBody: ChangeEmail) => changeEmail(requestBody),
    onSuccess: async () => {
      await logout();
      navigate('/login');
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;

    const isEmailValid = validateEmail();
    const isPasswordValid = validatePassword();

    if (!isEmailValid || !isPasswordValid) {
      return;
    }

    const { isCancel } = await confirmDialog({
      icon: 'question',
      title: '本当に変更しますか？',
      message: 'メールアドレス変更後、一度ログアウトします。',
    });
    if (isCancel) return;

    const requestBody: ChangeEmail = { email, password };
    updateMutation.mutate(requestBody, {
      onSuccess: async () => {
        toast({
          title: 'メールアドレスを変更し、ログアウトしました',
          duration: 5000,
        });
      },
      onError: () => {
        toast({
          title: 'メールアドレスを変更できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateEmail = () => {
    const email = emailRef.current?.value as string;
    setEmailErrorMessage('');

    if (email === '') {
      setEmailErrorMessage('メールアドレスは必須です。');
      return false;
    }

    const emailRegex = /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(email)) {
      setEmailErrorMessage('無効なメールアドレスです。');
      return false;
    }

    return true;
  };

  const validatePassword = () => {
    const password = passwordRef.current?.value as string;
    setPasswordErrorMessage('');

    if (password === '') {
      setPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    return true;
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">メールアドレス変更</h1>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form
            className="flex w-full flex-col gap-y-4"
            onSubmit={handleSubmit}
          >
            <div>
              <Label className="text-xs" htmlFor="name">
                現在のメールアドレス
              </Label>
              <p className="my-2 rounded-full border border-transparent px-3 py-2 text-sm">
                {user?.email}
              </p>
            </div>

            <div>
              <Label className="text-xs" htmlFor="name">
                新しいメールアドレス
              </Label>
              <Input
                ref={emailRef}
                className={cn(
                  'my-2 rounded-full',
                  emailErrorMessage && 'border-destructive',
                )}
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
              />
              {emailErrorMessage && (
                <p className="text-xs text-destructive">{emailErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                現在のパスワード
              </Label>
              <PasswordInput
                ref={passwordRef}
                className={cn(
                  'my-2 rounded-full',
                  passwordErrorMessage && 'border-destructive',
                )}
                id="password"
                name="password"
              />
              {passwordErrorMessage && (
                <p className="text-xs text-destructive">
                  {passwordErrorMessage}
                </p>
              )}
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={updateMutation.isPending}
            >
              {updateMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '変更'
              )}
            </Button>

            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
change-password

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/profile/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { usePageTitle } from '@/hooks/use-page-title';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/utils';
import { ChangePassword } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React, { useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

type Props = {
  title: string;
};

export default function Page({ title }: Props) {
  usePageTitle(title);

  const [currentPasswordErrorMessage, setCurrentPasswordErrorMessage] =
    useState('');
  const [newPasswordErrorMessage, setNewPasswordErrorMessage] = useState('');
  const [confirmPasswordErrorMessage, setConfirmPasswordErrorMessage] =
    useState('');

  const currentPasswordRef = useRef<HTMLInputElement | null>(null);
  const newPasswordRef = useRef<HTMLInputElement | null>(null);
  const confirmPasswordRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { changePassword } = useApiUser();
  const { toast } = useToast();

  const { confirmDialog } = useConfirmDialog();

  const updateMutation = useMutation({
    mutationFn: (requestBody: ChangePassword) => changePassword(requestBody),
    onSuccess: () => {
      navigate('/profile');
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const currentPassword = form.get('current-password') as string;
    const newPassword = form.get('new-password') as string;
    const confirmPassword = form.get('confirm-password') as string;

    const isCurrentPasswrdValid = validateCurrentPassword();
    const isNewPasswrdValid = validateNewPassword();
    const isConfirmPasswrdValid = validateConfirmPassword();

    if (
      !isCurrentPasswrdValid ||
      !isNewPasswrdValid ||
      !isConfirmPasswrdValid
    ) {
      return;
    }

    const { isCancel } = await confirmDialog({
      icon: 'question',
      title: '本当に変更しますか？',
      message: 'パスワードを変更します。',
    });
    if (isCancel) return;

    const requestBody: ChangePassword = {
      currentPassword,
      newPassword,
      confirmPassword,
    };
    updateMutation.mutate(requestBody, {
      onSuccess: () => {
        toast({ title: 'パスワードを変更しました' });
      },
      onError: () => {
        toast({
          title: 'パスワードを変更できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateCurrentPassword = () => {
    setCurrentPasswordErrorMessage('');
    const password = currentPasswordRef.current?.value as string;

    if (password === '') {
      setCurrentPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    return true;
  };

  const validateNewPassword = () => {
    setNewPasswordErrorMessage('');
    const password = newPasswordRef.current?.value as string;

    if (password === '') {
      setNewPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    if (password.length < 4) {
      setNewPasswordErrorMessage('パスワードは4文字以上で設定してください。');
      return false;
    }

    return true;
  };

  const validateConfirmPassword = () => {
    setConfirmPasswordErrorMessage('');
    const newPassword = newPasswordRef.current?.value as string;
    const confirmPassword = confirmPasswordRef.current?.value as string;

    if (newPassword !== confirmPassword) {
      setConfirmPasswordErrorMessage(
        '新しいパスワードと確認用パスワードが一致していません。',
      );
      return false;
    }

    return true;
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">パスワード変更</h1>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form
            className="flex w-full flex-col gap-y-4"
            onSubmit={handleSubmit}
          >
            <div>
              <Label className="text-xs" htmlFor="current-password">
                現在のパスワード
              </Label>
              <PasswordInput
                ref={currentPasswordRef}
                className={cn(
                  'my-2 rounded-full',
                  currentPasswordErrorMessage && 'border-destructive',
                )}
                id="current-password"
                name="current-password"
              />
              {currentPasswordErrorMessage && (
                <p className="text-xs text-destructive">
                  {currentPasswordErrorMessage}
                </p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="new-password">
                新しいパスワード
              </Label>
              <PasswordInput
                ref={newPasswordRef}
                className={cn(
                  'my-2 rounded-full',
                  newPasswordErrorMessage && 'border-destructive',
                )}
                id="new-password"
                name="new-password"
              />
              {newPasswordErrorMessage && (
                <p className="text-xs text-destructive">
                  {newPasswordErrorMessage}
                </p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="confirm-password">
                新しいパスワード（確認用）
              </Label>
              <PasswordInput
                ref={confirmPasswordRef}
                className={cn(
                  'my-2 rounded-full',
                  confirmPasswordErrorMessage && 'border-destructive',
                )}
                id="confirm-password"
                name="confirm-password"
              />
              {confirmPasswordErrorMessage && (
                <p className="text-xs text-destructive">
                  {confirmPasswordErrorMessage}
                </p>
              )}
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={updateMutation.isPending}
            >
              {updateMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '変更'
              )}
            </Button>

            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
change-user-info

import Logo from '@/components/layout/logo';
import AvatarCarousel from '@/components/profile/avatar-carousel';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { usePageTitle } from '@/hooks/use-page-title';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/utils';
import { useAuth } from '@/providers/auth-provider';
import { UpdateCurrentUser } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

type Props = {
  title: string;
};

export default function Page({ title }: Props) {
  usePageTitle(title);

  const [nameErrorMessage, setNameErrorMessage] = useState('');

  const nameRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { updateCurrentUser } = useApiUser();
  const { toast } = useToast();

  const { user, setUser } = useAuth();

  const [avatarPath, setAvatarPath] = useState(user?.avatarPath || '');

  const updateMutation = useMutation({
    mutationFn: (requestBody: UpdateCurrentUser) =>
      updateCurrentUser(requestBody),
    onSuccess: () => {
      navigate('/profile');
    },
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    if (nameRef.current && user) {
      nameRef.current.value = user.name || '';
    }
  }, [user]);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const name = form.get('name') as string;

    const isNameValid = validateName();

    if (!isNameValid) {
      return;
    }

    const requestBody: UpdateCurrentUser = { name, avatarPath };
    updateMutation.mutate(requestBody, {
      onSuccess: () => {
        // 名前とアバターURLだけなので楽観的に更新しておく
        const newUser = user ? { ...user, name, avatarPath } : null;
        setUser(newUser);
        toast({ title: 'ユーザー情報を変更しました' });
      },
      onError: () => {
        toast({
          title: 'ユーザー情報を変更できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateName = () => {
    const name = nameRef.current?.value as string;
    setNameErrorMessage('');

    if (name === '') {
      setNameErrorMessage('ユーザー名は必須です。');
      return false;
    }

    return true;
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">ユーザー情報変更</h1>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form
            className="flex w-full flex-col gap-y-4"
            onSubmit={handleSubmit}
          >
            <div>
              <Label className="text-xs" htmlFor="name">
                ユーザー名
              </Label>
              <Input
                ref={nameRef}
                className={cn(
                  'my-2 rounded-full',
                  nameErrorMessage && 'border-destructive',
                )}
                id="name"
                name="name"
                autoComplete="off"
                spellCheck="false"
              />
              {nameErrorMessage && (
                <p className="text-xs text-destructive">{nameErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="name">
                アバター画像
              </Label>
              <AvatarCarousel value={avatarPath} onChange={setAvatarPath} />
            </div>

            <Button
              className="w-full rounded-full"
              type="submit"
              disabled={updateMutation.isPending}
            >
              {updateMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '変更'
              )}
            </Button>

            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
profile/page.tsx

import Logo from '@/components/layout/logo';
import ProfileCounts from '@/components/profile/profile-counts';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { AVATAR_IMAGE_BASE_URL } from '@/constants/constants';
import { usePageTitle } from '@/hooks/use-page-title';
import { useAuth } from '@/providers/auth-provider';
import ErrorElement from '@/routes/error-element';
import { KeyRoundIcon, MailIcon, UserRoundPenIcon } from 'lucide-react';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { Link } from 'react-router-dom';

type Props = {
  title: string;
};

export default function Page({ title }: Props) {
  usePageTitle(title);

  const { user } = useAuth();

  if (!user) return null;

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">プロフィール</h1>

      <Card className="w-80 overflow-hidden rounded-3xl sm:w-96">
        <CardHeader className="h-80 w-full bg-gradient-to-tr from-secondary to-primary px-2 sm:px-6">
          <div className="flex flex-col items-center pt-8">
            <Avatar className="mb-4 size-24">
              <AvatarImage
                className="bg-primary"
                src={AVATAR_IMAGE_BASE_URL + user.avatarPath}
                alt="avatar-image"
              />
              <AvatarFallback className="bg-primary text-5xl font-semibold">
                {user.name.slice(0, 1)}
              </AvatarFallback>
            </Avatar>
            <p className="text-xl font-semibold">{user.name}</p>
            <p className="text-sm">{user.email}</p>
          </div>

          <ErrorBoundary fallback={<ErrorElement />}>
            <Suspense fallback={null}>
              <ProfileCounts />
            </Suspense>
          </ErrorBoundary>
        </CardHeader>

        <CardContent className="relative p-6">
          <ul>
            <li className="flex items-center p-2">
              <UserRoundPenIcon className="mr-4" />
              <p>ユーザー情報</p>
              <div className="flex-1"></div>
              <Button
                className="rounded-full bg-transparent"
                variant="outline"
                asChild
              >
                <Link to="/profile/change-user-info">変更</Link>
              </Button>
            </li>
            <li className="flex items-center p-2">
              <MailIcon className="mr-4" />
              <p>メールアドレス</p>
              <div className="flex-1"></div>
              <Button
                className="rounded-full bg-transparent"
                variant="outline"
                asChild
              >
                <Link to="/profile/change-email">変更</Link>
              </Button>
            </li>
            <li className="flex items-center p-2">
              <KeyRoundIcon className="mr-4" />
              <p>パスワード</p>
              <div className="flex-1"></div>
              <Button
                className="rounded-full bg-transparent"
                variant="outline"
                asChild
              >
                <Link to="/profile/change-password">変更</Link>
              </Button>
            </li>
          </ul>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
search

import BooksSearch from '@/components/books/books-search';
import BooksSkeleton from '@/components/books/books-skeleton';
import { Separator } from '@/components/ui/separator';
import { usePageTitle } from '@/hooks/use-page-title';
import { useSearchFilters } from '@/hooks/use-search-filters';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';

export default function Page() {
  const { q, page } = useSearchFilters();

  usePageTitle(q);

  return (
    <>
      <div className="m-4 flex h-10 items-center">
        <h1>
          「 {q} 」
          <span className="text-sm text-muted-foreground">の検索結果</span>
        </h1>
      </div>

      <Separator className="my-4 bg-foreground/10" />

      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={<BooksSkeleton />}>
          <BooksSearch searchQuery={q} page={page} />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}

------------------------------------------------------------
signup

import Logo from '@/components/layout/logo';
import AvatarCarousel from '@/components/profile/avatar-carousel';
import PasswordInput from '@/components/profile/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { useApiUser } from '@/hooks/api/use-api-user';
import { usePageTitle } from '@/hooks/use-page-title';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/utils';
import { useAuth } from '@/providers/auth-provider';
import { SignupRequest } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import { useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

type Props = {
  title: string;
};

export default function Page({ title }: Props) {
  usePageTitle(title);

  const [emailErrorMessage, setEmailErrorMessage] = useState('');
  const [passwordErrorMessage, setPasswordErrorMessage] = useState('');
  const [nameErrorMessage, setNameErrorMessage] = useState('');

  const emailRef = useRef<HTMLInputElement | null>(null);
  const passwordRef = useRef<HTMLInputElement | null>(null);
  const nameRef = useRef<HTMLInputElement | null>(null);
  const [avatarPath, setAvatarPath] = useState('');

  const navigate = useNavigate();
  const { signup, setUser } = useAuth();
  const { getCurrentUser } = useApiUser();
  const { toast } = useToast();

  const signupMutation = useMutation({
    mutationFn: (requestBody: SignupRequest) => signup(requestBody),
    onSuccess: async () => {
      const user = await getCurrentUser();
      setUser(user);
      navigate('/');
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;
    const name = form.get('name') as string;

    const isEmailvalid = validateEmail();
    const isPasswordvalid = validatePassword();
    const isNamevalid = validateName();

    if (!isEmailvalid || !isPasswordvalid || !isNamevalid) {
      return;
    }

    const requestBody: SignupRequest = { email, password, name, avatarPath };
    signupMutation.mutate(requestBody, {
      onSuccess: () => {},
      onError: () => {
        toast({
          title: '新規登録できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateEmail = () => {
    setEmailErrorMessage('');

    const email = emailRef.current?.value as string;

    if (email === '') {
      setEmailErrorMessage('メールアドレスは必須です。');
      return false;
    }

    const emailRegex = /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(email)) {
      setEmailErrorMessage('無効なメールアドレスです。');
      return false;
    }

    return true;
  };

  const validatePassword = () => {
    setPasswordErrorMessage('');

    const password = passwordRef.current?.value as string;

    if (password === '') {
      setPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    if (password.length < 4) {
      setPasswordErrorMessage('パスワードは4文字以上で設定してください。');
      return false;
    }

    return true;
  };

  const validateName = () => {
    setNameErrorMessage('');

    const name = nameRef.current?.value as string;

    if (name === '') {
      setNameErrorMessage('ユーザー名は必須です。');
      return false;
    }

    return true;
  };

  return (
    <div className="my-3 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">アカウントの作成</h1>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form
            className="flex w-full flex-col gap-y-4"
            onSubmit={handleSubmit}
          >
            <div>
              <Label className="text-xs" htmlFor="email">
                メールアドレス
              </Label>
              <Input
                ref={emailRef}
                className={cn(
                  'my-2 rounded-full',
                  emailErrorMessage && 'border-destructive',
                )}
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
              />
              {emailErrorMessage && (
                <p className="text-xs text-destructive">{emailErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                パスワード
              </Label>
              <PasswordInput
                ref={passwordRef}
                className={cn(
                  'my-2 rounded-full',
                  passwordErrorMessage && 'border-destructive',
                )}
                id="password"
                name="password"
              />
              {passwordErrorMessage && (
                <p className="text-xs text-destructive">
                  {passwordErrorMessage}
                </p>
              )}
            </div>

            <Separator className="mb-2 mt-6 bg-foreground/10" />

            <div>
              <Label className="text-xs" htmlFor="name">
                ユーザー名
              </Label>
              <Input
                ref={nameRef}
                className={cn(
                  'my-2 rounded-full',
                  nameErrorMessage && 'border-destructive',
                )}
                id="name"
                name="name"
                autoComplete="off"
                spellCheck="false"
              />
              {nameErrorMessage && (
                <p className="text-xs text-destructive">{nameErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="name">
                アバター画像
              </Label>
              <AvatarCarousel value={avatarPath} onChange={setAvatarPath} />
            </div>

            <Button
              className="mt-2 w-full rounded-full"
              type="submit"
              disabled={signupMutation.isPending}
            >
              {signupMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '新規登録'
              )}
            </Button>
          </form>

          <div className="mt-6 flex justify-center gap-x-1 text-xs">
            <p className="text-muted-foreground">アカウントをお持ちですか？</p>
            <Link to={'/login'}>
              <p className="text-primary hover:underline">ログイン</p>
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
protected-route.tsx

import { useAuth } from '@/providers/auth-provider';
import { Navigate, Outlet, useLocation } from 'react-router-dom';

export default function ProtectedRoute() {
  const location = useLocation();
  const { accessToken, isLoading } = useAuth();

  if (isLoading) return null;

  return (
    <>
      {accessToken ? (
        <Outlet />
      ) : (
        <Navigate to="/login" state={{ from: location }} replace />
      )}
    </>
  );
}

------------------------------------------------------------
route.tsx

import BookDetailPage from '@/routes/book/[bookId]/page';
import BookmarksPage from '@/routes/bookmarks/page';
import DiscoverPage from '@/routes/discover/page';
import FavoritesPage from '@/routes/favorites/page';
import RootLayout from '@/routes/layout';
import LoginPage from '@/routes/login/page';
import MyReviewsPage from '@/routes/my-reviews/page';
import NotFoundPage from '@/routes/not-found';
import RootPage from '@/routes/page';
import ChangeEmailPage from '@/routes/profile/change-email/page';
import ChangePasswordPage from '@/routes/profile/change-password/page';
import ChangeUserInfoPage from '@/routes/profile/change-user-info/page';
import ProfilePage from '@/routes/profile/page';
import ProtectedRoute from '@/routes/protected-route';
import RankingPage from '@/routes/ranking/page';
import BookReadPage from '@/routes/read/[bookId]/chapter/[chapterNumber]/page/[pageNumber]/page';
import BookReadTableOfContentsPage from '@/routes/read/[bookId]/table-of-contents/page';
import SearchPage from '@/routes/search/page';
import SignupPage from '@/routes/signup/page';
import SpecialFeaturesPage from '@/routes/special-features/page';
import {
  createBrowserRouter,
  createRoutesFromElements,
  Route,
} from 'react-router-dom';

export const router = createBrowserRouter(
  createRoutesFromElements(
    <Route>
      <Route path="/" element={<RootLayout />}>
        <Route index element={<RootPage />} />

        <Route path="login" element={<LoginPage title="ログイン" />} />
        <Route path="signup" element={<SignupPage title="サインアップ" />} />

        <Route path="book">
          <Route path=":bookId" element={<BookDetailPage />} />
        </Route>

        <Route path="read">
          <Route path=":bookId">
            <Route
              path="table-of-contents"
              element={<BookReadTableOfContentsPage />}
            />
          </Route>
        </Route>

        <Route path="search" element={<SearchPage />} />
        <Route path="discover" element={<DiscoverPage title="ジャンル" />} />
        <Route path="ranking" element={<RankingPage title="ランキング" />} />
        <Route
          path="special-features"
          element={<SpecialFeaturesPage title="特集" />}
        />

        {/* 以下、認証が必要な画面 */}
        <Route element={<ProtectedRoute />}>
          <Route
            path="favorites"
            element={<FavoritesPage title="お気に入り" />}
          />
          <Route
            path="bookmarks"
            element={<BookmarksPage title="ブックマーク" />}
          />
          <Route
            path="my-reviews"
            element={<MyReviewsPage title="マイレビュー" />}
          />

          <Route path="profile">
            <Route index element={<ProfilePage title="プロフィール" />} />
            <Route
              path="change-user-info"
              element={<ChangeUserInfoPage title="ユーザー情報変更" />}
            />
            <Route
              path="change-email"
              element={<ChangeEmailPage title="メールアドレス変更" />}
            />
            <Route
              path="change-password"
              element={<ChangePasswordPage title="パスワード変更" />}
            />
          </Route>

          <Route path="read/:bookId">
            <Route path="chapter/:chapterNumber">
              <Route path="page/:pageNumber" element={<BookReadPage />} />
            </Route>
          </Route>
        </Route>

        <Route path="*" element={<NotFoundPage />} />
      </Route>
    </Route>,
  ),
);

------------------------------------------------------------
index.css

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }

  /* フォント */
  * {
    font-family: 'Inter', 'Noto Sans JP', system-ui, sans-serif;
  }

  /* スクロールバー */
  body ::-webkit-scrollbar-track {
    cursor: default;
    background-color: hsl(var(--muted));
  }
  body ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  body ::-webkit-scrollbar-thumb {
    cursor: default;
    border-radius: 8px;
    background-color: hsl(var(--foreground) / 0.2);
  }
  body ::-webkit-scrollbar-thumb:hover {
    background-color: hsl(var(--foreground) / 0.3);
  }
}

/*
カラーテーマは以下のページからコピペ
https://ui.jln.dev/
*/

@layer base {
  :root {
    --background: 112 100% 97%;
    --foreground: 60 2% 30%;
    --muted: 112 12% 90%;
    --muted-foreground: 112 12% 30%;
    --popover: 112 100% 94%;
    --popover-foreground: 60 2% 20%;
    --card: 112 100% 95%;
    --card-foreground: 60 2% 25%;
    --border: 112 90% 92%;
    --input: 112 90% 89%;
    --primary: 123 43% 39%;
    --primary-foreground: 0 0% 100%;
    --secondary: 123 30% 75%;
    --secondary-foreground: 123 30% 15%;
    --accent: 112 100% 82%;
    --accent-foreground: 112 100% 2%;
    --destructive: 2 96% 27%;
    --destructive-foreground: 2 96% 87%;

    --ring: 155 58% 29%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 200 19% 18%;
    --foreground: 0 0% 96%;
    --muted: 200 12% 22%;
    --muted-foreground: 200 12% 72%;
    --popover: 200 19% 15%;
    --popover-foreground: 0 0% 100%;
    --card: 200 19% 16%;
    --card-foreground: 0 0% 100%;
    --border: 200 9% 23%;
    --input: 200 9% 26%;
    --primary: 123 49% 59%;
    --primary-foreground: 0 0% 0%;
    --secondary: 123 30% 25%;
    --secondary-foreground: 123 30% 85%;
    --accent: 200 19% 33%;
    --accent-foreground: 200 19% 93%;
    --destructive: 4 91% 59%;
    --destructive-foreground: 0 0% 100%;
    --ring: 123 49% 59%;
  }
}

------------------------------------------------------------
main.tsx

import { AuthProvider } from '@/providers/auth-provider';
import { ThemeProvider } from '@/providers/theme-provider';
import { router } from '@/routes/route';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { RouterProvider } from 'react-router-dom';
import './index.css';

const queryClient = new QueryClient();

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <ThemeProvider defaultTheme="dark" storageKey="vite-ui-theme">
          <RouterProvider router={router} />
        </ThemeProvider>
      </AuthProvider>
    </QueryClientProvider>
  </StrictMode>,
);

------------------------------------------------------------
.prettierrc.cjs

module.exports = {
  singleQuote: true, // シングルクォートに統一（デフォルト:false）

  // Prettierでimportを整理（未使用のインポートを並べ替え、結合、削除）
  // https://www.npmjs.com/package/prettier-plugin-organize-imports
  plugins: ['prettier-plugin-organize-imports'],
};

------------------------------------------------------------
index.html

<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="本の探索サイトへようこそ。多様なコレクションから、新しい知識を発見しましょう。厳選された書籍で、あなたの次の読書を見つけてください。知識の旅に一緒に出かけましょう。"
    />
    <title>My Books</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Noto+Sans+JP:wght@100..900&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

------------------------------------------------------------

×
use-auth.ts
util.ts
auth-provider.tsx

