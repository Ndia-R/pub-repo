２７ファイル　package.json

------------------------------------------------------------
book-detail-skeleton

import { Skeleton } from '@/components/ui/skeleton';

export default function BookDetailSkeleton() {
  return (
    <>
      <div className="flex flex-col justify-center p-3 pt-10 sm:p-6 lg:flex-row">
        <div className="flex flex-col items-center justify-center lg:w-1/2">
          <Skeleton className="h-[360px] w-[280px] rounded bg-muted-foreground/5 object-cover sm:h-[480px] sm:w-[360px]" />
          <div className="mt-2 flex flex-col items-center sm:w-[440px]">
            <div className="flex items-center gap-x-2">
              <Skeleton className="my-1 h-8 w-48 rounded-full bg-muted-foreground/5" />
            </div>
            <div className="flex justify-center gap-x-2">
              <Skeleton className="size-8 rounded-full bg-muted-foreground/5" />
              <Skeleton className="size-8 rounded-full bg-muted-foreground/5" />
            </div>
          </div>
          <div className="my-4 flex items-center">
            <Skeleton className="h-11 w-48 rounded-full bg-muted-foreground/5" />
          </div>
        </div>

        <div className="p-4 lg:w-1/2">
          <div className="text-3xl font-bold sm:text-4xl">
            <Skeleton className="h-9 w-64 rounded-full bg-muted-foreground/5 sm:h-10" />
          </div>
          <div className="my-4 flex w-full flex-wrap items-center justify-end gap-x-3">
            <Skeleton className="h-7 w-24 rounded-full bg-muted-foreground/5 sm:h-8" />
          </div>

          <div className="flex gap-x-2">
            <Skeleton className="h-9 w-24 rounded-full bg-muted-foreground/5" />
            <Skeleton className="h-9 w-24 rounded-full bg-muted-foreground/5" />
          </div>

          <div className="my-6 md:my-10">
            <Skeleton className="my-2 h-6 w-full rounded-full bg-muted-foreground/5" />
            <Skeleton className="my-2 h-6 w-full rounded-full bg-muted-foreground/5" />
            <Skeleton className="my-2 h-6 w-full rounded-full bg-muted-foreground/5" />
          </div>

          <div className="flex flex-col justify-between gap-y-4 lg:flex-row">
            <div className="flex flex-col gap-y-1 text-muted-foreground">
              <div className="flex">
                <Skeleton className="mb-1 h-5 w-48 rounded-full bg-muted-foreground/5" />
              </div>
              <div className="flex">
                <Skeleton className="mb-1 h-5 w-36 rounded-full bg-muted-foreground/5" />
              </div>
              <div className="flex">
                <Skeleton className="mb-1 h-5 w-44 rounded-full bg-muted-foreground/5" />
              </div>
              <div className="flex">
                <Skeleton className="mb-1 h-5 w-36 rounded-full bg-muted-foreground/5" />
              </div>
              <div className="flex">
                <Skeleton className="mb-1 h-5 w-32 rounded-full bg-muted-foreground/5" />
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
}

------------------------------------------------------------
book-detail

import BookDetailSkeleton from '@/components/book-detail/book-detail-skeleton';
import FavoriteButton from '@/components/favorite-button';
import GenreList from '@/components/genre-list/genre-list';
import GenreListSkeleton from '@/components/genre-list/genre-list-skeleton';
import MyListButton from '@/components/my-list-button';
import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useFetchData } from '@/hooks/use-fetch-data';
import { useUser } from '@/hooks/use-user';
import { getBookDetailById } from '@/lib/data';
import { formatDateJP, formatIsbn, priceToString } from '@/lib/util';
import ErrorElement from '@/routes/error-element';
import { type BookDetail } from '@/types/book';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { Await } from 'react-router-dom';

type Props = {
  bookId: string;
};

export default function BookDetail({ bookId }: Props) {
  const { data: bookDetail } = useFetchData({
    queryKey: [bookId],
    queryFn: () => getBookDetailById(bookId),
  });

  const { user } = useUser();

  return (
    <Await resolve={bookDetail}>
      {(bookDetail: BookDetail) => {
        if (!bookDetail) return <BookDetailSkeleton />;
        return (
          <div className="flex flex-col justify-center p-3 pt-10 sm:p-6 lg:flex-row">
            <div className="flex flex-col items-center justify-center lg:w-1/2">
              <img
                className="h-[360px] rounded object-cover sm:h-[480px]"
                src={bookDetail.imageUrl}
                alt={bookDetail.title}
              />
              <div className="mt-2 flex flex-col items-center sm:w-[440px]">
                <div className="flex items-center gap-x-2">
                  <Rating rating={bookDetail.rating} readOnly />
                  <p className="text-sm text-muted-foreground">{`( ${bookDetail.reviewCount} )`}</p>
                </div>

                <div className="flex justify-center gap-x-2">
                  <div className="flex items-center gap-x-1">
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <MyListButton />
                      </TooltipTrigger>
                      {user ? (
                        <TooltipContent>マイリストに追加</TooltipContent>
                      ) : (
                        <TooltipContent>
                          ログインしてこの本を「マイリスト」に加えましょう
                        </TooltipContent>
                      )}
                    </Tooltip>
                    <p className="text-sm text-muted-foreground">
                      {bookDetail.myListCount}
                    </p>
                  </div>
                  <div className="flex items-center gap-x-1">
                    <ErrorBoundary fallback={<ErrorElement />}>
                      <Suspense fallback={<p>LLLL</p>}>
                        <FavoriteButton bookId={bookId} />
                      </Suspense>
                    </ErrorBoundary>
                    <p className="text-sm text-muted-foreground">
                      {bookDetail.favoriteCount}
                    </p>
                  </div>
                </div>
              </div>

              <div className="my-4 flex items-center">
                <Button className="w-48 rounded-full" size="lg">
                  読む
                </Button>
              </div>
            </div>

            <div className="p-4 lg:w-1/2">
              <p className="text-3xl font-bold sm:text-4xl">{bookDetail.title}</p>

              <div className="my-4 flex w-full flex-wrap items-center justify-end gap-x-3">
                <p>著者</p>
                {bookDetail.authors.map((author) => (
                  <p className="text-lg font-bold sm:text-2xl" key={author}>
                    {author}
                  </p>
                ))}
              </div>

              <ErrorBoundary fallback={<ErrorElement />}>
                <Suspense fallback={<GenreListSkeleton />}>
                  <GenreList
                    className="gap-2"
                    filterList={bookDetail.genreIds}
                    variant="outline"
                  />
                </Suspense>
              </ErrorBoundary>

              <div className="my-6 md:my-10">{bookDetail.description}</div>

              <div className="flex flex-col justify-between gap-y-4 lg:flex-row">
                <div className="flex flex-col gap-y-1 text-muted-foreground">
                  <div className="flex">
                    <p className="min-w-20">ISBN</p>
                    <p>{formatIsbn(bookDetail.isbn)}</p>
                  </div>
                  <div className="flex">
                    <p className="min-w-20">出版社</p>
                    <p>{bookDetail.publisher}</p>
                  </div>
                  <div className="flex">
                    <p className="min-w-20">発売日</p>
                    <p className="tracking-wide">
                      {formatDateJP(bookDetail.publishedDate)}
                    </p>
                  </div>
                  <div className="flex">
                    <p className="min-w-20">ページ数</p>
                    <p>{`${bookDetail.pageCount}ページ`}</p>
                  </div>
                  <div className="flex">
                    <p className="min-w-20">価格</p>
                    <p>{priceToString(bookDetail.price)}</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
book-list-by-genre-id

import BookList from '@/components/book-list/book-list';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import BookPagination from '@/components/book-list/book-pagination';
import { useFetchData } from '@/hooks/use-fetch-data';
import { getBooksByGenreId } from '@/lib/data';
import { PaginatedBook } from '@/types/book';
import { Await } from 'react-router-dom';

type Props = {
  genreId: string;
  page: number;
};

export default function BookListByGenreId({ genreId, page }: Props) {
  const { data: paginatedBook } = useFetchData({
    queryKey: [genreId, page],
    queryFn: () => getBooksByGenreId(genreId, page - 1),
  });

  return (
    <Await resolve={paginatedBook}>
      {(paginatedBook: PaginatedBook) => {
        if (!paginatedBook) return <BookListSkeleton />;
        return (
          <div className="flex flex-col gap-y-4 pb-4">
            <BookPagination totalPages={paginatedBook.totalPages} />
            <BookList books={paginatedBook.books} />
            <BookPagination totalPages={paginatedBook.totalPages} />
          </div>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
book-list-by-query

import BookList from '@/components/book-list/book-list';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import BookPagination from '@/components/book-list/book-pagination';
import { useFetchData } from '@/hooks/use-fetch-data';
import { getBooksByQuery } from '@/lib/data';
import { PaginatedBook } from '@/types/book';
import { Await } from 'react-router-dom';

type Props = {
  query: string;
  page: number;
};

export default function BookListByQuery({ query, page }: Props) {
  const { data: paginatedBook } = useFetchData({
    queryKey: [query, page],
    queryFn: () => getBooksByQuery(query, page - 1),
  });

  return (
    <Await resolve={paginatedBook}>
      {(paginatedBook: PaginatedBook) => {
        if (!paginatedBook) return <BookListSkeleton />;
        return (
          <div className="flex flex-col gap-y-4 pb-4">
            <BookPagination totalPages={paginatedBook.totalPages} />
            <BookList books={paginatedBook.books} />
            <BookPagination totalPages={paginatedBook.totalPages} />
          </div>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
book-list-favorites

import BookList from '@/components/book-list/book-list';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import BookPagination from '@/components/book-list/book-pagination';
import { useFetchData } from '@/hooks/use-fetch-data';
import { getFavorites } from '@/lib/data';
import { PaginatedBook } from '@/types/book';
import { Await } from 'react-router-dom';

type Props = {
  page: number;
};

export default function BookListFavorites({ page }: Props) {
  const { data: paginatedBook } = useFetchData({
    queryKey: [page],
    queryFn: () => getFavorites(page - 1),
  });

  return (
    <Await resolve={paginatedBook}>
      {(paginatedBook: PaginatedBook) => {
        if (!paginatedBook) return <BookListSkeleton />;
        return (
          <div className="flex flex-col gap-y-4 pb-4">
            <BookPagination totalPages={paginatedBook.totalPages} />
            <BookList books={paginatedBook.books} />
            <BookPagination totalPages={paginatedBook.totalPages} />
          </div>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
book-list-my-lists

import BookList from '@/components/book-list/book-list';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import BookPagination from '@/components/book-list/book-pagination';
import { useFetchData } from '@/hooks/use-fetch-data';
import { getMyLists } from '@/lib/data';
import { PaginatedBook } from '@/types/book';
import { Await } from 'react-router-dom';

type Props = {
  page: number;
};

export default function BookListMyLists({ page }: Props) {
  const { data: paginatedBook } = useFetchData({
    queryKey: [page],
    queryFn: () => getMyLists(page - 1),
  });

  return (
    <Await resolve={paginatedBook}>
      {(paginatedBook: PaginatedBook) => {
        if (!paginatedBook) return <BookListSkeleton />;
        return (
          <div className="flex flex-col gap-y-4 pb-4">
            <BookPagination totalPages={paginatedBook.totalPages} />
            <BookList books={paginatedBook.books} />
            <BookPagination totalPages={paginatedBook.totalPages} />
          </div>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
book-list-new-releases

import BookList from '@/components/book-list/book-list';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import { useFetchData } from '@/hooks/use-fetch-data';
import { getNewReleases } from '@/lib/data';
import { Book } from '@/types/book';
import { Await } from 'react-router-dom';

export default function BookListNewReleases() {
  const { data: books } = useFetchData({
    queryKey: [],
    queryFn: () => getNewReleases(),
  });

  return (
    <Await resolve={books}>
      {(books: Book[]) => {
        if (!books) return <BookListSkeleton paginationOff />;
        return (
          <div className="pb-4">
            <BookList books={books} />
          </div>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
genre-list-skeleton

import { Skeleton } from '@/components/ui/skeleton';

export default function GenreListSkeleton() {
  return (
    <>
      <ul className="flex flex-wrap gap-x-2">
        {[...Array<number>(2)].map((_, index) => (
          <li key={index}>
            <Skeleton className="h-9 w-24 rounded-full bg-muted-foreground/5" />
          </li>
        ))}
      </ul>
    </>
  );
}

------------------------------------------------------------
genre-list

import GenreListSkeleton from '@/components/genre-list/genre-list-skeleton';
import { Button } from '@/components/ui/button';
import { useFetchData } from '@/hooks/use-fetch-data';
import { getGenres } from '@/lib/data';
import { cn } from '@/lib/util';
import { Genre } from '@/types/book';
import { Await, Link } from 'react-router-dom';

type Props = {
  className?: string;
  filterList?: number[];
  variant?: 'default' | 'outline' | 'secondary' | 'ghost';
};

export default function GenreList({
  className,
  filterList = [],
  variant = 'default',
}: Props) {
  const { data: genres } = useFetchData({
    queryKey: [],
    queryFn: () => getGenres(),
  });

  return (
    <Await resolve={genres}>
      {(genres: Genre[]) => {
        if (!genres) return <GenreListSkeleton />;
        const filteredGenres =
          filterList.length === 0
            ? genres
            : genres.filter((genre) => filterList.includes(genre.id));
        return (
          <ul className={cn('flex flex-wrap', className)}>
            {filteredGenres.map((genre) => (
              <li key={genre.id}>
                <Button
                  className={cn(
                    'rounded-full',
                    variant === 'outline' && 'bg-transparent'
                  )}
                  variant={variant}
                  size="sm"
                  asChild
                >
                  <Link to={`/discover?genreId=${genre.id}`}>{genre.name}</Link>
                </Button>
              </li>
            ))}
          </ul>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
genre-selector

import GenreSelectorSkeleton from '@/components/genre-list/genre-selector-skeleton';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Separator } from '@/components/ui/separator';
import { useFetchData } from '@/hooks/use-fetch-data';
import { getGenres } from '@/lib/data';
import { cn } from '@/lib/util';
import { Genre } from '@/types/book';
import { CheckIcon } from 'lucide-react';
import { useEffect, useState } from 'react';
import { Await, useLocation, useNavigate } from 'react-router-dom';

type ConditionType = {
  id: string;
  value: string;
  splitCode: string;
};

const CONDITIONS: ConditionType[] = [
  { id: 'and-condition', value: 'AND', splitCode: ',' },
  { id: 'or-condition', value: 'OR', splitCode: '|' },
];

const parseGenreIdQuery = (genreIdQuery: string) => {
  for (const condition of CONDITIONS) {
    if (genreIdQuery.includes(condition.splitCode)) {
      return {
        ids: genreIdQuery.split(condition.splitCode).map((id) => Number(id)),
        condition,
      };
    }
  }
  const ids = genreIdQuery ? [Number(genreIdQuery)] : [];
  return { ids, condition: CONDITIONS[0] };
};

export default function GenreSelector() {
  const { data: genres } = useFetchData({
    queryKey: [],
    queryFn: () => getGenres(),
  });

  const location = useLocation();
  const navigate = useNavigate();

  const [selectedGenres, setSelectedGenres] = useState<number[]>([]);
  const [selectedCondition, setSelectedCondition] = useState<ConditionType>(
    CONDITIONS[0]
  );

  const isActive = (id: number) => selectedGenres.includes(id);

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const genreIdQuery = params.get('genreId') ?? '';

    const { ids, condition } = parseGenreIdQuery(genreIdQuery);

    setSelectedGenres(ids);
    if (ids.length > 1) setSelectedCondition(condition);
  }, [location.search]);

  const handleClickGenre = (genreId: number) => {
    const ids = isActive(genreId)
      ? selectedGenres.filter((id) => id !== genreId)
      : [...selectedGenres, genreId];
    setSelectedGenres(ids);

    const genreIdQuery = ids.join(selectedCondition.splitCode);
    updateDiscoverUrl(genreIdQuery);
  };

  const handleValueChange = (value: string) => {
    const selected =
      CONDITIONS.find((condition) => condition.value === value) || CONDITIONS[0];
    setSelectedCondition(selected);

    const genreIdQuery = selectedGenres.join(selected.splitCode);
    updateDiscoverUrl(genreIdQuery);
  };

  const updateDiscoverUrl = (genreIdQuery: string) => {
    const params = new URLSearchParams(location.search);
    params.set('genreId', genreIdQuery);
    params.set('page', '1');
    navigate(`/discover?${params.toString()}`);
  };

  return (
    <Await resolve={genres}>
      {(genres: Genre[]) => {
        if (!genres) return <GenreSelectorSkeleton />;
        return (
          <>
            <div className="my-4 flex items-center justify-between">
              <p className="my-2">ジャンル</p>
              <RadioGroup
                className="flex gap-x-4"
                value={selectedCondition.value}
                onValueChange={handleValueChange}
              >
                {CONDITIONS.map((condition) => (
                  <div className="flex items-center" key={condition.id}>
                    <RadioGroupItem value={condition.value} id={condition.id} />
                    <Label
                      className="cursor-pointer select-none p-2"
                      htmlFor={condition.id}
                    >
                      {condition.value}
                    </Label>
                  </div>
                ))}
              </RadioGroup>
            </div>

            <Separator className="my-4 bg-foreground/10" />

            <ul className="flex flex-wrap">
              {genres.map((genre) => (
                <li key={genre.id}>
                  <Button
                    className={cn(
                      'rounded-full m-1 text-muted-foreground text-xs sm:text-sm',
                      isActive(genre.id) && 'text-foreground'
                    )}
                    variant={isActive(genre.id) ? 'secondary' : 'ghost'}
                    size="sm"
                    onClick={() => handleClickGenre(genre.id)}
                  >
                    {isActive(genre.id) && (
                      <CheckIcon className="mr-1 size-4" strokeWidth={4} />
                    )}
                    {genre.name}
                  </Button>
                </li>
              ))}
            </ul>

            <Separator className="my-4 bg-foreground/10" />
          </>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
review-create-dialog

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { useUser } from '@/hooks/use-user';
import { createReview } from '@/lib/action';
import { Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState, useTransition } from 'react';

type Props = {
  bookId: string;
  refetch: () => void;
};

export default function ReviewCreateDialog({ bookId, refetch }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();
  const { user } = useUser();
  const [isPending, startTransition] = useTransition();

  useEffect(() => {
    if (isOpen) {
      setRating(0);
      setComment('');
    }
  }, [isOpen]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handlePost = async () => {
    if (rating === 0) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: 'このまま投稿しますか？',
        message: '星の数が「0」のままです。',
        actionLabel: '投稿する',
      });
      if (isCancel) return;
    }

    const isSuccess = await createReview({ comment, rating, bookId });
    if (!isSuccess) {
      toast({
        title: 'レビュー投稿に失敗しました',
        description: '管理者へ連絡してください',
        variant: 'destructive',
        duration: 5000,
      });
      setIsOpen(false);
      return;
    }

    toast({ description: 'レビューを投稿しました' });
    setIsOpen(false);

    startTransition(() => {
      refetch();
    });
  };

  const handleCloseDialog = async () => {
    if (comment) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: '本当に閉じますか？',
        message: 'コメントはまだ投稿していません。',
        actionLabel: '閉じる',
        persistent: true,
      });
      if (isCancel) return;
    }
    setIsOpen(false);
  };

  return (
    <>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className="w-44 rounded-full bg-transparent"
            variant="outline"
            disabled={isPending}
            onClick={() => user && setIsOpen(true)}
          >
            {isPending ? <Loader2Icon className="animate-spin" /> : 'レビューを書く'}
          </Button>
        </TooltipTrigger>
        {!user && (
          <TooltipContent>ログインしてこの本の「レビュー」を書きましょう</TooltipContent>
        )}
      </Tooltip>

      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogContent
          className="w-1/2 min-w-[360px] max-w-[600px] p-4 md:p-6"
          onEscapeKeyDown={handleCloseDialog}
          onPointerDownOutside={handleCloseDialog}
          onAnimationStart={handleAnimationStart}
        >
          <div className="flex items-start justify-between">
            <div>
              <p className="font-semibold leading-10">レビュー</p>
              <p className="text-xs text-muted-foreground md:text-sm">
                素敵な感想を伝えましょう！
              </p>
            </div>
            <div>
              <Rating rating={rating} onChange={setRating} />
              <p className="text-center text-xs text-muted-foreground md:text-sm">
                {rating === 0 ? '星をクリックして決定' : ''}
              </p>
            </div>
          </div>

          <Textarea
            ref={ref}
            spellCheck={false}
            value={comment}
            onChange={(e) => setComment(e.currentTarget.value)}
          />

          <DialogFooter>
            <Button className="rounded-full" variant="ghost" onClick={handleCloseDialog}>
              閉じる
            </Button>
            <Button
              className="rounded-full"
              disabled={comment === '' ? true : false}
              onClick={handlePost}
            >
              投稿する
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}

------------------------------------------------------------
review-item

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/review-list/review-update-dialog';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useUser } from '@/hooks/use-user';
import { deleteReview } from '@/lib/action';
import { formatDateJP, formatTime } from '@/lib/util';
import { Review } from '@/types/review';
import { Loader2Icon, Trash2Icon } from 'lucide-react';
import { useTransition } from 'react';

type Props = {
  review: Review;
  bookId: string;
  refetch: () => void;
};

export default function ReviewItem({ review, bookId, refetch }: Props) {
  const { user } = useUser();
  const { confirmDialog } = useConfirmDialog();
  const [isPending, startTransition] = useTransition();

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: '!',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除',
    });
    if (isCancel) return;

    await deleteReview(review.id);

    startTransition(() => {
      refetch();
    });
  };

  return (
    <div className="p-4">
      <div className="flex flex-col items-center justify-between sm:flex-row">
        <div className="flex items-center gap-x-4">
          <Avatar className="size-16">
            <AvatarImage
              className="bg-primary/50"
              src={review.user.avatarUrl}
              alt="avatar-image"
            />
            <AvatarFallback className="font-semibold">
              {review.user.name.slice(0, 1)}
            </AvatarFallback>
          </Avatar>
          <div>
            <p className="-mb-1 text-lg font-semibold">{review.user.name}</p>
            <div className="flex items-center">
              <p className="text-sm leading-8 tracking-wide text-muted-foreground">
                {formatDateJP(review.updatedAt)} {formatTime(review.updatedAt)}
              </p>
              <div className="ml-2 flex w-16">
                {user?.id === review.user.id && (
                  <>
                    <ReviewUpdateDialog
                      review={review}
                      bookId={bookId}
                      refetch={refetch}
                    />
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      disabled={isPending}
                      onClick={handleClickDelete}
                    >
                      {isPending ? (
                        <Loader2Icon className="size-4 animate-spin" />
                      ) : (
                        <Trash2Icon className="size-4" />
                      )}
                    </Button>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
        <Rating rating={review.rating} readOnly />
      </div>
      <p className="mt-2 text-muted-foreground sm:pl-20">{review.comment}</p>
    </div>
  );
}

------------------------------------------------------------
review-list

import ReviewCreateDialog from '@/components/review-list/review-create-dialog';
import ReviewItem from '@/components/review-list/review-item';
import ReviewListSkeleton from '@/components/review-list/review-list-skeleton';
import { Separator } from '@/components/ui/separator';
import { useFetchData } from '@/hooks/use-fetch-data';
import { getReviewsByBookId } from '@/lib/data';
import { Review } from '@/types/review';
import { Await } from 'react-router-dom';

type Props = {
  bookId: string;
};

export default function ReviewList({ bookId }: Props) {
  const { data: reviews, refetch } = useFetchData({
    queryKey: [bookId],
    queryFn: () => getReviewsByBookId(bookId),
  });

  return (
    <Await resolve={reviews}>
      {(reviews: Review[]) => {
        if (!reviews) return <ReviewListSkeleton />;
        return (
          <div className="mx-auto w-full lg:w-3/4">
            <div className="flex flex-col-reverse items-center justify-end gap-y-4 sm:flex-row sm:gap-x-4 sm:px-6">
              <p>レビュー {reviews.length} 件</p>
              <ReviewCreateDialog bookId={bookId} refetch={refetch} />
            </div>

            <ul className="flex flex-col p-3 sm:p-6">
              {reviews.map((review) => (
                <li key={review.id}>
                  <Separator className="bg-foreground/10" />
                  <ReviewItem review={review} bookId={bookId} refetch={refetch} />
                </li>
              ))}
            </ul>
          </div>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
review-update-dialog

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { Tooltip, TooltipTrigger } from '@/components/ui/tooltip';
import { useToast } from '@/hooks/use-toast';
import { useUser } from '@/hooks/use-user';
import { updateReview } from '@/lib/action';
import { Review } from '@/types/review';
import { Loader2Icon, SquarePenIcon } from 'lucide-react';
import React, { useEffect, useRef, useState, useTransition } from 'react';

type Props = {
  review: Review;
  bookId: string;
  refetch: () => void;
};

export default function ReviewUpdateDialog({ review, bookId, refetch }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { toast } = useToast();
  const { user } = useUser();
  const [isPending, startTransition] = useTransition();

  useEffect(() => {
    if (isOpen) {
      setRating(review.rating);
      setComment(review.comment);
    }
  }, [isOpen, review.comment, review.rating]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handlePost = async () => {
    const isSuccess = await updateReview(review.id, { bookId, comment, rating });
    if (!isSuccess) {
      toast({
        title: 'レビュー投稿に失敗しました',
        description: '管理者へ連絡してください',
        variant: 'destructive',
        duration: 5000,
      });
      setIsOpen(false);
      return;
    }

    toast({ description: 'レビューを投稿しました' });
    setIsOpen(false);

    startTransition(() => {
      refetch();
    });
  };

  const handleCloseDialog = async () => {
    setIsOpen(false);
  };

  return (
    <>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className="size-8 rounded-full text-muted-foreground"
            variant="ghost"
            size="icon"
            disabled={isPending}
            onClick={() => user && setIsOpen(true)}
          >
            {isPending ? (
              <Loader2Icon className="size-4 animate-spin" />
            ) : (
              <SquarePenIcon className="size-4" />
            )}
          </Button>
        </TooltipTrigger>
      </Tooltip>

      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogContent
          className="w-1/2 min-w-[360px] max-w-[600px] p-4 md:p-6"
          onEscapeKeyDown={handleCloseDialog}
          onPointerDownOutside={handleCloseDialog}
          onAnimationStart={handleAnimationStart}
        >
          <div className="flex items-start justify-between">
            <div>
              <p className="font-semibold leading-10">レビュー</p>
              <p className="text-xs text-muted-foreground md:text-sm">
                素敵な感想を伝えましょう！
              </p>
            </div>
            <div>
              <Rating rating={rating} onChange={setRating} />
              <p className="text-center text-xs text-muted-foreground md:text-sm">
                {rating === 0 ? '星をクリックして決定' : ''}
              </p>
            </div>
          </div>

          <Textarea
            ref={ref}
            spellCheck={false}
            value={comment}
            onChange={(e) => setComment(e.currentTarget.value)}
          />

          <DialogFooter>
            <Button className="rounded-full" variant="ghost" onClick={handleCloseDialog}>
              閉じる
            </Button>
            <Button
              className="rounded-full"
              disabled={comment === '' ? true : false}
              onClick={handlePost}
            >
              投稿する
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}

------------------------------------------------------------
favorite-button

import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useFetchData } from '@/hooks/use-fetch-data';
import { useUser } from '@/hooks/use-user';
import { addFavorite, removeFavorite } from '@/lib/action';
import { getFavoriteState } from '@/lib/data';
import { cn } from '@/lib/util';
import { FavoriteState } from '@/types/book';
import { HeartIcon } from 'lucide-react';
import { startTransition } from 'react';
import { Await } from 'react-router-dom';

const BUTTON_SIZE = {
  sm: 'size-6',
  md: 'size-8',
  lg: '',
};
const ICON_SIZE = {
  sm: 'size-3',
  md: 'size-4',
  lg: '',
};

type Props = {
  className?: string;
  size?: 'sm' | 'md' | 'lg';
  bookId: string;
};

export default function FavoriteButton({ className, size = 'md', bookId }: Props) {
  const { data: favoriteState, refetch } = useFetchData({
    queryKey: [bookId],
    queryFn: () => getFavoriteState(bookId),
  });

  const { user } = useUser();

  const handleClick = async (isFavorite: boolean) => {
    if (isFavorite) {
      console.log('remove');

      await removeFavorite(bookId);
    } else {
      console.log('add');
      await addFavorite(bookId);
    }
    startTransition(() => {
      console.log('refetch');
      refetch();
    });
  };

  return (
    <Await resolve={favoriteState}>
      {(favoriteState: FavoriteState) => {
        if (!favoriteState) return null;
        return (
          <>
            <Tooltip>
              <TooltipTrigger asChild>
                <div className={className}>
                  <Button
                    className={cn(
                      'rounded-full text-muted-foreground',
                      BUTTON_SIZE[size],
                      favoriteState.isFavorite && 'text-primary bg-transparent'
                    )}
                    variant="ghost"
                    size="icon"
                    onClick={() => handleClick(favoriteState.isFavorite)}
                  >
                    <HeartIcon
                      className={ICON_SIZE[size]}
                      style={{
                        fill: favoriteState.isFavorite ? 'hsl(var(--primary))' : '',
                      }}
                    />
                  </Button>
                </div>
              </TooltipTrigger>
              {user ? (
                <TooltipContent>
                  {favoriteState.isFavorite ? 'お気に入りから削除' : 'お気に入りに追加'}
                </TooltipContent>
              ) : (
                <TooltipContent>
                  ログインしてこの本を「お気に入り」に加えましょう
                </TooltipContent>
              )}
            </Tooltip>
            {favoriteState.favoriteCount}
          </>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
profile-counts

import CountUpNumber from '@/components/count-up-number';
import { useFetchData } from '@/hooks/use-fetch-data';
import { getProfileCounts } from '@/lib/data';
import { type ProfileCounts } from '@/types/user';
import { Await } from 'react-router-dom';

export default function ProfileCounts() {
  const { data: profileCounts } = useFetchData({
    queryKey: [],
    queryFn: () => getProfileCounts(),
  });

  return (
    <Await resolve={profileCounts}>
      {(profileCounts: ProfileCounts) => {
        if (!profileCounts) return null;
        return (
          <div className="flex justify-between pt-8">
            <div className="animate-fadeInUp-4 delay-0">
              <div className="w-20 text-center">
                <p className="text-xl font-bold">
                  <CountUpNumber end={profileCounts.favoriteCount} delay={300} />
                </p>
                <p className="text-sm">お気に入り</p>
              </div>
            </div>
            <div className="animate-fadeInUp-4 delay-100">
              <div className="w-20 text-center">
                <p className="text-xl font-bold">
                  <CountUpNumber end={profileCounts.myListCount} delay={400} />
                </p>
                <p className="text-sm">マイリスト</p>
              </div>
            </div>
            <div className="animate-fadeInUp-4 delay-200">
              <div className="w-20 text-center">
                <p className="text-xl font-bold">
                  <CountUpNumber end={profileCounts.reviewCount} delay={500} />
                </p>
                <p className="text-sm">レビュー</p>
              </div>
            </div>
          </div>
        );
      }}
    </Await>
  );
}

------------------------------------------------------------
use-fetch-data

/* eslint-disable react-hooks/exhaustive-deps */

import { useEffect, useState } from 'react';

type Props = {
  queryKey: unknown[];
  queryFn: () => Promise<unknown>;
};

export const useFetchData = ({ queryKey, queryFn }: Props) => {
  const [data, setData] = useState<Promise<unknown>>();

  useEffect(() => {
    setData(queryFn());
  }, [...queryKey]);

  const refetch = () => {
    setData(queryFn());
  };

  return { data, refetch };
};

------------------------------------------------------------
action

import { fetchWithAuth } from '@/lib/auth';
import { ReviewRequest } from '@/types/review';
import { ChangeEmail, ChangePassword, UpdateCurrentUser } from '@/types/user';

export const updateCurrentUser = async (requestBody: UpdateCurrentUser) => {
  try {
    const url = `/me`;
    const options: RequestInit = {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    };
    await fetchWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const changePassword = async (requestBody: ChangePassword) => {
  try {
    const url = `/me/password`;
    const options: RequestInit = {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    };
    await fetchWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const changeEmail = async (requestBody: ChangeEmail) => {
  try {
    const url = `/me/email`;
    const options: RequestInit = {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    };
    await fetchWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const createReview = async (reqestBody: ReviewRequest) => {
  try {
    const url = `/reviews`;
    const options: RequestInit = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(reqestBody),
    };
    await fetchWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const updateReview = async (reviewId: number, reqestBody: ReviewRequest) => {
  try {
    const url = `/reviews/${reviewId}`;
    const options: RequestInit = {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(reqestBody),
    };
    await fetchWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const deleteReview = async (reviewId: number) => {
  try {
    const url = `/reviews/${reviewId}`;
    const options: RequestInit = { method: 'DELETE' };
    await fetchWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const addFavorite = async (bookId: string) => {
  try {
    const url = `/favorites`;
    const options: RequestInit = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ bookId }),
    };
    await fetchWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const removeFavorite = async (bookId: string) => {
  try {
    const url = `/favorites/${bookId}`;
    const options: RequestInit = { method: 'DELETE' };
    await fetchWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

------------------------------------------------------------
data

import { BOOKS_API_ENDPOINT } from '@/constants/constants';
import { fetchWithAuth } from '@/lib/auth';
import { sleep } from '@/lib/util';
import { Book, BookDetail, FavoriteState, Genre, PaginatedBook } from '@/types/book';
import { Review } from '@/types/review';
import { CheckNameExists, ProfileCounts, User } from '@/types/user';

export const FETCH_BOOKS_MAX_RESULTS = 20;

export const getGenres = async () => {
  try {
    const url = `/genres`;
    const genres = await fetchJSON<Genre[]>(url);
    return genres;
  } catch {
    throw new Error('ジャンル一覧の読み込みが失敗しました。');
  }
};

export const getBookDetailById = async (bookId: string) => {
  try {
    const url = `/books/${bookId}`;
    const bookDetail = await fetchJSON<BookDetail>(url);
    return bookDetail;
  } catch {
    throw new Error('書籍情報の読み込みが失敗しました。');
  }
};

export const getBooksByQuery = async (q: string, page: number = 0) => {
  try {
    const url = `/books/search?q=${q}&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
    const paginatedBook = await fetchJSON<PaginatedBook>(url);
    return paginatedBook;
  } catch {
    throw new Error('書籍検索が失敗しました。');
  }
};

export const getBooksByGenreId = async (genreIdsQuery: string, page: number = 0) => {
  try {
    // 「|」はそのまま渡すとエラーになるので、URLエンコードする
    const encodedParams = genreIdsQuery.replace(/\|/g, encodeURIComponent('|'));

    const url = `/books/discover?genreId=${encodedParams}&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
    const paginatedBook = await fetchJSON<PaginatedBook>(url);
    return paginatedBook;
  } catch {
    throw new Error('ジャンル検索が失敗しました。');
  }
};

export const getFavorites = async (page: number = 0) => {
  try {
    const url = `/favorites?&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
    const paginatedBook = await fetchWithAuth<PaginatedBook>(url);
    return paginatedBook;
  } catch {
    throw new Error('お気に入り一覧の読み込みが失敗しました。');
  }
};

export const getMyLists = async (page: number = 0) => {
  try {
    const url = `/my-lists?&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
    const paginatedBook = await fetchWithAuth<PaginatedBook>(url);
    return paginatedBook;
  } catch {
    throw new Error('マイリスト一覧の読み込みが失敗しました。');
  }
};

export const getFavoriteState = async (bookId: string) => {
  if (!bookId) {
    return {
      isFavorite: false,
      facoriteCount: 0,
    };
  }
  try {
    const url = `/favorites/favorite-state/${bookId}`;
    const favoriteState = await fetchWithAuth<FavoriteState>(url);
    return favoriteState;
  } catch {
    throw new Error('お気に入り情報の読み込みが失敗しました。');
  }
};

export const getNewReleases = async () => {
  try {
    const url = `/books/new-releases`;
    const books = await fetchJSON<Book[]>(url);
    return books;
  } catch {
    throw new Error('ニューリリース一覧の読み込みが失敗しました。');
  }
};

export const getCurrentUser = async () => {
  try {
    const url = `/me`;
    const user = await fetchWithAuth<User>(url);
    return user;
  } catch {
    throw new Error('ユーザー情報の読み込みが失敗しました。');
  }
};

export const getProfileCounts = async () => {
  try {
    const url = `/me/profile-counts`;
    const profieleCounts = await fetchWithAuth<ProfileCounts>(url);
    return profieleCounts;
  } catch {
    throw new Error('ユーザーのプロフィール情報の読み込みが失敗しました。');
  }
};

export const checkNameExists = async (name: string) => {
  try {
    const url = `/check-name-exists?name=${name}`;
    const data = await fetchJSON<CheckNameExists>(url);
    return data.exists;
  } catch {
    return false; // エラーの場合「存在しない」とするのはどうかと思うけどいったんfalse
  }
};

export const getReviewsByBookId = async (bookId: string) => {
  await sleep(2000);

  try {
    const url = `/reviews/book/${bookId}`;
    const reviews = await fetchJSON<Review[]>(url);
    return reviews;
  } catch {
    throw new Error('レビュー一覧の読み込みが失敗しました。');
  }
};

const fetchJSON = async <T>(url: string, options: RequestInit = {}): Promise<T> => {
  const res = await fetch(`${BOOKS_API_ENDPOINT}${url}`, options);
  if (!res.ok) {
    throw new Error(`失敗しました。URL: ${url} ステータス: ${res.status}`);
  }
  return res.json();
};

------------------------------------------------------------
favorites

import BookListFavorites from '@/components/book-list/book-list-favorites';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import { useUser } from '@/hooks/use-user';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';

export default function Page() {
  const { user } = useUser();

  if (!user) return null;

  return (
    <>
      <p className="my-2">お気に入り</p>

      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={<BookListSkeleton />}>
          <BookListFavorites page={1} />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}

------------------------------------------------------------
my-lists

import BookListMyLists from '@/components/book-list/book-list-my-lists';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import { useUser } from '@/hooks/use-user';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';

export default function Page() {
  const { user } = useUser();

  if (!user) return null;

  return (
    <>
      <p className="my-2">マイリスト</p>

      <ErrorBoundary fallback={<ErrorElement />}>
        <Suspense fallback={<BookListSkeleton />}>
          <BookListMyLists page={1} />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}

------------------------------------------------------------
profile

import Logo from '@/components/layout/logo';
import ProfileCounts from '@/components/profile-counts';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { useUser } from '@/hooks/use-user';
import ErrorElement from '@/routes/error-element';
import { KeyRoundIcon, MailIcon, UserRoundIcon } from 'lucide-react';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { Link } from 'react-router-dom';

export default function Page() {
  const { user } = useUser();

  if (!user) return null;

  return (
    <div className="my-3 flex flex-col items-center justify-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">プロフィール</p>

      <Card className="w-80 overflow-hidden rounded-3xl sm:w-96">
        <CardHeader className="h-80 w-full bg-gradient-to-tr from-secondary to-primary">
          <div className="flex flex-col items-center pt-8">
            <Avatar className="mb-4 size-24">
              <AvatarImage
                className="bg-primary"
                src={user.avatarUrl}
                alt="avatar-image"
              />
              <AvatarFallback className="bg-primary text-5xl font-semibold">
                {user.name.slice(0, 1)}
              </AvatarFallback>
            </Avatar>
            <p className="text-xl font-semibold">{user.name}</p>
            <p className="text-sm">{user.email}</p>
          </div>

          <ErrorBoundary fallback={<ErrorElement />}>
            <Suspense fallback={null}>
              <ProfileCounts />
            </Suspense>
          </ErrorBoundary>
        </CardHeader>

        <CardContent className="relative p-6">
          <ul>
            <li className="flex items-center p-2">
              <UserRoundIcon className="mr-4" />
              <p>ユーザー情報</p>
              <div className="flex-1"></div>
              <Button className="rounded-full bg-transparent" variant="outline" asChild>
                <Link to="/settings/change-user-info">変更</Link>
              </Button>
            </li>
            <li className="flex items-center p-2">
              <MailIcon className="mr-4" />
              <p>メールアドレス</p>
              <div className="flex-1"></div>
              <Button className="rounded-full bg-transparent" variant="outline" asChild>
                <Link to="/settings/change-email">変更</Link>
              </Button>
            </li>
            <li className="flex items-center p-2">
              <KeyRoundIcon className="mr-4" />
              <p>パスワード</p>
              <div className="flex-1"></div>
              <Button className="rounded-full bg-transparent" variant="outline" asChild>
                <Link to="/settings/change-password">変更</Link>
              </Button>
            </li>
          </ul>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
user-provider

import { getCurrentUser } from '@/lib/data';
import { User } from '@/types/user';
import { createContext, useEffect, useState } from 'react';

type UserContextType = {
  user: User | null;
  setUser: (user: User | null) => void;
};

const UserContext = createContext<UserContextType | undefined>(undefined);

const UserProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    const initializeUser = async () => {
      if (!user) {
        const currentUser = await getCurrentUser();
        setUser(currentUser);
      }
    };

    initializeUser();
  }, [user]);

  return (
    <UserContext.Provider value={{ user, setUser }}>{children}</UserContext.Provider>
  );
};

export { UserContext, UserProvider };

------------------------------------------------------------
book

export interface Book {
  id: string;
  title: string;
  description: string;
  genreIds: number[];
  authors: string[];
  publisher: string;
  publishedDate: string;
  price: number;
  pageCount: number;
  isbn: string;
  imageUrl: string;
}

export interface PaginatedBook {
  page: number;
  totalPages: number;
  totalItems: number;
  books: Book[];
}

export interface BookDetail {
  id: string;
  title: string;
  description: string;
  genreIds: number[];
  authors: string[];
  publisher: string;
  publishedDate: string;
  price: number;
  pageCount: number;
  isbn: string;
  imageUrl: string;

  favoriteCount: number;
  myListCount: number;
  reviewCount: number;
  rating: number;
}

export interface Genre {
  id: number;
  name: string;
}

export interface FavoriteState {
  isFavorite: boolean;
  favoriteCount: number;
}

------------------------------------------------------------
review

import { SimpleUserInfo } from '@/types/user';

export interface Review {
  id: number;
  comment: string;
  rating: number;
  updatedAt: string;
  user: SimpleUserInfo;
}

export interface ReviewRequest {
  bookId: string;
  comment: string;
  rating: number;
}

------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------


