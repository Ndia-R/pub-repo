３９ファイル

------------------------------------------------------------
book-detail-skeleton

import { Skeleton } from '@/components/ui/skeleton';

export default function BookDetailSkeleton() {
  return (
    <>
      <div className="flex flex-col justify-center p-3 pt-10 sm:p-6 lg:flex-row">
        <div className="flex flex-col items-center justify-center lg:w-1/2">
          <Skeleton className="h-[360px] w-[280px] rounded bg-muted-foreground/5 object-cover sm:h-[480px] sm:w-[360px]" />
          <div className="mt-2 flex flex-col items-center sm:w-[440px]">
            <div className="my-1 flex justify-center gap-x-10">
              <Skeleton className="size-8 rounded-full bg-muted-foreground/5" />
              <Skeleton className="size-8 rounded-full bg-muted-foreground/5" />
            </div>
            <div className="flex items-center gap-x-2">
              <Skeleton className="mt-2 h-6 w-48 rounded-full bg-muted-foreground/5" />
            </div>
          </div>
          <div className="my-4 flex items-center">
            <Skeleton className="h-11 w-48 rounded-full bg-muted-foreground/5" />
          </div>
        </div>

        <div className="p-4 lg:w-1/2">
          <div className="text-3xl font-bold sm:text-4xl">
            <Skeleton className="h-9 w-64 rounded-full bg-muted-foreground/5 sm:h-10" />
          </div>
          <div className="my-4 flex w-full flex-wrap items-center justify-end gap-x-3">
            <Skeleton className="h-7 w-24 rounded-full bg-muted-foreground/5 sm:h-8" />
          </div>

          <div className="flex gap-x-2">
            <Skeleton className="h-9 w-24 rounded-full bg-muted-foreground/5" />
            <Skeleton className="h-9 w-24 rounded-full bg-muted-foreground/5" />
          </div>

          <div className="my-6 md:my-10">
            <Skeleton className="my-2 h-6 w-full rounded-full bg-muted-foreground/5" />
            <Skeleton className="my-2 h-6 w-full rounded-full bg-muted-foreground/5" />
            <Skeleton className="my-2 h-6 w-full rounded-full bg-muted-foreground/5" />
          </div>

          <div className="flex flex-col justify-between gap-y-4 lg:flex-row">
            <div className="flex flex-col gap-y-1 text-muted-foreground">
              <div className="flex">
                <Skeleton className="mb-1 h-5 w-48 rounded-full bg-muted-foreground/5" />
              </div>
              <div className="flex">
                <Skeleton className="mb-1 h-5 w-36 rounded-full bg-muted-foreground/5" />
              </div>
              <div className="flex">
                <Skeleton className="mb-1 h-5 w-44 rounded-full bg-muted-foreground/5" />
              </div>
              <div className="flex">
                <Skeleton className="mb-1 h-5 w-36 rounded-full bg-muted-foreground/5" />
              </div>
              <div className="flex">
                <Skeleton className="mb-1 h-5 w-32 rounded-full bg-muted-foreground/5" />
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
}

------------------------------------------------------------
book-detail

import FavoriteButton from '@/components/favorite-button';
import GenreList from '@/components/genre-list/genre-list';
import Rating from '@/components/rating';
import ReviewCommentButton from '@/components/review-comment-count';
import { Button } from '@/components/ui/button';
import { getBookById, getGenres, getReviewSummary } from '@/lib/data';
import { formatDateJP, formatIsbn, priceToString } from '@/lib/util';
import { useSuspenseQueries } from '@tanstack/react-query';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
};

export default function BookDetail({ bookId }: Props) {
  const [{ data: book }, { data: reviewRatingInfo }, { data: genres }] =
    useSuspenseQueries({
      queries: [
        {
          queryKey: ['getBookById', bookId],
          queryFn: () => getBookById(bookId),
        },
        {
          queryKey: ['getReviewSummary', bookId],
          queryFn: () => getReviewSummary(bookId),
        },
        {
          queryKey: ['getGenres'],
          queryFn: () => getGenres(),
        },
      ],
    });

  return (
    <div className="flex flex-col justify-center p-3 pt-10 sm:p-6 lg:flex-row">
      <div className="flex flex-col items-center justify-center lg:w-1/2">
        <div className="delay-0 duration-500 animate-in fade-in-0 slide-in-from-top-10 fill-mode-both">
          <img
            className="h-[360px] rounded object-cover sm:h-[480px]"
            src={book.imageUrl}
            alt={book.title}
          />
        </div>
        <div className="delay-150 duration-500 animate-in fade-in-0 slide-in-from-bottom-10">
          <div className="mt-2 flex flex-col items-center sm:w-[440px]">
            <div className="flex justify-center gap-x-10">
              <ReviewCommentButton bookId={bookId} countUpAnimation={true} />
              <FavoriteButton bookId={bookId} countUpAnimation={true} />
            </div>
            <div className="flex items-center gap-x-2">
              <Rating rating={reviewRatingInfo.averageRating} readOnly />
            </div>
          </div>
        </div>
        <div className="delay-300 duration-500 animate-in fade-in-0 slide-in-from-bottom-10 fill-mode-both">
          <div className="my-4 flex items-center">
            <Button className="w-48 rounded-full" size="lg" asChild>
              <Link to={`/book/${bookId}/read/1`}>読む</Link>
            </Button>
          </div>
        </div>
      </div>

      <div className="p-4 lg:w-1/2">
        <div className="delay-150 duration-500 animate-in fade-in-0 slide-in-from-right-10 fill-mode-both">
          <p className="text-3xl font-bold sm:text-4xl">{book.title}</p>

          <div className="my-4 flex w-full flex-wrap items-center justify-end gap-x-3">
            <p>著者</p>
            {book.authors.map((author) => (
              <p className="text-lg font-bold sm:text-2xl" key={author}>
                {author}
              </p>
            ))}
          </div>
        </div>
        <div className="delay-300 duration-500 animate-in fade-in-0 slide-in-from-right-10 fill-mode-both">
          <GenreList
            className="gap-2"
            genres={genres}
            filterList={book.genreIds}
            variant="outline"
          />

          <div className="my-6 md:my-10">{book.description}</div>

          <div className="flex flex-col justify-between gap-y-4 lg:flex-row">
            <div className="flex flex-col gap-y-1 text-muted-foreground">
              <div className="flex">
                <p className="min-w-20">ISBN</p>
                <p>{formatIsbn(book.isbn)}</p>
              </div>
              <div className="flex">
                <p className="min-w-20">出版社</p>
                <p>{book.publisher}</p>
              </div>
              <div className="flex">
                <p className="min-w-20">発売日</p>
                <p className="tracking-wide">{formatDateJP(book.publishedDate)}</p>
              </div>
              <div className="flex">
                <p className="min-w-20">ページ数</p>
                <p>{`${book.pageCount}ページ`}</p>
              </div>
              <div className="flex">
                <p className="min-w-20">価格</p>
                <p>{priceToString(book.price)}</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
book-list-by-genre-id

import BookList from '@/components/book-list/book-list';
import BookPagination from '@/components/book-list/book-pagination';
import { getBookPageByGenreId } from '@/lib/data';
import { useSuspenseQuery } from '@tanstack/react-query';

type Props = {
  genreId: string;
  page: number;
};

export default function BookListByGenreId({ genreId, page }: Props) {
  const { data: paginatedBook } = useSuspenseQuery({
    queryKey: ['getBookPageByGenreId', genreId, page],
    queryFn: () => getBookPageByGenreId(genreId, page - 1),
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <BookPagination totalPages={paginatedBook.totalPages} />
      <BookList books={paginatedBook.books} />
      <BookPagination totalPages={paginatedBook.totalPages} />
    </div>
  );
}

------------------------------------------------------------
book-list-by-query

import BookList from '@/components/book-list/book-list';
import BookPagination from '@/components/book-list/book-pagination';
import { getBookPageByQuery } from '@/lib/data';
import { useSuspenseQuery } from '@tanstack/react-query';

type Props = {
  query: string;
  page: number;
};

export default function BookListByQuery({ query, page }: Props) {
  const { data: paginatedBook } = useSuspenseQuery({
    queryKey: ['getBookPageByQuery', query, page],
    queryFn: () => getBookPageByQuery(query, page - 1),
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <BookPagination totalPages={paginatedBook.totalPages} />
      <BookList books={paginatedBook.books} />
      <BookPagination totalPages={paginatedBook.totalPages} />
    </div>
  );
}

------------------------------------------------------------
book-list-favorites

import BookList from '@/components/book-list/book-list';
import BookPagination from '@/components/book-list/book-pagination';
import { getFavoritePage } from '@/lib/data';
import { useSuspenseQuery } from '@tanstack/react-query';

type Props = {
  page: number;
};

export default function BookListFavorites({ page }: Props) {
  const { data: bookPage } = useSuspenseQuery({
    queryKey: ['getFavoritePage', page],
    queryFn: () => getFavoritePage(page - 1),
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <BookPagination totalPages={bookPage.totalPages} />
      <BookList books={bookPage.favorites.map((favorite) => favorite.book)} />
      <BookPagination totalPages={bookPage.totalPages} />
    </div>
  );
}

------------------------------------------------------------
book-list-new-releases

import BookList from '@/components/book-list/book-list';
import { getNewBooks } from '@/lib/data';
import { useSuspenseQuery } from '@tanstack/react-query';

export default function BookListNewReleases() {
  const { data: books } = useSuspenseQuery({
    queryKey: ['getNewBooks'],
    queryFn: () => getNewBooks(),
  });

  return (
    <div className="pb-4">
      <BookList books={books} />
    </div>
  );
}

------------------------------------------------------------
review-create-dialog

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { createReview } from '@/lib/action';
import { ReviewRequest } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import React, { useEffect, useRef, useState } from 'react';

type Props = {
  bookId: string;
  queryKey: unknown[];
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
};

export default function ReviewCreateDialog({
  bookId,
  queryKey,
  isOpen,
  setIsOpen,
}: Props) {
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const queryClient = useQueryClient();
  const { mutate } = useMutation({
    mutationFn: (reqestBody: ReviewRequest) => createReview(bookId, reqestBody),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
      queryClient.invalidateQueries({ queryKey: ['getReviewSummary', bookId] });
    },
  });

  useEffect(() => {
    if (isOpen) {
      setRating(0);
      setComment('');
    }
  }, [isOpen]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handlePost = async () => {
    if (rating === 0) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: 'このまま投稿しますか？',
        message: '星の数が「0」のままです。',
        actionLabel: '投稿する',
      });
      if (isCancel) return;
    }

    const requestBody: ReviewRequest = { comment, rating };
    mutate(requestBody, {
      onSuccess: () => {
        toast({ description: 'レビューを投稿しました' });
        setIsOpen(false);
      },
      onError: () => {
        toast({
          title: 'レビュー投稿に失敗しました',
          description: '管理者へ連絡してください',
          variant: 'destructive',
          duration: 5000,
        });
        setIsOpen(false);
      },
    });
  };

  const handleCloseDialog = async () => {
    if (comment) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: '本当に閉じますか？',
        message: 'コメントはまだ投稿していません。',
        actionLabel: '閉じる',
        persistent: true,
      });
      if (isCancel) return;
    }
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
        onAnimationStart={handleAnimationStart}
      >
        <div className="flex items-start justify-between">
          <div>
            <p className="font-semibold leading-10">レビュー</p>
            <p className="text-xs text-muted-foreground sm:text-sm">
              素敵な感想を伝えましょう！
            </p>
          </div>
          <div>
            <Rating rating={rating} onChange={setRating} />
            <p className="text-center text-xs text-muted-foreground sm:text-sm">
              星をクリックして決定
            </p>
          </div>
        </div>

        <Textarea
          ref={ref}
          spellCheck={false}
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />

        <DialogFooter>
          <Button className="rounded-full" variant="ghost" onClick={handleCloseDialog}>
            閉じる
          </Button>
          <Button
            className="rounded-full"
            disabled={comment === '' ? true : false}
            onClick={handlePost}
          >
            投稿する
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
review-item

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/review-list/review-update-dialog';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { useUser } from '@/hooks/use-user';
import { deleteReview } from '@/lib/action';
import { formatDateJP, formatTime } from '@/lib/util';
import { Review } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';

type Props = {
  review: Review;
  bookId: string;
  queryKey: unknown[];
};

export default function ReviewItem({ review, bookId, queryKey }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const { user } = useUser();
  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const queryClient = useQueryClient();
  const { mutate } = useMutation({
    mutationFn: (bookId: string) => deleteReview(bookId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
      queryClient.invalidateQueries({ queryKey: ['getReviewSummary', bookId] });
    },
  });

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: '!',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除する',
    });
    if (isCancel) return;

    mutate(bookId, {
      onSuccess: () => {
        toast({ description: 'レビューを削除しました' });
      },
    });
  };

  return (
    <div className="p-4">
      <div className="flex flex-col items-center justify-between sm:flex-row">
        <div className="flex w-full items-center gap-x-4">
          <Avatar className="size-16">
            <AvatarImage
              className="bg-primary/50"
              src={review.user.avatarUrl}
              alt="avatar-image"
            />
            <AvatarFallback className="font-semibold">
              {review.user.name.slice(0, 1)}
            </AvatarFallback>
          </Avatar>
          <div>
            <p className="-mb-1 text-lg font-semibold">{review.user.name}</p>
            <div className="flex items-center">
              <p className="whitespace-nowrap text-sm leading-8 tracking-wide text-muted-foreground">
                {formatDateJP(review.updatedAt)} {formatTime(review.updatedAt)}
              </p>
              <div className="ml-2 flex w-16">
                {user?.id === review.user.id && (
                  <>
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      onClick={() => user && setIsOpen(true)}
                    >
                      <SquarePenIcon className="size-4" />
                    </Button>
                    <ReviewUpdateDialog
                      bookId={bookId}
                      review={review}
                      queryKey={queryKey}
                      isOpen={isOpen}
                      setIsOpen={setIsOpen}
                    />
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      onClick={handleClickDelete}
                    >
                      <Trash2Icon className="size-4" />
                    </Button>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
        <Rating rating={review.rating} readOnly />
      </div>
      <p className="mt-2 text-muted-foreground sm:pl-20">{review.comment}</p>
    </div>
  );
}

------------------------------------------------------------
review-list

import { Pagination } from '@/components/pagination';
import ReviewCreateDialog from '@/components/review-list/review-create-dialog';
import ReviewItem from '@/components/review-list/review-item';
import { Button } from '@/components/ui/button';
import { Separator } from '@/components/ui/separator';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useUser } from '@/hooks/use-user';
import { checkMyReviewExists, getReviewPage } from '@/lib/data';
import { useSuspenseQuery } from '@tanstack/react-query';
import { useState } from 'react';

type Props = {
  bookId: string;
};

export default function ReviewList({ bookId }: Props) {
  const [page, setPage] = useState(1);
  const [isOpen, setIsOpen] = useState(false);
  const { user } = useUser();

  const queryKey = ['ReviewList', 'checkMyReviewExists', bookId, page, user?.id];
  const {
    data: [paginatedReview, reviewExists],
  } = useSuspenseQuery({
    queryKey,
    queryFn: () =>
      Promise.all([
        getReviewPage(bookId, page - 1),
        checkMyReviewExists(bookId, user?.id),
      ]),
  });

  return (
    <div className="mx-auto w-full lg:w-3/4">
      <div className="flex flex-col-reverse items-center justify-end gap-y-4 sm:flex-row sm:gap-x-4 sm:px-6">
        <p>レビュー {paginatedReview.totalItems} 件</p>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              className="w-44 rounded-full bg-transparent"
              variant="outline"
              disabled={reviewExists}
              onClick={() => user && setIsOpen(true)}
            >
              {reviewExists ? 'レビュー済み' : 'レビューする'}
            </Button>
          </TooltipTrigger>
          {!user && (
            <TooltipContent>
              ログインしてこの本の「レビュー」を書きましょう
            </TooltipContent>
          )}
        </Tooltip>
        <ReviewCreateDialog
          bookId={bookId}
          queryKey={queryKey}
          isOpen={isOpen}
          setIsOpen={setIsOpen}
        />
      </div>

      <ul className="flex flex-col p-3 sm:p-6">
        {paginatedReview.reviews.map((review) => (
          <li key={review.userId}>
            <Separator className="bg-foreground/10" />
            <ReviewItem review={review} bookId={bookId} queryKey={queryKey} />
          </li>
        ))}
      </ul>

      <div className="mb-4 flex justify-center">
        {paginatedReview.totalPages > 1 && (
          <Pagination
            total={paginatedReview.totalPages}
            page={page}
            onChangePage={setPage}
          />
        )}
      </div>
    </div>
  );
}

------------------------------------------------------------
review-update-dialog

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/hooks/use-toast';
import { updateReview } from '@/lib/action';
import { Review, ReviewRequest } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import React, { useEffect, useRef, useState } from 'react';

type Props = {
  bookId: string;
  review: Review;
  queryKey: unknown[];
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
};

export default function ReviewUpdateDialog({
  bookId,
  review,
  queryKey,
  isOpen,
  setIsOpen,
}: Props) {
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { toast } = useToast();

  const queryClient = useQueryClient();
  const { mutate } = useMutation({
    mutationFn: (reqestBody: ReviewRequest) => updateReview(bookId, reqestBody),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
      queryClient.invalidateQueries({ queryKey: ['getReviewSummary', bookId] });
    },
  });

  useEffect(() => {
    if (isOpen) {
      setRating(review.rating);
      setComment(review.comment);
    }
  }, [isOpen, review.comment, review.rating]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handlePost = async () => {
    const requestBody: ReviewRequest = { comment, rating };
    mutate(requestBody, {
      onSuccess: () => {
        toast({ description: 'レビューを投稿しました' });
        setIsOpen(false);
      },
      onError: () => {
        toast({
          title: 'レビュー投稿に失敗しました',
          description: '管理者へ連絡してください',
          variant: 'destructive',
          duration: 5000,
        });
        setIsOpen(false);
      },
    });
  };

  const handleCloseDialog = async () => {
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
        onAnimationStart={handleAnimationStart}
      >
        <div className="flex items-start justify-between">
          <div>
            <p className="font-semibold leading-10">レビュー</p>
            <p className="text-xs text-muted-foreground sm:text-sm">
              素敵な感想を伝えましょう！
            </p>
          </div>
          <div>
            <Rating rating={rating} onChange={setRating} />
            <p className="text-center text-xs text-muted-foreground sm:text-sm">
              星をクリックして決定
            </p>
          </div>
        </div>

        <Textarea
          ref={ref}
          spellCheck={false}
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />

        <DialogFooter>
          <Button className="rounded-full" variant="ghost" onClick={handleCloseDialog}>
            閉じる
          </Button>
          <Button
            className="rounded-full"
            disabled={comment === '' ? true : false}
            onClick={handlePost}
          >
            投稿する
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
favorite-button

import CountUpNumber from '@/components/count-up-number';
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useUser } from '@/hooks/use-user';
import { createFavorite, deleteFavorite } from '@/lib/action';
import { getFavoriteInfo } from '@/lib/data';
import { cn } from '@/lib/util';
import { FavoriteInfo, FavoriteRequest } from '@/types';
import { useMutation, useQueryClient, useSuspenseQuery } from '@tanstack/react-query';
import { HeartIcon } from 'lucide-react';

const BUTTON_SIZE = { sm: 'size-6', md: 'size-8' };
const ICON_SIZE = { sm: 'size-3', md: 'size-4' };
const TEXT_SIZE = { sm: 'text-xs', md: 'text-sm' };

type Props = {
  bookId: string;
  size?: 'sm' | 'md';
  countUpAnimation?: boolean;
};

export default function FavoriteButton({
  bookId,
  size = 'md',
  countUpAnimation = false,
}: Props) {
  const { user } = useUser();
  const queryClient = useQueryClient();

  const queryKey = ['getFavoriteInfo', bookId, user?.id];
  const { data: favoriteInfo } = useSuspenseQuery({
    queryKey,
    queryFn: () => getFavoriteInfo(bookId, user?.id),
  });

  const { mutate, variables, isPending } = useMutation({
    mutationFn: async (newFavorite: FavoriteInfo) => {
      if (newFavorite.isFavorite) {
        const requestBody: FavoriteRequest = { bookId };
        await createFavorite(requestBody);
      } else {
        await deleteFavorite(bookId);
      }
    },
    onMutate: async (newFavoriteInfo: FavoriteInfo) => {
      await queryClient.cancelQueries({ queryKey });
      const previousFavoriteInfo = queryClient.getQueryData(queryKey);
      queryClient.setQueryData(queryKey, newFavoriteInfo);
      return { previousFavoriteInfo };
    },
    onSettled: (_newFavoriteInfo, error, _variables, context) => {
      if (error) {
        queryClient.setQueryData(queryKey, context?.previousFavoriteInfo);
      }
      queryClient.invalidateQueries({ queryKey });
    },
  });

  const handleClick = () => {
    if (!user) return;

    const newFavoriteInfo: FavoriteInfo = {
      isFavorite: !favoriteInfo.isFavorite,
      favoriteCount: favoriteInfo.isFavorite
        ? favoriteInfo.favoriteCount - 1
        : favoriteInfo.favoriteCount + 1,
    };
    mutate(newFavoriteInfo);
  };

  const optimisticData = isPending ? variables : favoriteInfo;

  return (
    <div className="flex items-center">
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className={cn(
              'rounded-full text-muted-foreground',
              BUTTON_SIZE[size],
              optimisticData?.isFavorite && 'text-primary bg-transparent'
            )}
            variant="ghost"
            size="icon"
            onClick={handleClick}
          >
            <HeartIcon
              className={ICON_SIZE[size]}
              style={{
                fill: optimisticData?.isFavorite ? 'hsl(var(--primary))' : '',
              }}
            />
          </Button>
        </TooltipTrigger>
        {user ? (
          <TooltipContent>
            {optimisticData?.isFavorite ? 'お気に入りから削除' : 'お気に入りに追加'}
          </TooltipContent>
        ) : (
          <TooltipContent>
            ログインしてこの本を「お気に入り」に加えましょう
          </TooltipContent>
        )}
      </Tooltip>

      <p
        className={cn(
          'flex min-w-4 text-muted-foreground justify-center',
          TEXT_SIZE[size]
        )}
      >
        {countUpAnimation ? (
          <CountUpNumber end={optimisticData?.favoriteCount || 0} />
        ) : (
          optimisticData?.favoriteCount
        )}
      </p>
    </div>
  );
}

------------------------------------------------------------
review-comment-count

import CountUpNumber from '@/components/count-up-number';
import { getReviewSummary } from '@/lib/data';
import { cn } from '@/lib/util';
import { useQuery } from '@tanstack/react-query';
import { MessageSquareIcon } from 'lucide-react';

const BUTTON_SIZE = { sm: 'size-6', md: 'size-8' };
const ICON_SIZE = { sm: 'size-3', md: 'size-4' };
const TEXT_SIZE = { sm: 'text-xs', md: 'text-sm' };

type Props = {
  bookId: string;
  size?: 'sm' | 'md';
  countUpAnimation?: boolean;
};

export default function ReviewCommentCount({
  bookId,
  size = 'md',
  countUpAnimation = false,
}: Props) {
  const queryKey = ['getReviewSummary', bookId];
  const { data: reviewRatingInfo } = useQuery({
    queryKey,
    queryFn: () => getReviewSummary(bookId),
  });

  return (
    <div className="flex items-center">
      <div
        className={cn(
          'rounded-full text-muted-foreground flex justify-center items-center',
          BUTTON_SIZE[size]
        )}
      >
        <MessageSquareIcon className={ICON_SIZE[size]} />
      </div>

      <p
        className={cn(
          'flex min-w-4 text-muted-foreground justify-center',
          TEXT_SIZE[size]
        )}
      >
        {countUpAnimation ? (
          <CountUpNumber end={reviewRatingInfo?.reviewCount || 0} />
        ) : (
          reviewRatingInfo?.reviewCount
        )}
      </p>
    </div>
  );
}

------------------------------------------------------------
bookmark

import { fetchActionWithAuth } from '@/lib/auth';
import { BookmarkRequest } from '@/types';

export const createBookmark = async (reqestBody: BookmarkRequest) => {
  try {
    const url = `/me/bookmarks`;
    const options: RequestInit = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(reqestBody),
    };
    await fetchActionWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const updateBookmark = async (reqestBody: BookmarkRequest) => {
  try {
    const url = `/me/bookmarks`;
    const options: RequestInit = {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(reqestBody),
    };
    await fetchActionWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const deleteBookmark = async (bookId: string) => {
  try {
    const url = `/me/bookmarks/${bookId}`;
    const options: RequestInit = { method: 'DELETE' };
    await fetchActionWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

------------------------------------------------------------
favorite

import { fetchActionWithAuth } from '@/lib/auth';
import { FavoriteRequest } from '@/types';

export const createFavorite = async (reqestBody: FavoriteRequest) => {
  try {
    const url = `/me/favorites`;
    const options: RequestInit = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(reqestBody),
    };
    await fetchActionWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const deleteFavorite = async (bookId: string) => {
  try {
    const url = `/me/favorites/${bookId}`;
    const options: RequestInit = { method: 'DELETE' };
    await fetchActionWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

------------------------------------------------------------
review

import { fetchActionWithAuth } from '@/lib/auth';
import { ReviewRequest } from '@/types';

export const createReview = async (bookId: string, reqestBody: ReviewRequest) => {
  try {
    const url = `/books/${bookId}/reviews`;
    const options: RequestInit = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(reqestBody),
    };
    await fetchActionWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const updateReview = async (bookId: string, reqestBody: ReviewRequest) => {
  try {
    const url = `/books/${bookId}/reviews`;
    const options: RequestInit = {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(reqestBody),
    };
    await fetchActionWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const deleteReview = async (bookId: string) => {
  try {
    const url = `/books/${bookId}/reviews`;
    const options: RequestInit = { method: 'DELETE' };
    await fetchActionWithAuth(url, options);
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

------------------------------------------------------------
book-chapter

import { fetchJsonWithAuth } from '@/lib/auth';
import { BookTableOfContents } from '@/types';

export const getBookTableOfContents = async (bookId: string) => {
  try {
    const url = `/book/${bookId}/table-of-contents`;
    const bookTableOfContents = await fetchJsonWithAuth<BookTableOfContents>(url);
    return bookTableOfContents;
  } catch {
    throw new Error('書籍の目次の読み込みが失敗しました。');
  }
};

------------------------------------------------------------
book-content-page

import { fetchJsonWithAuth } from '@/lib/auth';
import { BookContentPage } from '@/types';

export const getBookContentPage = async (
  bookId: string,
  chapterNumber: number,
  pageNumber: number
) => {
  try {
    const url = `/books/${bookId}/chapters/${chapterNumber}/pages/${pageNumber}`;
    const bookContentPage = await fetchJsonWithAuth<BookContentPage>(url);
    return bookContentPage;
  } catch {
    throw new Error('書籍のページ情報の読み込みが失敗しました。');
  }
};

------------------------------------------------------------
book

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { fetchJson } from '@/lib/data';
import { Book, BookPage } from '@/types';

export const getBookById = async (bookId: string) => {
  try {
    const url = `/books/${bookId}`;
    const book = await fetchJson<Book>(url);
    return book;
  } catch {
    throw new Error('書籍情報の読み込みが失敗しました。');
  }
};

export const getBookPageByQuery = async (q: string, page: number = 0) => {
  try {
    const url = `/books/search?q=${q}&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
    const bookPage = await fetchJson<BookPage>(url);
    return bookPage;
  } catch {
    throw new Error('書籍検索が失敗しました。');
  }
};

export const getBookPageByGenreId = async (genreIdsQuery: string, page: number = 0) => {
  try {
    // 「|」はそのまま渡すとエラーになるので、URLエンコードする
    const encodedParams = genreIdsQuery.replace(/\|/g, encodeURIComponent('|'));

    const url = `/books/discover?genreId=${encodedParams}&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
    const bookPage = await fetchJson<BookPage>(url);
    return bookPage;
  } catch {
    throw new Error('ジャンル検索が失敗しました。');
  }
};

export const getNewBooks = async () => {
  try {
    const url = `/books/new-books`;
    const books = await fetchJson<Book[]>(url);
    return books;
  } catch {
    throw new Error('ニューリリース一覧の読み込みが失敗しました。');
  }
};

------------------------------------------------------------
bookmark

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { fetchJsonWithAuth } from '@/lib/auth';
import { Bookmark, BookmarkPage } from '@/types';

export const getBookmarkPage = async (page: number = 0) => {
  try {
    const url = `/me/bookmarks?&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
    const bookmarkPage = await fetchJsonWithAuth<BookmarkPage>(url);
    return bookmarkPage;
  } catch {
    throw new Error('ブックマーク一覧の読み込みが失敗しました。');
  }
};

export const getBookmarkById = async (bookId: string) => {
  try {
    const url = `/me/bookmarks/${bookId}`;
    const bookmark = await fetchJsonWithAuth<Bookmark>(url);
    return bookmark;
  } catch {
    throw new Error('ブックマークの読み込みが失敗しました。');
  }
};

------------------------------------------------------------
favorite

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { fetchJsonWithAuth } from '@/lib/auth';
import { fetchJson } from '@/lib/data';
import { Favorite, FavoriteInfo, FavoritePage } from '@/types';

export const getFavoritePage = async (page: number = 0) => {
  try {
    const url = `/me/favorites?&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
    const favoritePage = await fetchJsonWithAuth<FavoritePage>(url);
    return favoritePage;
  } catch {
    throw new Error('お気に入り一覧の読み込みが失敗しました。');
  }
};

export const getFavoriteById = async (bookId: string) => {
  try {
    const url = `/me/favorites/${bookId}`;
    const favorite = await fetchJsonWithAuth<Favorite>(url);
    return favorite;
  } catch {
    throw new Error('お気に入りの読み込みが失敗しました。');
  }
};

export const getFavoriteInfo = async (bookId: string, userId: number | undefined) => {
  try {
    const query = userId ? `?userId=${userId}` : '';
    const url = `/books/${bookId}/favorites${query}`;
    const favoriteInfo = await fetchJson<FavoriteInfo>(url);
    return favoriteInfo;
  } catch {
    throw new Error('お気に入り情報の読み込みが失敗しました。');
  }
};

------------------------------------------------------------
index

import { BOOKS_API_ENDPOINT } from '@/constants/constants';

export * from './book';
export * from './book-chapter';
export * from './book-content-page';
export * from './bookmark';
export * from './favorite';
export * from './genre';
export * from './review';
export * from './user';

export const fetchJson = async <T>(
  url: string,
  options: RequestInit = {}
): Promise<T> => {
  const res = await fetch(`${BOOKS_API_ENDPOINT}${url}`, options);
  if (!res.ok) {
    throw new Error(`失敗しました。URL: ${url} ステータス: ${res.status}`);
  }
  return res.json();
};

------------------------------------------------------------
review

import { FETCH_REVIEWS_MAX_RESULTS } from '@/constants/constants';
import { fetchJson } from '@/lib/data';
import { Review, ReviewPage, ReviewSummary } from '@/types';

export const getReviewPage = async (bookId: string, page: number = 0) => {
  try {
    const url = `/books/${bookId}/reviews?&page=${page}&maxResults=${FETCH_REVIEWS_MAX_RESULTS}`;
    const reviewPage = await fetchJson<ReviewPage>(url);
    return reviewPage;
  } catch {
    throw new Error('レビュー一覧の読み込みが失敗しました。');
  }
};

export const getReviewSummary = async (bookId: string) => {
  try {
    const url = `/books/${bookId}/reviews/summary`;
    const reviewSummary = await fetchJson<ReviewSummary>(url);
    return reviewSummary;
  } catch {
    throw new Error('レビュー情報の読み込みが失敗しました。');
  }
};

export const checkMyReviewExists = async (bookId: string, userId: number | undefined) => {
  if (!userId) return false;

  try {
    const url = `/books/${bookId}/reviews/${userId}`;
    await fetchJson<Review>(url);
    return true;
  } catch {
    return false;
  }
};

------------------------------------------------------------
page

import BookReading from '@/components/book-reading/book-reading';
import ErrorElement from '@/routes/error-element';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { useParams } from 'react-router-dom';

export default function Page() {
  const params = useParams();
  const bookId = params.bookId || '';
  const chapterNumber = Number(params.chapterNumber) || 0;
  const pageNumber = Number(params.pageNumber) || 1;

  console.log(bookId, chapterNumber, pageNumber);

  return (
    <ErrorBoundary fallback={<ErrorElement />}>
      <Suspense fallback={<div>Loading...</div>}>
        <BookReading
          bookId={bookId}
          chapterNumber={chapterNumber}
          pageNumber={pageNumber}
        />
      </Suspense>
    </ErrorBoundary>
  );
}

------------------------------------------------------------
route

import BookContentPagePage from '@/routes/book/[bookId]/chapters/[chapterNumber]/pages/[pageNumber]/page';
import BookDetailPage from '@/routes/book/[bookId]/page';
import DiscoverPage from '@/routes/discover/page';
import FavoritesPage from '@/routes/favorites/page';
import RootLayout from '@/routes/layout';
import LoginPage from '@/routes/login/page';
import RootPage from '@/routes/page';
import { ProtectedRoute } from '@/routes/protected-route';
import SearchPage from '@/routes/search/page';
import ChangeEmailPage from '@/routes/settings/change-email/page';
import ChangePasswordPage from '@/routes/settings/change-password/page';
import ChangeUserInfoPage from '@/routes/settings/change-user-info/page';
import ProfilePage from '@/routes/settings/profile/page';
import SignupPage from '@/routes/signup/page';
import { createBrowserRouter, createRoutesFromElements, Route } from 'react-router-dom';

export const router = createBrowserRouter(
  createRoutesFromElements(
    <Route>
      <Route path="/" element={<RootLayout />}>
        <Route index element={<RootPage />} />

        <Route path="book">
          <Route path=":bookId" element={<BookDetailPage />} />
          <Route
            path=":bookId/chapters/:chapterNumber/pages/:pageNumber"
            element={<BookContentPagePage />}
          />
        </Route>

        <Route path="search">
          <Route index element={<SearchPage />} />
        </Route>

        <Route path="discover">
          <Route index element={<DiscoverPage />} />
        </Route>

        <Route path="login">
          <Route index element={<LoginPage />} />
        </Route>

        <Route path="signup">
          <Route index element={<SignupPage />} />
        </Route>

        <Route element={<ProtectedRoute />}>
          <Route path="favorites">
            <Route index element={<FavoritesPage />} />
          </Route>

          <Route path="settings">
            <Route path="profile" element={<ProfilePage />} />
            <Route path="change-user-info" element={<ChangeUserInfoPage />} />
            <Route path="change-email" element={<ChangeEmailPage />} />
            <Route path="change-password" element={<ChangePasswordPage />} />
          </Route>
        </Route>
      </Route>
    </Route>
  )
);

------------------------------------------------------------
book-content-page

export interface BookContentPage {
  bookId: string;
  chapterNumber: number;
  chapterTitle: string;
  pageNumber: number;
  content: string;
}

------------------------------------------------------------
book

export interface Book {
  id: string;
  title: string;
  description: string;
  genreIds: number[];
  authors: string[];
  publisher: string;
  publishedDate: string;
  price: number;
  pageCount: number;
  isbn: string;
  imageUrl: string;
}

export interface BookPage {
  page: number;
  totalPages: number;
  totalItems: number;
  books: Book[];
}

------------------------------------------------------------
bookmark

import { Book } from '@/types/book';

export interface Bookmark {
  userId: number;
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
  updatedAt: string;
  book: Book;
}

export interface BookmarkPage {
  page: number;
  totalPages: number;
  totalItems: number;
  bookmarks: Bookmark[];
}

export interface BookmarkRequest {
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
}

------------------------------------------------------------
favorite

import { Book } from '@/types/book';

export interface Favorite {
  userId: number;
  bookId: string;
  updatedAt: string;
  book: Book;
}

export interface FavoritePage {
  page: number;
  totalPages: number;
  totalItems: number;
  favorites: Favorite[];
}

export interface FavoriteInfo {
  isFavorite: boolean;
  favoriteCount: number;
}

export interface FavoriteRequest {
  bookId: string;
}

------------------------------------------------------------
index

export * from './auth';
export * from './book';
export * from './book-chapter';
export * from './book-content-page';
export * from './bookmark';
export * from './favorite';
export * from './genre';
export * from './review';
export * from './user';

------------------------------------------------------------
review

import { SimpleUserInfo } from '@/types';

export interface Review {
  userId: number;
  bookId: string;
  comment: string;
  rating: number;
  createdAt: string;
  updatedAt: string;
  user: SimpleUserInfo;
}

export interface ReviewPage {
  page: number;
  totalPages: number;
  totalItems: number;
  reviews: Review[];
}

export interface ReviewSummary {
  bookId: string;
  reviewCount: number;
  averageRating: number;
}

export interface ReviewRequest {
  comment: string;
  rating: number;
}

------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------

