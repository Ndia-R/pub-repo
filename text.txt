--------------------------------------------------
devcontainer.json

{
  "name": "my-books-app",
  "dockerComposeFile": ["../docker-compose.yml", "docker-compose.yml"],
  "service": "app",
  "workspaceFolder": "/app",
  "customizations": {
    "vscode": {
      "extensions": [
        "formulahendry.auto-rename-tag",
        "streetsidesoftware.code-spell-checker",
        "dsznajder.es7-react-js-snippets",
        "dbaeumer.vscode-eslint",
        "mhutchie.git-graph",
        "ecmel.vscode-html-css",
        "oderwat.indent-rainbow",
        "PKief.material-icon-theme",
        "christian-kohler.path-intellisense",
        "esbenp.prettier-vscode",
        "bradlc.vscode-tailwindcss",
        "shardulm94.trailing-spaces",
        "mosapride.zenkaku"
      ]
    }
  }
}

--------------------------------------------------
settings.json

{
  // globals.cssの「@tailwind」の警告の波線を消す
  "files.associations": {
    "*.css": "tailwindcss"
  },

  // ミニマップを非表示にする
  "editor.minimap.enabled": false,

  // 制御文字を表示する
  "editor.renderControlCharacters": true,

  // デフォルトのフォーマットはprettierを指定
  "editor.defaultFormatter": "esbenp.prettier-vscode",

  // ファイル保存時にPrettierでフォーマット
  "editor.formatOnSave": true,

  // ファイル保存時
  "editor.codeActionsOnSave": {
    "source.organizeImports": "explicit", // 未使用のimport文を削除し、import文の順番を並べ替え
    "source.fixAll.eslint": "explicit" // ESLintに対応しているファイルはESLintでフォーマット
  },

  // 改行コードの規定値
  "files.eol": "\n",

  // ファイル保存時に行末に改行を挿入
  "files.insertFinalNewline": true,

  // ファイル保存時に最終行以降の空行を削除
  "files.trimFinalNewlines": true,

  // ファイル保存時に各行の末尾にある半角スペースを削除
  "files.trimTrailingWhitespace": true,

  // 絶対パスでAuto Importを行う（tsconfig.jsonに構成されているbseUrlまたはpathsに基づいて非相対インポートを優先）
  "typescript.preferences.importModuleSpecifier": "non-relative",

  // スペルチェックの対象外にするワード
  "cSpell.words": [
    "bradlc",
    "clsx",
    "dbaeumer",
    "Devcontainer",
    "dsznajder",
    "ecmel",
    "esbenp",
    "formulahendry",
    "kohler",
    "lucide",
    "mhutchie",
    "mosapride",
    "oderwat",
    "shadcn",
    "shardulm",
    "tailwindcss",
    "tseslint",
    "zenkaku"
  ]
}

--------------------------------------------------
public/images/no-image.png

--------------------------------------------------
book-list-skeleton.tsx

import Card from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { FETCH_BOOKS_MAX_RESULTS } from '@/lib/data';

export default function BookListSkeleton() {
  return (
    <>
      <div className="flex flex-col gap-y-4 pb-4">
        <div className="flex justify-center">
          <Skeleton className="size-8 rounded-full" />
          <Skeleton className="size-8 rounded-full" />
          <Skeleton className="size-8 rounded-full" />
        </div>

        <ul className="grid grid-cols-2 justify-items-center gap-2 sm:grid-cols-3 sm:gap-3 md:grid-cols-4 lg:grid-cols-5">
          {[...Array<number>(FETCH_BOOKS_MAX_RESULTS)].map((_, index) => (
            <li key={index}>
              <Card className="relative flex w-40 flex-col gap-2 p-4 sm:w-48 sm:p-5">
                <Skeleton className="z-0 h-44 w-32 rounded object-cover sm:h-52 sm:w-36" />
                <div className="flex w-full flex-col items-center gap-y-3">
                  <Skeleton className="h-3 w-4/5 rounded-lg" />
                  <Skeleton className="h-3 w-4/5 rounded-lg" />
                </div>
              </Card>
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

--------------------------------------------------
genre-list/

genre-list-skeleton.tsx

import { Skeleton } from '@/components/ui/skeleton';

export default function GenreListSkeleton() {
  return (
    <ul className="flex flex-wrap">
      {[...Array<number>(12)].map(() => (
        <li className="p-1">
          <Skeleton className="h-10 w-24 rounded-full" />
        </li>
      ))}
    </ul>
  );
}

--------------------------------------------------
genre-list.tsx

import Button from '@/components/ui/button';
import { Genre } from '@/types/book';

type Props = {
  genres: Genre[];
};

export default function GenreList({ genres }: Props) {
  return (
    <ul className="flex flex-wrap">
      {genres.map((genre) => (
        <li className="p-1">
          <Button className="rounded-full" variant="outline">
            {genre.name}
          </Button>
        </li>
      ))}
    </ul>
  );
}

--------------------------------------------------
search-pagination.tsx

import Pagination from '@/components/ui/pagination';
import { useEffect, useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

type Props = {
  totalPages: number;
};

export default function SearchPagination({ totalPages }: Props) {
  const location = useLocation();
  const navigate = useNavigate();

  const [page, setPage] = useState(1);

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const page = Number(params.get('page') ?? '1');
    setPage(page);
  }, [location.search]);

  const handleChange = (page: number) => {
    setPage(page);
    const params = new URLSearchParams(location.search);
    params.set('page', page.toString());
    navigate(`/search?${params.toString()}`);
  };

  return (
    <div className="flex justify-center">
      <Pagination total={totalPages} page={page} onChangePage={handleChange} />
    </div>
  );
}

--------------------------------------------------
lib/data.ts

// import { getUser } from '@/lib/auth';
// import prisma from '@/lib/db';
import { Book, BookResponse, FavoriteBook, Genre } from '@/types/book';
import {
  MyBooksApiBook,
  MyBooksApiBookResponse,
  MyBooksApiGenre,
} from '@/types/my-books-api';
// import { Book, FavoriteBook, GoogleApiBook, SearchResponse } from '@/types';

const BOOKS_API_ENDPOINT = 'http://vsv-emerald/my-books';
export const FETCH_BOOKS_MAX_RESULTS = 20;

/**
 * 書籍の検索
 * @param q 全文のクエリ文字列
 * @param page? ページ番号のインデックス（0 から開始）
 * @return Book[]
 */
export const getBooksByQuery = async (q: string | undefined | null, page: number = 0) => {
  if (!q) return [];

  const url = `${BOOKS_API_ENDPOINT}/books/search?q=${q}&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
  const res = await fetch(url);

  if (!res.ok) {
    throw new Error(
      `Failed to fetch data from ${url}. HTTP error! status: ${res.status}`
    );
  }

  const myBookApiBookResponse = (await res.json()) as MyBooksApiBookResponse;

  const bookResponse: BookResponse = {
    page: myBookApiBookResponse.page,
    totalPages: myBookApiBookResponse.totalPages,
    totalItems: myBookApiBookResponse.totalItems,
    books: myBookApiBookResponse.books.map((book) => convertBook(book, [])),
  };

  return bookResponse;

  // const user = getUser();
  // const favoriteBooks = await prisma.favoriteBook.findMany({
  //   where: {
  //     userId: user.id,
  //   },
  // });

  // const books = googleBooksData.items
  //   ? googleBooksData.items.map((item) => convertBook(item, favoriteBooks))
  //   : [];

  // return books;
};

/**
 * １冊分の本の情報を取得
 * @param bookId 取得する書籍のID
 * @return Book
 */
export const getBookById = async (
  bookId: string | undefined
): Promise<Book | undefined> => {
  if (!bookId) return undefined;

  const url = `${BOOKS_API_ENDPOINT}/books/${bookId}`;
  const res = await fetch(url);

  if (!res.ok) {
    throw new Error(
      `Failed to fetch data from ${url}. HTTP error! status: ${res.status}`
    );
  }

  const myBooksApiBook = (await res.json()) as MyBooksApiBook;
  const book = convertBook(myBooksApiBook, []);
  return book;

  // const user = getUser();
  // const favoriteBooks = await prisma.favoriteBook.findMany({
  //   where: {
  //     userId: user.id,
  //   },
  // });

  // const book = convertBook(googleBooksData, favoriteBooks);

  // return book;
};

/**
 * ジャンル一覧の取得
 * @return Genre[]
 */
export const getGenres = async () => {
  const url = `${BOOKS_API_ENDPOINT}/genres`;
  const res = await fetch(url);

  if (!res.ok) {
    throw new Error(
      `Failed to fetch data from ${url}. HTTP error! status: ${res.status}`
    );
  }

  const myBooksApiGenres = (await res.json()) as MyBooksApiGenre[];

  // MyBooksApiGenre型からGenre型へ変換（今は必要ないが今後の拡張のため）
  const genres: Genre[] = myBooksApiGenres.map((genre) => genre);

  return genres;
};

/**
 * お気に入り一覧取得
 * @return Book[]
 */
export const fetchFavorites = async () => {
  // const user = getUser();
  // const favorites = await prisma.favoriteBook.findMany({
  //   where: {
  //     userId: user.id,
  //   },
  //   orderBy: {
  //     createdAt: 'desc',
  //   },
  // });
  // const books = favorites.map((favorite) => ({
  //   id: favorite.bookId,
  //   title: favorite.title,
  //   imageUrl: favorite.imageUrl,
  //   authors: [],
  //   publisher: '',
  //   publishedDate: '',
  //   description: '',
  //   webReaderLink: '',
  //   pageCount: 0,
  //   price: 0,
  //   isFavorite: true,
  // }));
  // return books;
};

/**
 * 閲覧履歴一覧取得
 * @return Book[]
 */
export const getBrowsingHistory = async () => {
  // const user = getUser();
  // const histories = await prisma.bookBrowsingHistory.findMany({
  //   where: {
  //     userId: user.id,
  //   },
  //   orderBy: {
  //     createdAt: 'desc',
  //   },
  // });
  // const favorites = await prisma.favoriteBook.findMany({
  //   where: {
  //     userId: user.id,
  //   },
  //   select: {
  //     bookId: true,
  //   },
  // });
  // const books = histories.map((history) => ({
  //   id: history.bookId,
  //   title: history.title,
  //   imageUrl: history.imageUrl,
  //   authors: [],
  //   publisher: '',
  //   publishedDate: '',
  //   description: '',
  //   webReaderLink: '',
  //   pageCount: 0,
  //   price: 0,
  //   isFavorite: favorites.find((favorite) => favorite.bookId === history.bookId)
  //     ? true
  //     : false,
  // }));
  // return books;
};

/**
 * My Books API のレスポンスをBookへ変換
 * @param myBooksData My Books API のレスポンス
 * @param favoriteBooks お気に入り一覧
 * @returns Book
 */
const convertBook = (
  myBooksData: MyBooksApiBook,
  favoriteBooks: FavoriteBook[]
): Book => {
  return {
    id: myBooksData.id,
    title: myBooksData.title,
    description: myBooksData.description ?? '',
    genreIds: myBooksData.genreIds,
    authors: myBooksData.authors,
    publisher: myBooksData.publisher ?? '',
    publishedDate: myBooksData.publishedDate,
    price: myBooksData.price ?? 0,
    pageCount: myBooksData.pageCount ?? 0,
    isbn: myBooksData.isbn ?? '',
    imageUrl: myBooksData.imageUrl ?? '/images/no-image.png',

    // isFavorite: favoriteBooks.find((favorite) => favorite.bookId === googleBooksData.id)
    //   ? true
    //   : false,

    isFavorite: Math.random() > 0.5,
  };
};

// import { Book } from '@/types/book';
// import { GoogleApiBook, SearchResponse } from '@/types/google-books-api';

// const BOOKS_API_ENDPOINT = 'https://www.googleapis.com/books/v1';
// const FETCH_BOOKS_MAX_RESULTS = 20;

// /**
//  * 書籍の検索
//  * https://developers.google.com/books/docs/v1/reference/volumes/list?hl=ja
//  * @param q 全文のクエリ文字列
//  * @param startIndex? 最初に返される結果のインデックス（0 から開始）
//  * @return Book[]
//  */
// export const getBooksByQuery = async (
//   q: string | undefined | null,
//   startIndex: number = 0
// ) => {
//   if (!q) return [];

//   const url = `${BOOKS_API_ENDPOINT}/volumes?q=${q}&startIndex=${startIndex}&maxResults=${FETCH_BOOKS_MAX_RESULTS}&langRestrict=ja`;

//   const res = await fetch(url);

//   if (!res.ok) {
//     throw new Error(
//       `Failed to fetch data from ${url}. HTTP error! status: ${res.status}`
//     );
//   }

//   const googleBooksData = (await res.json()) as SearchResponse;

//   const books = googleBooksData.items
//     ? googleBooksData.items.map((item) => convertBook(item))
//     : [];

//   return books;
// };

// /**
//  * １冊分の本の情報を取得
//  * https://developers.google.com/books/docs/v1/reference/volumes/get?hl=ja
//  * @param volumeId 取得するボリュームの ID
//  * @return Book
//  */
// export const getBookById = async (
//   volumeId: string | undefined
// ): Promise<Book | undefined> => {
//   if (!volumeId) return undefined;

//   const url = `${BOOKS_API_ENDPOINT}/volumes/${volumeId}`;

//   const res = await fetch(url);

//   if (!res.ok) {
//     throw new Error(
//       `Failed to fetch data from ${url}. HTTP error! status: ${res.status}`
//     );
//   }

//   const googleBooksData = (await res.json()) as GoogleApiBook;

//   const book = convertBook(googleBooksData);

//   return book;
// };

// /**
//  * Google Books API のレスポンスをBookへ変換
//  * @param googleBooksData Google Books API のレスポンス
//  * @returns Book
//  */
// const convertBook = (googleBooksData: GoogleApiBook): Book => {
//   return {
//     id: googleBooksData.id,
//     title: googleBooksData.volumeInfo.title,
//     imageUrl:
//       googleBooksData.volumeInfo.imageLinks?.thumbnail ??
//       new URL(`src/assets/no-image.png`, import.meta.url).href,
//     authors: googleBooksData.volumeInfo.authors,
//     publisher: googleBooksData.volumeInfo.publisher ?? '',
//     publishedDate: googleBooksData.volumeInfo.publishedDate,
//     description: googleBooksData.volumeInfo.description ?? '',
//     webReaderLink: googleBooksData.accessInfo.webReaderLink,
//     pageCount: googleBooksData.volumeInfo.pageCount ?? 0,
//     price: googleBooksData.saleInfo.retailPrice?.amount ?? 0,
//   };
// };

--------------------------------------------------
routes/search/page.tsx

import BookList from '@/components/book-list/book-list';
import BookListEmpty from '@/components/book-list/book-list-empty';
import BookListSkeleton from '@/components/book-list/book-list-skeleton';
import SearchPagination from '@/components/search-pagination';
import { getBooksByQuery } from '@/lib/data';
import { BookResponse } from '@/types/book';
import { Suspense } from 'react';
import {
  Await,
  LoaderFunctionArgs,
  ScrollRestoration,
  useAsyncError,
  useLoaderData,
} from 'react-router-dom';

type LoaderFunctionReturnType = {
  bookResponse: Promise<BookResponse>;
  query: string;
  page: number;
};

const loader = ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const query = url.searchParams.get('q');

  const page = Number(url.searchParams.get('page') ?? '1');
  const bookResponse = getBooksByQuery(query, page - 1);

  return { bookResponse, query, page };
};

const ErrorElement = () => {
  const error = useAsyncError();
  console.log(error);

  return <BookListEmpty />;
};

export default function Page() {
  const { bookResponse, query } = useLoaderData() as LoaderFunctionReturnType;

  return (
    <>
      <p className="my-2 text-sm text-muted-foreground">{`「 ${query} 」の検索結果`}</p>

      <div className="flex flex-col gap-y-4 pb-4">
        <Suspense fallback={<BookListSkeleton />}>
          <Await resolve={bookResponse} errorElement={<ErrorElement />}>
            {(resolvedBookResponse: BookResponse) => (
              <>
                <SearchPagination totalPages={resolvedBookResponse.totalPages} />
                <BookList books={resolvedBookResponse.books} />
                <SearchPagination totalPages={resolvedBookResponse.totalPages} />
              </>
            )}
          </Await>
        </Suspense>
      </div>

      <ScrollRestoration />
    </>
  );
}

Page.loader = loader;

--------------------------------------------------
routes/
page.tsx

import GenreList from '@/components/genre-list/genre-list';
import GenreListSkeleton from '@/components/genre-list/genre-list-skeleton';
import Hero from '@/components/layout/hero';
import { getGenres } from '@/lib/data';
import { Genre } from '@/types/book';
import { Suspense } from 'react';
import { Await, useAsyncError, useLoaderData } from 'react-router-dom';

type LoaderFunctionReturnType = {
  genres: Promise<Genre[]>;
};

const loader = () => {
  const genres = getGenres();
  return { genres };
};

const ErrorElement = () => {
  const error = useAsyncError();
  console.log(error);

  return <div>ジャンル取得失敗</div>;
};

export default function Page() {
  const { genres } = useLoaderData() as LoaderFunctionReturnType;

  return (
    <>
      <Hero />

      <div className="flex flex-col gap-y-2">
        <p>ジャンルから探す</p>
        <Suspense fallback={<GenreListSkeleton />}>
          <Await resolve={genres} errorElement={<ErrorElement />}>
            {(resolvedGenres: Genre[]) => <GenreList genres={resolvedGenres} />}
          </Await>
        </Suspense>
      </div>

      <p>
        Lorem ipsum dolor sit amet consectetur adipisicing elit. Non aliquam sed excepturi
        iusto eaque accusamus eos architecto. Quidem ducimus cupiditate qui quas porro
        saepe hic, quae cumque vero enim eveniet! Similique excepturi possimus tenetur!
        Debitis, ipsum sequi aperiam magnam veritatis sit vitae alias quaerat dicta?
        Facilis possimus dolorem eum culpa totam doloremque impedit beatae voluptatem
        tempore perspiciatis, laborum alias in neque amet, autem rerum numquam ipsa libero
        veniam. Harum possimus alias nam optio consectetur neque perferendis, non
        veritatis aut a enim dolor mollitia, doloremque voluptatum aliquam, vero quasi
        illo voluptas. Dolores pariatur magnam culpa quidem doloremque provident adipisci
        quod consectetur quia fugit, voluptas molestias, necessitatibus dolor veritatis
        nostrum nobis iste assumenda. Nesciunt ex, quod ut porro iste voluptate ipsum
        natus quae, dolore sit vel et distinctio sint? Obcaecati, ducimus, delectus nisi
        est ipsum perspiciatis perferendis cupiditate libero fugit temporibus dicta quasi
        aliquid eius corrupti id maiores quibusdam, cumque et quo! Perferendis quae a
        fugit mollitia ea? Nesciunt harum libero non praesentium earum doloremque nobis
        alias saepe deleniti, et, veniam quibusdam minima. Minus neque vel, placeat
        dolorem aliquid delectus asperiores quasi distinctio dolor ipsa eum perspiciatis
        aspernatur repudiandae explicabo cupiditate, nihil aliquam iusto corporis
        pariatur. Dolorem est sequi expedita tempore asperiores, autem culpa saepe porro
        error alias, blanditiis aliquam hic quas laboriosam, debitis necessitatibus eius
        aperiam sunt tenetur dolor. Nostrum expedita iste, saepe, laboriosam, cum culpa
        natus beatae ullam quam tempore aliquid doloribus perspiciatis quibusdam magni?
        Eaque officiis ad consequatur in unde voluptatum saepe. Aliquam excepturi, natus
        eveniet accusamus doloremque obcaecati sit fugit neque deserunt soluta optio alias
        cupiditate earum molestiae dolore nihil error laborum. Nostrum cum totam
        exercitationem alias suscipit! Officia voluptate omnis accusamus doloremque ad
        adipisci minima, recusandae expedita reprehenderit? Hic debitis sint quos iste
        ullam cumque dolorum nisi libero illo obcaecati alias repellendus optio itaque
        placeat eaque soluta voluptatem dignissimos corporis reprehenderit aspernatur eum,
        blanditiis quis. Ipsa iste optio modi expedita similique itaque sunt harum
        consequuntur veniam? Id, atque, tempora non velit nisi illo excepturi incidunt
        quos necessitatibus consequatur tenetur sunt quibusdam quo iste quas dolore. Quam
        enim ad odit ut saepe eum quibusdam repudiandae commodi molestias molestiae natus
        fugit velit, in quis. Reiciendis nemo aliquam delectus eos consectetur
        voluptatibus, ducimus iure voluptas? Quas, ullam? Tenetur in repellendus
        distinctio repudiandae sunt optio rem necessitatibus iusto, delectus dolorum est
        fugit? Nostrum sint pariatur numquam, sunt ullam quod libero facere fugit beatae
        cumque. Provident nihil veniam odit eum natus labore voluptates corporis illo
        distinctio rerum dolores amet quibusdam, dolore deserunt est doloremque facere
        exercitationem neque quas! Quos placeat iusto, eveniet nemo vitae inventore soluta
        velit dolor dignissimos optio temporibus nobis dolorum cumque consectetur ducimus
        nam maxime nesciunt eaque! Tempora debitis quas architecto dolore! Dolorem est
        dolores, necessitatibus velit ratione earum doloribus, libero voluptates vel nam
        laboriosam. Beatae, fugiat rerum quis repellendus, possimus iusto fugit quidem,
        culpa et officia repellat deleniti quia deserunt cum repudiandae quo laborum eum
        libero modi enim obcaecati. Aut alias, esse temporibus recusandae culpa nisi
        magnam, ex voluptatem provident nulla autem ut facere voluptates rem eveniet
        aspernatur velit laudantium ea? Vero eum commodi earum, qui dolores error repellat
        fuga nostrum quia ducimus voluptatum eos blanditiis, laboriosam aliquam voluptates
        expedita aspernatur obcaecati dicta suscipit? Laudantium dolores minus adipisci
        iusto nostrum, repudiandae officiis hic blanditiis! Exercitationem dolorum sit,
        ex, eius vel animi maxime accusantium suscipit excepturi, numquam praesentium
        corporis corrupti ea id deserunt quibusdam dolor explicabo nulla magnam?
        Accusamus, excepturi tempora. Quo non distinctio provident ullam, rem alias sequi
        modi quae animi dolorum soluta numquam quaerat? Accusantium nobis nam esse
        obcaecati quia ut harum! Id provident deleniti tempore, repellat dolorum unde, ab
        sit, voluptatem necessitatibus excepturi suscipit in maiores natus ipsam doloribus
        nobis laborum laboriosam. Voluptatum animi adipisci saepe magni soluta ut. Aut
        deserunt corporis eum sunt harum maiores ut sapiente pariatur! Sed consequuntur
        est, earum reprehenderit debitis hic nesciunt! Sed fugiat commodi accusantium
        eaque, deserunt officia, sequi suscipit unde repellat aliquam rerum iure possimus
        optio nam, nihil tempora voluptas! Placeat molestias eius labore officia numquam
        inventore dicta in aperiam reprehenderit ipsum dolorum deserunt pariatur expedita
        suscipit modi delectus, ea iure dolore. Vero suscipit perspiciatis, alias ipsa,
        aliquid quas nesciunt ad totam recusandae accusantium, asperiores labore. Tempore,
        enim nihil accusamus dicta delectus explicabo, provident aut iure dolorum rem
        temporibus reiciendis cum consequuntur sunt cumque quae, ratione non soluta esse
        voluptate eius. Totam unde sit, quod ab odio maxime at, eveniet dicta sequi rem
        veritatis, nisi odit quisquam voluptatem dolor vitae corrupti et. Sint eligendi
        laudantium hic atque alias nulla, nemo, neque ipsa perspiciatis praesentium ipsam
        quas ducimus ratione repudiandae sapiente quibusdam voluptatum? Commodi,
        voluptatibus officiis. Explicabo laborum voluptates officia dolor maiores ipsam
        nam officiis. Ipsum sapiente consequuntur hic earum molestiae enim ducimus placeat
        recusandae! Magnam, dicta consectetur sapiente omnis culpa quos officia
        perferendis ducimus, non voluptatem, eius sint! Sint, culpa provident, officiis
        laudantium dolore, quia maiores saepe nostrum sapiente consequuntur accusantium
        iste assumenda expedita ullam eaque. Eligendi sapiente eos, placeat accusantium
        nobis cupiditate, dignissimos, aliquam dolorum adipisci et debitis atque delectus
        at magnam nemo minima facere nihil rem eum libero quia. Optio expedita unde iusto
        assumenda voluptatum nesciunt, illo possimus rerum hic quam quis laboriosam earum
        nihil explicabo quo. Excepturi asperiores commodi ipsam laboriosam, eum labore
        ratione aliquam perspiciatis earum doloremque fuga necessitatibus fugit aperiam,
        corporis similique, sapiente reprehenderit ad ea laborum iste dolores reiciendis
        harum vitae? Error omnis minima nobis quisquam facere impedit accusamus ducimus
        sequi pariatur voluptatem quia quo veniam numquam ipsum fugit illum nulla sapiente
        dolorum nihil rem quae, voluptates doloremque dolores. Atque, quisquam nisi veniam
        ad dolorem deserunt voluptatem tenetur velit voluptatibus error voluptates
        distinctio aspernatur molestias libero beatae earum quibusdam odit adipisci quam
        corporis sapiente? Voluptatem impedit culpa hic recusandae eaque tenetur ratione
        necessitatibus laborum. Quod ipsa, sequi vero minus magni et delectus fugiat,
        quasi dolorum nihil voluptates dolor voluptatum totam vel beatae in nam eum magnam
        libero illum autem! Officia earum dicta rerum corporis, nemo, delectus nam tempora
        recusandae ea fuga illum et reprehenderit modi quidem ab aliquam magnam sint
        eaque. Saepe quo dicta possimus iure labore perspiciatis sunt totam magni
        aspernatur impedit.
      </p>
    </>
  );
}

Page.loader = loader;

--------------------------------------------------
route.tsx

import BookIdNotFound from '@/routes/book/[bookId]/not-found';
import BookIdPage from '@/routes/book/[bookId]/page';
import FavoritesPage from '@/routes/favorite/page';
import RootLayout from '@/routes/layout';
import RootPage from '@/routes/page';
import SearchPage from '@/routes/search/page';
import SettingsPage from '@/routes/settings/page';
import { createBrowserRouter, createRoutesFromElements, Route } from 'react-router-dom';

export const router = createBrowserRouter(
  createRoutesFromElements(
    <Route>
      <Route path="/" element={<RootLayout />}>
        <Route index element={<RootPage />} loader={RootPage.loader} />

        <Route path="book">
          <Route
            path=":bookId"
            element={<BookIdPage />}
            loader={BookIdPage.loader}
            errorElement={<BookIdNotFound />}
          />
        </Route>

        <Route path="favorites">
          <Route index element={<FavoritesPage />} />
        </Route>

        <Route path="settings">
          <Route index element={<SettingsPage />} />
        </Route>

        <Route path="search">
          <Route index element={<SearchPage />} loader={SearchPage.loader} />
        </Route>
      </Route>
    </Route>
  )
);

--------------------------------------------------
--------------------------------------------------
--------------------------------------------------
