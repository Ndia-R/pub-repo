２５ファイル

------------------------------------------------------------
bookmark-create-dialog.tsx

import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/hooks/use-toast';
import { BookmarkCreateMutation, BookmarkRequest } from '@/types';
import { useEffect, useState } from 'react';

type Props = {
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  createMutation?: BookmarkCreateMutation;
};

export default function BookmarkCreateDialog({
  bookId,
  chapterNumber,
  pageNumber,
  isOpen,
  setIsOpen,
  createMutation,
}: Props) {
  const [note, setNote] = useState('');

  const { toast } = useToast();

  useEffect(() => {
    if (isOpen) {
      setNote('');
    }
  }, [isOpen]);

  const handleCreate = () => {
    const requestBody: BookmarkRequest = {
      bookId,
      chapterNumber,
      pageNumber,
      note,
    };
    createMutation?.mutate(requestBody, {
      onSuccess: () => {
        toast({ title: 'ブックマークを作成しました' });
        setIsOpen(false);
      },
      onError: () => {
        toast({
          title: 'ブックマークの作成に失敗しました',
          description: '管理者へ連絡してください。',
          variant: 'destructive',
          duration: 5000,
        });
        setIsOpen(false);
      },
    });
  };

  const handleCloseDialog = () => {
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
      >
        <div>
          <p className="font-semibold leading-10">ブックマーク</p>
          <p className="text-xs text-muted-foreground sm:text-sm">
            このブックマークにメモを残せます。メモが未入力でもブックマーク登録できます。
          </p>
        </div>

        <Textarea
          spellCheck={false}
          value={note}
          onChange={(e) => setNote(e.currentTarget.value)}
        />

        <DialogFooter className="gap-y-4 sm:gap-y-0">
          <Button
            className="min-w-24 rounded-full"
            variant="ghost"
            onClick={handleCloseDialog}
          >
            キャンセル
          </Button>
          <Button className="min-w-24 rounded-full" onClick={handleCreate}>
            作成
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
bookmark-item.tsx

import BookmarkUpdateDialog from '@/components/bookmarks/bookmark-update-dialog';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { BOOK_IMAGE_BASE_URL } from '@/constants/constants';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { formatDateJP, formatTime } from '@/lib/util';
import {
  Bookmark,
  BookmarkCreateMutation,
  BookmarkDeleteMutation,
  BookmarkUpdateMutation,
} from '@/types';
import { BookmarkIcon, SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';
import { Link } from 'react-router-dom';

type Props = {
  bookmark: Bookmark;
  createMutation?: BookmarkCreateMutation;
  updateMutation?: BookmarkUpdateMutation;
  deleteMutation?: BookmarkDeleteMutation;
};

export default function BookmarkItem({
  bookmark,
  updateMutation,
  deleteMutation,
}: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const handleClickUpdate = () => {
    setIsOpen(true);
  };

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: 'warning',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除',
    });
    if (isCancel) return;

    deleteMutation?.mutate(bookmark.id, {
      onSuccess: () => {
        toast({ title: 'ブックマークを削除しました' });
      },
    });
  };

  return (
    <Card>
      <CardContent>
        <div className="flex gap-x-4 px-3 py-4">
          <div className="flex min-w-20 justify-center sm:min-w-24">
            <Link
              to={`/read/${bookmark.bookId}/chapter/${bookmark.chapterNumber}/page/${bookmark.pageNumber}`}
              className="size-fit"
            >
              <img
                className="h-24 rounded object-cover sm:h-28"
                src={BOOK_IMAGE_BASE_URL + bookmark.book.imagePath}
                alt={bookmark.book.title}
              />
            </Link>
          </div>
          <div className="flex w-full flex-col justify-center">
            <div className="mb-2 flex flex-col items-start gap-x-4 sm:flex-row sm:items-center">
              <Link
                to={`/read/${bookmark.bookId}/chapter/${bookmark.chapterNumber}/page/${bookmark.pageNumber}`}
                className="size-fit"
              >
                <p className="text-base font-semibold hover:text-primary sm:text-xl">
                  {bookmark.book.title}
                </p>
              </Link>
              <div className="flex flex-wrap items-center">
                <div className="flex size-8 items-center justify-center">
                  <BookmarkIcon
                    className="size-4 text-primary"
                    style={{ fill: 'hsl(var(--primary))' }}
                  />
                </div>
                <p className="mr-2 whitespace-nowrap text-xs leading-8 tracking-wide text-muted-foreground sm:text-sm">
                  {formatDateJP(bookmark.updatedAt)} {formatTime(bookmark.updatedAt)}
                </p>
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを編集"
                  onClick={handleClickUpdate}
                >
                  <SquarePenIcon className="size-4" />
                </Button>
                <BookmarkUpdateDialog
                  bookmark={bookmark}
                  isOpen={isOpen}
                  setIsOpen={setIsOpen}
                  updateMutation={updateMutation}
                />
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを削除"
                  onClick={handleClickDelete}
                >
                  <Trash2Icon className="size-4" />
                </Button>
              </div>
            </div>
            <p className="mb-4 text-xs text-muted-foreground sm:text-sm">
              第 {bookmark.chapterNumber} 章 : {bookmark.chapterTitle}（
              {bookmark.pageNumber}ページ目）
            </p>
            <p className="text-muted-foreground">
              {bookmark.note && <span>{bookmark.note}</span>}
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
bookmark-update-dialog.tsx

import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import {
  Bookmark,
  BookmarkDeleteMutation,
  BookmarkRequest,
  BookmarkUpdateMutation,
} from '@/types';
import { useEffect, useState } from 'react';
import { useLocation } from 'react-router-dom';

type Props = {
  bookmark: Bookmark;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  updateMutation?: BookmarkUpdateMutation;
  deleteMutation?: BookmarkDeleteMutation;
};

export default function BookmarkUpdateDialog({
  bookmark,
  isOpen,
  setIsOpen,
  updateMutation,
  deleteMutation,
}: Props) {
  const [note, setNote] = useState('');

  const location = useLocation();

  const { confirmDialog } = useConfirmDialog();
  const { toast } = useToast();

  useEffect(() => {
    if (isOpen) {
      setNote(bookmark.note);
    }
  }, [isOpen, bookmark.note]);

  const handleDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: 'warning',
      title: 'このブックマークを削除しますか？',
      message: 'ブックマークのメモも削除されます。',
    });
    if (isCancel) return;

    deleteMutation?.mutate(bookmark.id, {
      onSuccess: () => {
        toast({ title: 'ブックマークを削除しました' });
        setIsOpen(false);
      },
      onError: () => {
        toast({
          title: 'ブックマークの削除に失敗しました',
          description: '管理者へ連絡してください。',
          variant: 'destructive',
          duration: 5000,
        });
        setIsOpen(false);
      },
    });
  };

  const handleUpdate = () => {
    const requestBody: BookmarkRequest = {
      bookId: bookmark.bookId,
      chapterNumber: bookmark.chapterNumber,
      pageNumber: bookmark.pageNumber,
      note,
    };
    updateMutation?.mutate(
      { id: bookmark.id, requestBody },
      {
        onSuccess: () => {
          toast({ title: 'ブックマークのメモを更新しました' });
          setIsOpen(false);
        },
        onError: () => {
          toast({
            title: 'ブックマークのメモを更新に失敗しました',
            description: '管理者へ連絡してください。',
            variant: 'destructive',
            duration: 5000,
          });
          setIsOpen(false);
        },
      }
    );
  };

  const handleCloseDialog = () => {
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
      >
        <div>
          <p className="font-semibold leading-10">ブックマーク</p>
          <p className="text-xs text-muted-foreground sm:text-sm">
            メモを編集できます。メモが未入力でもブックマーク登録は消えません。
          </p>
        </div>

        <Textarea
          spellCheck={false}
          value={note}
          onChange={(e) => setNote(e.currentTarget.value)}
        />

        <DialogFooter className="gap-y-4 sm:gap-y-0">
          <Button
            className="min-w-24 rounded-full"
            variant="ghost"
            onClick={handleCloseDialog}
          >
            キャンセル
          </Button>
          {location.pathname.includes('read') && (
            <Button
              className="min-w-24 rounded-full"
              variant="outline"
              onClick={handleDelete}
            >
              削除
            </Button>
          )}
          <Button className="min-w-24 rounded-full" onClick={handleUpdate}>
            更新
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
my-review-item.tsx

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/reviews/review-update-dialog';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { BOOK_IMAGE_BASE_URL } from '@/constants/constants';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { formatDateJP, formatTime } from '@/lib/util';
import {
  Review,
  ReviewCreateMutation,
  ReviewDeleteMutation,
  ReviewUpdateMutation,
} from '@/types';
import { SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';
import { Link } from 'react-router-dom';

type Props = {
  review: Review;
  createMutation?: ReviewCreateMutation;
  updateMutation?: ReviewUpdateMutation;
  deleteMutation?: ReviewDeleteMutation;
};

export default function MyReviewItem({ review, updateMutation, deleteMutation }: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const handleClickUpdate = () => {
    setIsOpen(true);
  };

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: 'warning',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除',
    });
    if (isCancel) return;

    deleteMutation?.mutate(review.id, {
      onSuccess: () => {
        toast({ title: 'レビューを削除しました' });
      },
    });
  };

  return (
    <Card>
      <CardContent>
        <div className="flex gap-x-4 px-3 py-4">
          <div className="flex min-w-20 justify-center sm:min-w-24">
            <Link to={`/book/${review.book.id}`} className="size-fit">
              <img
                className="h-24 rounded object-cover sm:h-28"
                src={BOOK_IMAGE_BASE_URL + review.book.imagePath}
                alt={review.book.title}
              />
            </Link>
          </div>
          <div className="flex w-full flex-col justify-center">
            <Link to={`/book/${review.book.id}`} className="size-fit">
              <p className="text-base font-semibold hover:text-primary sm:text-xl">
                {review.book.title}
              </p>
            </Link>
            <div className="mb-2 flex flex-col items-start sm:flex-row sm:items-center">
              <div className="mr-2">
                <Rating rating={review.rating} readOnly />
              </div>
              <div className="flex flex-wrap items-center">
                <p className="mr-2 whitespace-nowrap text-xs leading-8 tracking-wide text-muted-foreground sm:text-sm">
                  {formatDateJP(review.updatedAt)} {formatTime(review.updatedAt)}
                </p>
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを編集"
                  onClick={handleClickUpdate}
                >
                  <SquarePenIcon className="size-4" />
                </Button>
                <ReviewUpdateDialog
                  review={review}
                  isOpen={isOpen}
                  setIsOpen={setIsOpen}
                  updateMutation={updateMutation}
                />
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを削除"
                  onClick={handleClickDelete}
                >
                  <Trash2Icon className="size-4" />
                </Button>
              </div>
            </div>
            <p className="text-muted-foreground">{review.comment}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
review-create-dialog.tsx

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { ReviewCreateMutation, ReviewRequest } from '@/types';
import { useEffect, useState } from 'react';

type Props = {
  bookId: string;
  page: number;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  createMutation?: ReviewCreateMutation;
};

export default function ReviewCreateDialog({
  bookId,
  isOpen,
  setIsOpen,
  createMutation,
}: Props) {
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  useEffect(() => {
    if (isOpen) {
      setRating(0);
      setComment('');
    }
  }, [isOpen]);

  const handleClickPost = async () => {
    if (rating === 0) {
      const { isCancel } = await confirmDialog({
        icon: 'question',
        title: 'このまま投稿しますか？',
        message: '星の数が「0」のままです。',
        actionLabel: '投稿',
      });
      if (isCancel) return;
    }

    const requestBody: ReviewRequest = { bookId, comment, rating };
    createMutation?.mutate(requestBody, {
      onSuccess: () => {
        toast({ title: 'レビューを投稿しました' });
        setIsOpen(false);
      },
      onError: () => {
        toast({
          title: 'レビュー投稿に失敗しました',
          description: '管理者へ連絡してください。',
          variant: 'destructive',
          duration: 5000,
        });
        setIsOpen(false);
      },
    });
  };

  const handleClickCancel = async () => {
    if (comment) {
      const { isCancel } = await confirmDialog({
        icon: 'question',
        title: 'キャンセルして閉じますか？',
        message: 'コメントはまだ投稿していません。',
        persistent: true,
      });
      if (isCancel) return;
    }
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleClickCancel}
        onPointerDownOutside={handleClickCancel}
      >
        <div className="flex items-start justify-between">
          <div>
            <p className="font-semibold leading-10">レビュー</p>
            <p className="text-xs text-muted-foreground sm:text-sm">
              素敵な感想を伝えましょう！
            </p>
          </div>
          <div>
            <Rating rating={rating} onChange={setRating} />
            <p className="text-center text-xs text-muted-foreground sm:text-sm">
              星をクリックして決定
            </p>
          </div>
        </div>

        <Textarea
          spellCheck={false}
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />

        <DialogFooter className="gap-y-4 sm:gap-y-0">
          <Button
            className="min-w-24 rounded-full"
            variant="ghost"
            onClick={handleClickCancel}
          >
            キャンセル
          </Button>
          <Button
            className="min-w-24 rounded-full"
            disabled={comment === ''}
            onClick={handleClickPost}
          >
            投稿
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
review-item.tsx

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/reviews/review-update-dialog';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { AVATAR_IMAGE_BASE_URL } from '@/constants/constants';
import { useAuth } from '@/hooks/use-auth';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { formatDateJP, formatTime } from '@/lib/util';
import {
  Review,
  ReviewCreateMutation,
  ReviewDeleteMutation,
  ReviewUpdateMutation,
} from '@/types';
import { SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';

type Props = {
  review: Review;
  createMutation?: ReviewCreateMutation;
  updateMutation?: ReviewUpdateMutation;
  deleteMutation?: ReviewDeleteMutation;
};

export default function ReviewItem({ review, updateMutation, deleteMutation }: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const { user } = useAuth();
  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const handleClickUpdate = () => {
    setIsOpen(true);
  };

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: 'warning',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除',
    });
    if (isCancel) return;

    deleteMutation?.mutate(review.id, {
      onSuccess: () => {
        toast({ title: 'レビューを削除しました' });
      },
    });
  };

  return (
    <div className="delay-0 duration-500 animate-in fade-in-0 slide-in-from-top-2 fill-mode-both">
      <div className="p-4">
        <div className="flex flex-col items-center justify-between sm:flex-row">
          <div className="flex w-full items-center gap-x-4">
            <Avatar className="size-16">
              <AvatarImage
                className="bg-primary/50"
                src={AVATAR_IMAGE_BASE_URL + review.avatarPath}
                alt="avatar-image"
              />
              <AvatarFallback className="font-semibold">
                {review.name.slice(0, 1)}
              </AvatarFallback>
            </Avatar>
            <div>
              <p className="-mb-1 text-lg font-semibold">{review.name}</p>
              <div className="flex items-center">
                <p className="whitespace-nowrap text-sm leading-8 tracking-wide text-muted-foreground">
                  {formatDateJP(review.updatedAt)} {formatTime(review.updatedAt)}
                </p>
                <div className="ml-2 flex w-16">
                  {user?.id === review.userId && (
                    <>
                      <Button
                        className="size-8 rounded-full text-muted-foreground"
                        variant="ghost"
                        size="icon"
                        aria-label="レビューを編集"
                        onClick={handleClickUpdate}
                      >
                        <SquarePenIcon className="size-4" />
                      </Button>
                      <ReviewUpdateDialog
                        review={review}
                        isOpen={isOpen}
                        setIsOpen={setIsOpen}
                        updateMutation={updateMutation}
                      />
                      <Button
                        className="size-8 rounded-full text-muted-foreground"
                        variant="ghost"
                        size="icon"
                        aria-label="レビューを削除"
                        onClick={handleClickDelete}
                      >
                        <Trash2Icon className="size-4" />
                      </Button>
                    </>
                  )}
                </div>
              </div>
            </div>
          </div>
          <Rating rating={review.rating} readOnly />
        </div>
        <p className="mt-2 text-muted-foreground sm:pl-20">{review.comment}</p>
      </div>
    </div>
  );
}

------------------------------------------------------------
review-update-dialog.tsx

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/hooks/use-toast';
import { Review, ReviewRequest, ReviewUpdateMutation } from '@/types';
import { useEffect, useState } from 'react';

type Props = {
  review: Review;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  updateMutation?: ReviewUpdateMutation;
};

export default function ReviewUpdateDialog({
  review,
  isOpen,
  setIsOpen,
  updateMutation,
}: Props) {
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const { toast } = useToast();

  useEffect(() => {
    if (isOpen) {
      setRating(review.rating);
      setComment(review.comment);
    }
  }, [isOpen, review.comment, review.rating]);

  const handleClickUpdate = () => {
    const requestBody: ReviewRequest = { bookId: review.bookId, comment, rating };
    updateMutation?.mutate(
      { id: review.id, requestBody },
      {
        onSuccess: () => {
          toast({ title: 'レビューを更新しました' });
          setIsOpen(false);
        },
        onError: () => {
          toast({
            title: 'レビューの更新に失敗しました',
            description: '管理者へ連絡してください。',
            variant: 'destructive',
            duration: 5000,
          });
          setIsOpen(false);
        },
      }
    );
  };

  const handleClickCancel = async () => {
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleClickCancel}
        onPointerDownOutside={handleClickCancel}
      >
        <div className="flex items-start justify-between">
          <div>
            <p className="font-semibold leading-10">レビュー</p>
            <p className="text-xs text-muted-foreground sm:text-sm">
              レビュー内容を編集できます。
            </p>
          </div>
          <div>
            <Rating rating={rating} onChange={setRating} />
            <p className="text-center text-xs text-muted-foreground sm:text-sm">
              星をクリックして決定
            </p>
          </div>
        </div>

        <Textarea
          spellCheck={false}
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />

        <DialogFooter className="gap-y-4 sm:gap-y-0">
          <Button
            className="min-w-24 rounded-full"
            variant="ghost"
            onClick={handleClickCancel}
          >
            キャンセル
          </Button>
          <Button
            className="min-w-24 rounded-full"
            disabled={comment === ''}
            onClick={handleClickUpdate}
          >
            更新
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
reviews-book-detail.tsx

import ReviewCreateDialog from '@/components/reviews/review-create-dialog';
import ReviewList from '@/components/reviews/review-list';
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useApiReview } from '@/hooks/api/use-api-review';
import { useAuth } from '@/hooks/use-auth';
import { Review, ReviewRequest } from '@/types';
import {
  useMutation,
  useQuery,
  useQueryClient,
  useSuspenseQuery,
} from '@tanstack/react-query';
import { useEffect, useState } from 'react';

type Props = {
  bookId: string;
};

export default function ReviewsBookDetail({ bookId }: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const [currentPage, setCurrentPage] = useState(1);
  const [reviews, setReviews] = useState<Review[]>([]);
  const [totalPages, setTotalPages] = useState(0);

  const { user } = useAuth();
  const {
    getReviewPage,
    checkSelfReviewExists,
    createReview,
    updateReview,
    deleteReview,
  } = useApiReview();

  const { data: initialReviewPage } = useSuspenseQuery({
    queryKey: ['getReviewPage', bookId, 1],
    queryFn: () => getReviewPage(bookId, 1),
  });

  // ログインしていない場合は、enabledオプションを指定して
  // queryFnを呼び出さないようにする（この指定はuseSuspenseQueryでは出来ない模様）
  const { data: reviewExists = false } = useQuery({
    queryKey: ['checkSelfReviewExists', bookId],
    queryFn: () => checkSelfReviewExists(bookId),
    enabled: !!user,
    retry: false,
  });

  const queryClient = useQueryClient();

  const onSuccess = () => {
    queryClient.invalidateQueries({ queryKey: ['getReviewPage', bookId, 1] });
    queryClient.invalidateQueries({ queryKey: ['getBookDetailsById', bookId] });
    queryClient.invalidateQueries({ queryKey: ['checkSelfReviewExists', bookId] });
  };

  const onError = (error: Error) => {
    console.error(error);
  };

  const createMutation = useMutation({
    mutationFn: (requestBody: ReviewRequest) => createReview(requestBody),
    onSuccess,
    onError,
  });

  const updateMutation = useMutation({
    mutationFn: ({ id, requestBody }: { id: number; requestBody: ReviewRequest }) =>
      updateReview(id, requestBody),
    onSuccess,
    onError,
  });

  const deleteMutation = useMutation({
    mutationFn: (id: number) => deleteReview(id),
    onSuccess,
    onError,
  });

  useEffect(() => {
    if (initialReviewPage) {
      setCurrentPage(1);
      setReviews(initialReviewPage.reviews);
      setTotalPages(initialReviewPage.totalPages);
    }
  }, [initialReviewPage]);

  const loadMoreReviews = async () => {
    const nextPage = currentPage + 1;
    const nextReviewPage = await getReviewPage(bookId, nextPage);
    setReviews((prevReviews) => [...prevReviews, ...nextReviewPage.reviews]);
    setCurrentPage(nextPage);
  };

  return (
    <div className="mx-auto w-full pb-4 lg:w-3/4">
      <div className="flex flex-col-reverse items-center justify-end gap-y-4 sm:flex-row sm:gap-x-4 sm:px-6">
        <p>レビュー {initialReviewPage.totalItems} 件</p>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              className="w-44 rounded-full bg-transparent"
              variant="outline"
              disabled={user ? reviewExists : true}
              onClick={() => user && setIsOpen(true)}
            >
              {user && reviewExists ? 'レビュー済み' : 'レビューする'}
            </Button>
          </TooltipTrigger>
          {!user && (
            <TooltipContent>
              ログインしてこの本の「レビュー」を書きましょう
            </TooltipContent>
          )}
        </Tooltip>
        <ReviewCreateDialog
          bookId={bookId}
          page={currentPage}
          isOpen={isOpen}
          setIsOpen={setIsOpen}
          createMutation={createMutation}
        />
      </div>

      <ReviewList
        reviews={reviews}
        updateMutation={updateMutation}
        deleteMutation={deleteMutation}
      />

      {currentPage < totalPages && (
        <div className="flex justify-center">
          <Button
            className="w-44 rounded-full text-muted-foreground"
            variant="ghost"
            onClick={loadMoreReviews}
          >
            もっと見る
          </Button>
        </div>
      )}
    </div>
  );
}

------------------------------------------------------------
dialog.tsx

import { cn } from '@/lib/util';
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';
import ReactDOM from 'react-dom';

interface DialogContextType {
  isOpen: boolean;
  openDialog: () => void;
  closeDialog: () => void;
}

const DialogContext = React.createContext<DialogContextType | undefined>(undefined);

// ----------------------------------------------------------------------------
// Dialog
// ----------------------------------------------------------------------------
interface DialogProps extends React.DialogHTMLAttributes<HTMLDialogElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const Dialog = ({ children, open, onOpenChange }: DialogProps) => {
  // 外部からの状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openDialog = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeDialog = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  return (
    <DialogContext.Provider value={{ isOpen, openDialog, closeDialog }}>
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case DialogTrigger:
            case DialogContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </DialogContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// DialogTrigger
// ----------------------------------------------------------------------------
interface DialogTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const DialogTrigger = React.forwardRef<HTMLButtonElement, DialogTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    const context = useContext(DialogContext);
    if (!context) throw new Error('DialogTrigger must be used within Dialog');

    const { openDialog } = context;

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
        onClick: (e: React.MouseEvent) => {
          children.props.onClick?.(e);
          openDialog();
        },
      };
      return React.cloneElement(children, { ...mergeChildProps, ref });
    }

    const mergeProps = {
      ...props,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        props.onClick?.(e);
        openDialog();
      },
    };

    return (
      <button ref={ref} {...mergeProps}>
        {children}
      </button>
    );
  }
);

// ----------------------------------------------------------------------------
// DialogOverlay
// ----------------------------------------------------------------------------
type DialogOverlayProps = React.HTMLAttributes<HTMLDivElement>;

const DialogOverlay = ({ className, ...props }: DialogOverlayProps) => {
  const context = useContext(DialogContext);
  if (!context) throw new Error('DialogOverlay must be used within Dialog');

  const { isOpen } = context;

  return (
    <div
      className={cn(
        'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
        'fill-mode-both',
        className
      )}
      data-state={isOpen ? 'open' : 'closed'}
      {...props}
    ></div>
  );
};

// ----------------------------------------------------------------------------
// DialogContent
// ----------------------------------------------------------------------------
interface DialogContentProps extends React.HTMLAttributes<HTMLDivElement> {
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
}
const DialogContent = ({
  className,
  children,
  onEscapeKeyDown,
  onPointerDownOutside,
  ...props
}: DialogContentProps) => {
  const context = useContext(DialogContext);
  if (!context) throw new Error('DialogContent must be used within Dialog');

  const { isOpen, closeDialog } = context;
  const [isVisible, setIsVisible] = useState(false);
  const dialogRef = useRef<HTMLDivElement>(null);

  const handleWheel = useCallback((e: WheelEvent) => {
    const isInsideDialog =
      e.target instanceof Node && dialogRef.current?.contains(e.target);

    if (!isInsideDialog) {
      e.preventDefault();
      return;
    }

    let target = e.target as HTMLElement;
    while (target && target !== dialogRef.current) {
      const { overflowY } = window.getComputedStyle(target);
      const isScrollable = overflowY === 'auto' || overflowY === 'scroll';
      const hasScrollableContent = target.scrollHeight > target.clientHeight;

      if (isScrollable && hasScrollableContent) {
        const scrollTop = target.scrollTop;
        const scrollHeight = target.scrollHeight;
        const clientHeight = target.clientHeight;

        if (scrollTop === 0 && e.deltaY < 0) {
          e.preventDefault();
        } else if (scrollTop + clientHeight >= scrollHeight && e.deltaY > 0) {
          e.preventDefault();
        }
        return;
      }
      target = target.parentElement as HTMLElement;
    }

    e.preventDefault();
  }, []);

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (!isOpen) return;

      if (e.key === 'Escape') {
        if (onEscapeKeyDown) {
          onEscapeKeyDown();
        } else {
          closeDialog();
        }
      }
    },
    [closeDialog, isOpen, onEscapeKeyDown]
  );

  useEffect(() => {
    if (isOpen) {
      setIsVisible(true);
      document.addEventListener('wheel', handleWheel, { passive: false });
      document.addEventListener('keydown', handleKeyDown);
    } else {
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    }
    return () => {
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown, handleWheel, isOpen]);

  const handlePointerDownOutside = () => {
    if (onPointerDownOutside) {
      onPointerDownOutside();
    } else {
      closeDialog();
    }
  };

  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit') {
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      props.onAnimationEnd?.(e);
      handleAnimationEnd(e);
    },
  };

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <DialogOverlay onClick={handlePointerDownOutside} />
          <div
            ref={dialogRef}
            className={cn(
              'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
              'fill-mode-both',
              className
            )}
            data-state={isOpen ? 'open' : 'closed'}
            {...mergeProps}
          >
            {children}
          </div>
        </>
      )}
    </>,
    document.body
  );
};

// ----------------------------------------------------------------------------
// DialogHeader
// ----------------------------------------------------------------------------
const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col space-y-1.5 text-center sm:text-left', className)}
    {...props}
  />
);

// ----------------------------------------------------------------------------
// DialogFooter
// ----------------------------------------------------------------------------
const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);

// ----------------------------------------------------------------------------
// DialogTitle
// ----------------------------------------------------------------------------
type DialogTitleProps = React.HTMLAttributes<HTMLDivElement>;
const DialogTitle = React.forwardRef<HTMLDivElement, DialogTitleProps>(
  ({ className, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn('text-lg font-semibold leading-none tracking-tight', className)}
        {...props}
      />
    );
  }
);

// ----------------------------------------------------------------------------
// DialogDescription
// ----------------------------------------------------------------------------
type DialogDescriptionProps = React.HTMLAttributes<HTMLDivElement>;
const DialogDescription = React.forwardRef<HTMLDivElement, DialogDescriptionProps>(
  ({ className, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn('text-sm text-muted-foreground', className)}
        {...props}
      />
    );
  }
);

export {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogTitle,
  DialogTrigger,
};

------------------------------------------------------------
dropdown-menu.tsx

import { cn } from '@/lib/util';
import React, {
  useCallback,
  useContext,
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
} from 'react';
import ReactDOM from 'react-dom';

type DropdownMenuSideType = 'top' | 'right' | 'bottom' | 'left';
type DropdownMenuAlignType = 'start' | 'center' | 'end';

const DEFAULT_SIDE: DropdownMenuSideType = 'bottom';
const DEFAULT_ALIGN: DropdownMenuAlignType = 'center';
const DEFAULT_SIDE_OFFSET = 4;

interface DropdownMenuContextType {
  isOpen: boolean;
  openDropdownMenu: () => void;
  closeDropdownMenu: () => void;
  triggerRef: React.MutableRefObject<HTMLDivElement | HTMLButtonElement | null>;
  focusedIndex: number;
  setFocusedIndex: (index: number) => void;
  itemsRef: React.MutableRefObject<HTMLButtonElement[]>;
}

const DropdownMenuContext = React.createContext<DropdownMenuContextType | undefined>(
  undefined
);

// ----------------------------------------------------------------------------
// DropdownMenu
// ----------------------------------------------------------------------------
interface DropdownMenuProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const DropdownMenu = ({ children, open, onOpenChange }: DropdownMenuProps) => {
  // 外部からの状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const itemsRef = useRef<HTMLButtonElement[]>([]);

  // propsが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openDropdownMenu = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeDropdownMenu = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  const triggerRef = useRef<HTMLDivElement | null>(null);

  return (
    <DropdownMenuContext.Provider
      value={{
        isOpen,
        openDropdownMenu,
        closeDropdownMenu,
        triggerRef,
        focusedIndex,
        setFocusedIndex,
        itemsRef,
      }}
    >
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case DropdownMenuTrigger:
            case DropdownMenuContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </DropdownMenuContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// DropdownMenuTrigger
// ----------------------------------------------------------------------------
interface DropdownMenuTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const DropdownMenuTrigger = React.forwardRef<HTMLButtonElement, DropdownMenuTriggerProps>(
  ({ className, children, asChild = false, ...props }, ref) => {
    const context = useContext(DropdownMenuContext);
    if (!context) throw new Error('DropdownMenuContent must be used within DropdownMenu');

    const { openDropdownMenu, triggerRef } = context;

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
        onClick: (e: React.MouseEvent) => {
          children.props.onClick?.(e);
          openDropdownMenu();
        },
      };
      return (
        <div
          ref={triggerRef as React.MutableRefObject<HTMLDivElement>}
          className={cn('w-fit', className)}
        >
          {React.cloneElement(children, { ...mergeChildProps, ref })}
        </div>
      );
    }
    const mergeProps = {
      ...props,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        props.onClick?.(e);
        openDropdownMenu();
      },
    };

    return (
      <button
        ref={triggerRef as React.MutableRefObject<HTMLButtonElement>}
        className={cn('w-fit', className)}
        {...mergeProps}
      >
        {children}
      </button>
    );
  }
);

// ----------------------------------------------------------------------------
// DropdownMenuContent
// ----------------------------------------------------------------------------
interface DropdownMenuContentProps extends React.HTMLAttributes<HTMLDivElement> {
  side?: DropdownMenuSideType;
  align?: DropdownMenuAlignType;
  sideOffset?: number;
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
}

const DropdownMenuContent = ({
  children,
  className,
  side = DEFAULT_SIDE,
  align = DEFAULT_ALIGN,
  sideOffset = DEFAULT_SIDE_OFFSET,
  onEscapeKeyDown,
  onPointerDownOutside,
  ...props
}: DropdownMenuContentProps) => {
  const context = useContext(DropdownMenuContext);
  if (!context) throw new Error('DropdownMenuContent must be used within DropdownMenu');

  const {
    isOpen,
    closeDropdownMenu,
    triggerRef,
    focusedIndex,
    itemsRef,
    setFocusedIndex,
  } = context;

  const [isVisible, setIsVisible] = useState(false);

  const handleArrawNavigation = useCallback(
    (key: string) => {
      const isArrowUp = key === 'ArrowUp';
      const itemCount = itemsRef.current.length;

      let newIndex = focusedIndex;

      if (focusedIndex === -1) {
        newIndex = isArrowUp ? itemCount - 1 : 0;
      } else {
        newIndex = isArrowUp
          ? (focusedIndex - 1 + itemCount) % itemCount
          : (focusedIndex + 1) % itemCount;
      }

      setFocusedIndex(newIndex);
      itemsRef.current[newIndex].focus();
    },
    [focusedIndex, itemsRef, setFocusedIndex]
  );

  const handleWheel = useCallback((e: WheelEvent) => {
    e.preventDefault();
  }, []);

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (!isOpen) return;

      switch (e.key) {
        case 'Escape':
          if (onEscapeKeyDown) {
            onEscapeKeyDown();
          } else {
            closeDropdownMenu();
          }
          break;

        case 'Tab':
          e.preventDefault();
          break;

        case 'ArrowUp':
        case 'ArrowDown':
          e.preventDefault();
          handleArrawNavigation(e.key);
          break;
      }
    },
    [closeDropdownMenu, handleArrawNavigation, isOpen, onEscapeKeyDown]
  );

  useEffect(() => {
    if (isOpen) {
      setIsVisible(true);
      document.addEventListener('wheel', handleWheel, { passive: false });
      document.addEventListener('keydown', handleKeyDown);
    } else {
      setFocusedIndex(-1);
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    }
    return () => {
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown, handleWheel, isOpen, setFocusedIndex]);

  const handlePointerDownOutside = () => {
    if (onPointerDownOutside) {
      onPointerDownOutside();
    } else {
      closeDropdownMenu();
    }
  };

  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit') {
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      props.onAnimationEnd?.(e);
      handleAnimationEnd(e);
    },
  };

  const [transformStyle, setTransformStyle] = useState('');

  useLayoutEffect(() => {
    // triggerとなる要素からDropdownMenuを表示する座標を計算する
    // （style属性に指定する文字列作成）
    if (triggerRef.current) {
      const { left, top, right, bottom, width, height } =
        triggerRef.current.getBoundingClientRect();

      const getOffset = (align: DropdownMenuAlignType, size: number) => {
        switch (align) {
          case 'start':
            return `0% - ${size / 2}px`;
          case 'end':
            return `-100% + ${size / 2}px`;
          default:
            return '-50%';
        }
      };

      const offsetX = getOffset(align, width);
      const offsetY = getOffset(align, height);

      const positions = {
        top: {
          x: left + width / 2,
          y: top,
          offset: { x: offsetX, y: `-100% - ${sideOffset}px` },
        },
        bottom: {
          x: left + width / 2,
          y: bottom,
          offset: { x: offsetX, y: `0% + ${sideOffset}px` },
        },
        left: {
          x: left,
          y: top + height / 2,
          offset: { x: `-100% - ${sideOffset}px`, y: offsetY },
        },
        right: {
          x: right,
          y: top + height / 2,
          offset: { x: `0% + ${sideOffset}px`, y: offsetY },
        },
      };
      const pos = positions[side];

      setTransformStyle(
        `translate(calc(${pos.x}px + ${pos.offset.x}), calc(${pos.y}px + ${pos.offset.y}))`
      );
    }
  }, [context, triggerRef, side, sideOffset, align]);

  let itemIndex = 0;
  const innerChildren = React.Children.map(children, (child) => {
    if (React.isValidElement(child)) {
      switch (child.type) {
        case DropdownMenuItem:
          return React.cloneElement(child, { ...child.props, index: itemIndex++ });
        default:
          return child;
      }
    }
  });

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <div className="fixed inset-0 z-50" onClick={handlePointerDownOutside} />
          <div className="fixed left-0 top-0 z-50" style={{ transform: transformStyle }}>
            <div
              className={cn(
                'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
                'fill-mode-both',
                className
              )}
              data-state={isOpen ? 'open' : 'closed'}
              data-side={side}
              {...mergeProps}
            >
              {innerChildren}
            </div>
          </div>
        </>
      )}
    </>,
    document.body
  );
};

// ----------------------------------------------------------------------------
// DropdownMenuItem
// ----------------------------------------------------------------------------
interface DropdownMenuItemProps extends React.HTMLAttributes<HTMLButtonElement> {
  index?: number;
  inset?: boolean;
}
const DropdownMenuItem = ({
  className,
  children,
  index = 0,
  inset,
  ...props
}: DropdownMenuItemProps) => {
  const context = useContext(DropdownMenuContext);
  if (!context) throw new Error('DropdownMenuItem must be used within DropdownMenu');

  const { itemsRef, closeDropdownMenu } = context;

  const mergeProps = {
    ...props,
    onMouseEnter: (e: React.MouseEvent<HTMLButtonElement>) => {
      props.onMouseEnter?.(e);
      itemsRef.current[index].focus();
    },
    onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
      if (props.onClick) {
        props.onClick(e);
        return;
      }
      closeDropdownMenu();
    },
  };

  return (
    <button
      ref={(el) => (itemsRef.current[index] = el as HTMLButtonElement)}
      className={cn(
        'relative w-full flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0',
        inset && 'pl-8',
        className
      )}
      tabIndex={-1}
      {...mergeProps}
    >
      {children}
    </button>
  );
};

// ----------------------------------------------------------------------------
// DropdownMenuSeparator
// ----------------------------------------------------------------------------
type DropdownMenuSeparatorProps = React.HTMLAttributes<HTMLDivElement>;
const DropdownMenuSeparator = React.forwardRef<
  HTMLDivElement,
  DropdownMenuSeparatorProps
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('-mx-1 my-1 h-px bg-muted', className)} {...props} />
));

// ----------------------------------------------------------------------------
// DropdownMenuLabel
// ----------------------------------------------------------------------------
interface DropdownMenuLabelProps extends React.HTMLAttributes<HTMLDivElement> {
  inset?: boolean;
}
const DropdownMenuLabel = React.forwardRef<HTMLDivElement, DropdownMenuLabelProps>(
  ({ className, inset, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('px-2 py-1.5 text-sm font-semibold', inset && 'pl-8', className)}
      {...props}
    />
  )
);

export {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
};

------------------------------------------------------------
select.tsx

import { cn } from '@/lib/util';
import { CheckIcon, ChevronDownIcon } from 'lucide-react';
import React, {
  useCallback,
  useContext,
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
} from 'react';
import ReactDOM from 'react-dom';

type SelectSideType = 'top' | 'right' | 'bottom' | 'left';
type SelectAlignType = 'start' | 'center' | 'end';

const DEFAULT_SIDE: SelectSideType = 'bottom';
const DEFAULT_ALIGN: SelectAlignType = 'center';
const DEFAULT_SIDE_OFFSET = 4;

interface SelectContextType {
  isOpen: boolean;
  openSelect: () => void;
  closeSelect: () => void;
  triggerRef: React.MutableRefObject<HTMLDivElement | HTMLButtonElement | null>;
  focusedIndex: number;
  setFocusedIndex: (index: number) => void;
  itemsRef: React.MutableRefObject<HTMLButtonElement[]>;
  innerValue: string;
  setValue: (value: string) => void;
}

const SelectContext = React.createContext<SelectContextType | undefined>(undefined);

// ----------------------------------------------------------------------------
// Select
// ----------------------------------------------------------------------------
interface SelectProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
  value?: string;
  onValueChange?: (value: string) => void;
}

const Select = ({ children, open, onOpenChange, value, onValueChange }: SelectProps) => {
  // 外部からの状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const itemsRef = useRef<HTMLButtonElement[]>([]);
  const [innerValue, setInnerValue] = useState(value ?? '');

  // propsが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  useEffect(() => {
    if (value !== undefined) {
      setInnerValue(value);
    }
  }, [value]);

  const openSelect = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeSelect = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  const setValue = useCallback(
    (value: string) => {
      if (onValueChange) {
        onValueChange(value);
      } else {
        setInnerValue(value);
      }
    },
    [onValueChange]
  );

  const triggerRef = useRef<HTMLDivElement | null>(null);

  return (
    <SelectContext.Provider
      value={{
        isOpen,
        openSelect,
        closeSelect,
        triggerRef,
        focusedIndex,
        setFocusedIndex,
        itemsRef,
        innerValue,
        setValue,
      }}
    >
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case SelectTrigger:
            case SelectContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </SelectContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// SelectTrigger
// ----------------------------------------------------------------------------
interface SelectTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const SelectTrigger = React.forwardRef<HTMLButtonElement, SelectTriggerProps>(
  ({ className, children, asChild = false, ...props }, ref) => {
    const context = useContext(SelectContext);
    if (!context) throw new Error('SelectContent must be used within Select');

    const { openSelect, triggerRef } = context;

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
        onClick: (e: React.MouseEvent) => {
          children.props.onClick?.(e);
          openSelect();
        },
      };
      return (
        <div
          ref={triggerRef as React.MutableRefObject<HTMLDivElement>}
          className={cn('w-fit', className)}
        >
          {React.cloneElement(children, { ...mergeChildProps, ref })}
        </div>
      );
    }

    const mergeProps = {
      ...props,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        props.onClick?.(e);
        openSelect();
      },
    };

    return (
      <button
        ref={triggerRef as React.MutableRefObject<HTMLButtonElement>}
        className={cn(
          'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
          className
        )}
        {...mergeProps}
      >
        {React.Children.map(children, (child) => {
          if (React.isValidElement(child)) {
            switch (child.type) {
              case SelectValue:
                return child;
              default:
                return null;
            }
          }
        })}
        <ChevronDownIcon className="size-4 opacity-50" />
      </button>
    );
  }
);

// ----------------------------------------------------------------------------
// SelectContent
// ----------------------------------------------------------------------------
interface SelectContentProps extends React.HTMLAttributes<HTMLDivElement> {
  side?: SelectSideType;
  align?: SelectAlignType;
  sideOffset?: number;
  onEscapeKeyDown?: () => void;
  onPointerDownOutside?: () => void;
  position?: 'item-aligned' | 'popper';
}

const SelectContent = ({
  children,
  className,
  side = DEFAULT_SIDE,
  align = DEFAULT_ALIGN,
  sideOffset = DEFAULT_SIDE_OFFSET,
  onEscapeKeyDown,
  onPointerDownOutside,
  position = 'item-aligned',
  ...props
}: SelectContentProps) => {
  const context = useContext(SelectContext);
  if (!context) throw new Error('SelectContent must be used within Select');

  const { isOpen, closeSelect, triggerRef, focusedIndex, itemsRef, setFocusedIndex } =
    context;

  const [isVisible, setIsVisible] = useState(false);

  const handleArrawNavigation = useCallback(
    (key: string) => {
      const isArrowUp = key === 'ArrowUp';
      const itemCount = itemsRef.current.length;

      const newIndex = isArrowUp
        ? (focusedIndex - 1 + itemCount) % itemCount
        : (focusedIndex + 1) % itemCount;

      setFocusedIndex(newIndex);
      itemsRef.current[newIndex].focus();
    },
    [focusedIndex, itemsRef, setFocusedIndex]
  );

  const handleWheel = useCallback((e: WheelEvent) => {
    e.preventDefault();
  }, []);

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (!isOpen) return;

      switch (e.key) {
        case 'Escape':
          if (onEscapeKeyDown) {
            onEscapeKeyDown();
          } else {
            closeSelect();
          }
          break;

        case 'Tab':
          e.preventDefault();
          break;

        case 'ArrowUp':
        case 'ArrowDown':
          e.preventDefault();
          handleArrawNavigation(e.key);
          break;
      }
    },
    [closeSelect, handleArrawNavigation, isOpen, onEscapeKeyDown]
  );

  useEffect(() => {
    if (isOpen) {
      setIsVisible(true);
      document.addEventListener('wheel', handleWheel, { passive: false });
      document.addEventListener('keydown', handleKeyDown);
    } else {
      setFocusedIndex(-1);
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    }
    return () => {
      document.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown, handleWheel, isOpen, setFocusedIndex]);

  const handlePointerDownOutside = () => {
    if (onPointerDownOutside) {
      onPointerDownOutside();
    } else {
      closeSelect();
    }
  };

  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'exit') {
      setIsVisible(false);
    }
  };

  const mergeProps = {
    ...props,
    onAnimationEnd: (e: React.AnimationEvent<HTMLDivElement>) => {
      props.onAnimationEnd?.(e);
      handleAnimationEnd(e);
    },
  };

  const [transformStyle, setTransformStyle] = useState('');

  useLayoutEffect(() => {
    // triggerとなる要素からSelectを表示する座標を計算する
    // （style属性に指定する文字列作成）
    if (triggerRef.current) {
      const { left, top, right, bottom, width, height } =
        triggerRef.current.getBoundingClientRect();

      const getOffset = (align: SelectAlignType, size: number) => {
        switch (align) {
          case 'start':
            return `0% - ${size / 2}px`;
          case 'end':
            return `-100% + ${size / 2}px`;
          default:
            return '-50%';
        }
      };

      const offsetX = getOffset(align, width);
      const offsetY = getOffset(align, height);

      const positions = {
        top: {
          x: left + width / 2,
          y: top,
          offset: { x: offsetX, y: `-100% - ${sideOffset}px` },
        },
        bottom: {
          x: left + width / 2,
          y: bottom,
          offset: { x: offsetX, y: `0% + ${sideOffset}px` },
        },
        left: {
          x: left,
          y: top + height / 2,
          offset: { x: `-100% - ${sideOffset}px`, y: offsetY },
        },
        right: {
          x: right,
          y: top + height / 2,
          offset: { x: `0% + ${sideOffset}px`, y: offsetY },
        },
      };
      const pos = positions[side];

      setTransformStyle(
        `translate(calc(${pos.x}px + ${pos.offset.x}), calc(${pos.y}px + ${pos.offset.y}))`
      );
    }
  }, [context, triggerRef, side, sideOffset, align]);

  let itemIndex = 0;
  const innerChildren = React.Children.map(children, (child) => {
    if (React.isValidElement(child)) {
      switch (child.type) {
        case SelectItem:
          return React.cloneElement(child, { ...child.props, index: itemIndex++ });
        default:
          return child;
      }
    }
  });

  return ReactDOM.createPortal(
    <>
      {isVisible && (
        <>
          <div className="fixed inset-0 z-50" onClick={handlePointerDownOutside} />
          <div className="fixed left-0 top-0 z-50" style={{ transform: transformStyle }}>
            <div
              className={cn(
                'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
                'fill-mode-both',
                position === 'popper' &&
                  'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
                className
              )}
              style={{ minWidth: `${triggerRef.current?.offsetWidth}px` }}
              data-state={isOpen ? 'open' : 'closed'}
              data-side={side}
              {...mergeProps}
            >
              <div
                className={cn(
                  'p-1',
                  position === 'popper' &&
                    'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]'
                )}
              >
                {innerChildren}
              </div>
            </div>
          </div>
        </>
      )}
    </>,
    document.body
  );
};

// ----------------------------------------------------------------------------
// SelectItem
// ----------------------------------------------------------------------------
interface SelectItemProps extends React.HTMLAttributes<HTMLButtonElement> {
  index?: number;
  value?: string;
}
const SelectItem = ({
  className,
  children,
  index = 0,
  value,
  ...props
}: SelectItemProps) => {
  const context = useContext(SelectContext);
  if (!context) throw new Error('SelectItem must be used within Select');

  const { innerValue, itemsRef, setFocusedIndex, setValue, closeSelect } = context;

  useEffect(() => {
    if (innerValue === value) {
      itemsRef.current[index].focus();
      setFocusedIndex(index);
    }
  }, [index, innerValue, itemsRef, setFocusedIndex, value]);

  const mergeProps = {
    ...props,
    onMouseEnter: (e: React.MouseEvent<HTMLButtonElement>) => {
      props.onMouseEnter?.(e);
      itemsRef.current[index].focus();
    },
    onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
      if (props.onClick) {
        props.onClick(e);
        return;
      }
      setValue(value ?? '');
      closeSelect();
    },
  };

  return (
    <button
      ref={(el) => (itemsRef.current[index] = el as HTMLButtonElement)}
      className={cn(
        'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
        className
      )}
      tabIndex={-1}
      {...mergeProps}
    >
      <span className="absolute left-2 flex size-3.5 items-center justify-center">
        {innerValue === value && <CheckIcon className="size-4" />}
      </span>
      {children}
    </button>
  );
};
// ----------------------------------------------------------------------------
// SelectSeparator
// ----------------------------------------------------------------------------
type SelectSeparatorProps = React.HTMLAttributes<HTMLDivElement>;
const SelectSeparator = React.forwardRef<HTMLDivElement, SelectSeparatorProps>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('-mx-1 my-1 h-px bg-muted', className)} {...props} />
  )
);

// ----------------------------------------------------------------------------
// SelectLabel
// ----------------------------------------------------------------------------
type SelectLabelProps = React.HTMLAttributes<HTMLDivElement>;
const SelectLabel = React.forwardRef<HTMLDivElement, SelectLabelProps>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
      {...props}
    />
  )
);

// ----------------------------------------------------------------------------
// SelectValue
// ----------------------------------------------------------------------------
interface SelectValueProps extends React.HTMLAttributes<HTMLDivElement> {
  placeholder?: string;
}
const SelectValue = React.forwardRef<HTMLDivElement, SelectValueProps>(
  ({ className, placeholder, ...props }, ref) => {
    const context = useContext(SelectContext);
    if (!context) throw new Error('SelectValue must be used within Select');

    const { innerValue } = context;

    return (
      <span ref={ref} className={cn('', className)} {...props}>
        {innerValue || placeholder}
      </span>
    );
  }
);

export {
  Select,
  SelectContent,
  SelectItem,
  SelectLabel,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};

------------------------------------------------------------
tooltip.tsx

import { cn } from '@/lib/util';
import React, {
  useCallback,
  useContext,
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
} from 'react';

type TooltipSideType = 'top' | 'right' | 'bottom' | 'left';
type TooltipAlignType = 'start' | 'center' | 'end';

const DEFAULT_SIDE: TooltipSideType = 'top';
const DEFAULT_ALIGN: TooltipAlignType = 'center';
const DEFAULT_SIDE_OFFSET = 8;

interface TooltipContextType {
  isOpen: boolean;
  openTooltip: () => void;
  closeTooltip: () => void;
  triggerRef: React.MutableRefObject<HTMLDivElement | null>;
}

const TooltipContext = React.createContext<TooltipContextType | undefined>(undefined);

// ----------------------------------------------------------------------------
// Tooltip
// ----------------------------------------------------------------------------
interface TooltipProps extends React.HTMLAttributes<HTMLDivElement> {
  open?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}

const Tooltip = ({ children, open, onOpenChange }: TooltipProps) => {
  // 外部からの状態を優先し、指定がない場合は内部状態を利用
  const [isOpen, setIsOpen] = useState(open ?? false);

  // propsが更新されたら内部状態も更新
  useEffect(() => {
    if (open !== undefined) {
      setIsOpen(open);
    }
  }, [open]);

  const openTooltip = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(true);
    } else {
      setIsOpen(true);
    }
  }, [onOpenChange]);

  const closeTooltip = useCallback(() => {
    if (onOpenChange) {
      onOpenChange(false);
    } else {
      setIsOpen(false);
    }
  }, [onOpenChange]);

  const triggerRef = useRef<HTMLDivElement | null>(null);

  return (
    <TooltipContext.Provider value={{ isOpen, openTooltip, closeTooltip, triggerRef }}>
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          switch (child.type) {
            case TooltipTrigger:
            case TooltipContent:
              return child;
            default:
              return null;
          }
        }
      })}
    </TooltipContext.Provider>
  );
};

// ----------------------------------------------------------------------------
// TooltipTrigger
// ----------------------------------------------------------------------------
interface TooltipTriggerProps extends React.HTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}

const TooltipTrigger = React.forwardRef<HTMLButtonElement, TooltipTriggerProps>(
  ({ children, asChild = false, ...props }, ref) => {
    const context = useContext(TooltipContext);
    if (!context) throw new Error('TooltipContent must be used within Tooltip');

    const { triggerRef, openTooltip, closeTooltip } = context;

    if (asChild && React.isValidElement(children)) {
      const mergeChildProps = {
        ...children.props,
      };
      return (
        <div
          ref={triggerRef}
          className="w-fit"
          onPointerEnter={openTooltip}
          onPointerLeave={closeTooltip}
          onPointerDown={closeTooltip}
        >
          {React.cloneElement(children, { ...mergeChildProps, ref })}
        </div>
      );
    }

    return (
      <div
        ref={triggerRef}
        className="w-fit"
        onPointerEnter={openTooltip}
        onPointerLeave={closeTooltip}
        onPointerDown={closeTooltip}
      >
        <button ref={ref} {...props}>
          {children}
        </button>
      </div>
    );
  }
);

// ----------------------------------------------------------------------------
// TooltipContent
// ----------------------------------------------------------------------------
interface TooltipContentProps extends React.HTMLAttributes<HTMLDivElement> {
  side?: TooltipSideType;
  align?: TooltipAlignType;
  sideOffset?: number;
}

const TooltipContent = React.forwardRef<HTMLDivElement, TooltipContentProps>(
  (
    {
      children,
      className,
      side = DEFAULT_SIDE,
      align = DEFAULT_ALIGN,
      sideOffset = DEFAULT_SIDE_OFFSET,
      ...props
    },
    ref
  ) => {
    const context = useContext(TooltipContext);
    if (!context) throw new Error('TooltipContent must be used within Tooltip');

    const { isOpen, closeTooltip, triggerRef } = context;

    const [transformStyle, setTransformStyle] = useState('');

    const handleWheel = useCallback(
      (e: WheelEvent) => {
        e.preventDefault();
        closeTooltip();
      },
      [closeTooltip]
    );

    useEffect(() => {
      if (isOpen) {
        document.addEventListener('wheel', handleWheel, { passive: false });
      } else {
        document.removeEventListener('wheel', handleWheel);
      }
      return () => {
        document.removeEventListener('wheel', handleWheel);
      };
    }, [handleWheel, isOpen]);

    useLayoutEffect(() => {
      // triggerとなる要素からTooltipを表示する座標を計算する
      // （style属性に指定する文字列作成）
      if (triggerRef.current) {
        const { left, top, right, bottom, width, height } =
          triggerRef.current.getBoundingClientRect();

        const getOffset = (align: TooltipAlignType, size: number) => {
          switch (align) {
            case 'start':
              return `0% - ${size / 2}px`;
            case 'end':
              return `-100% + ${size / 2}px`;
            default:
              return '-50%';
          }
        };

        const offsetX = getOffset(align, width);
        const offsetY = getOffset(align, height);

        const positions = {
          top: {
            x: left + width / 2,
            y: top,
            offset: { x: offsetX, y: `-100% - ${sideOffset}px` },
          },
          bottom: {
            x: left + width / 2,
            y: bottom,
            offset: { x: offsetX, y: `0% + ${sideOffset}px` },
          },
          left: {
            x: left,
            y: top + height / 2,
            offset: { x: `-100% - ${sideOffset}px`, y: offsetY },
          },
          right: {
            x: right,
            y: top + height / 2,
            offset: { x: `0% + ${sideOffset}px`, y: offsetY },
          },
        };
        const pos = positions[side];

        setTransformStyle(
          `translate(calc(${pos.x}px + ${pos.offset.x}), calc(${pos.y}px + ${pos.offset.y}))`
        );
      }
    }, [context, triggerRef, side, sideOffset, align]);

    return (
      <>
        {isOpen && (
          <div className="fixed left-0 top-0 z-50" style={{ transform: transformStyle }}>
            <div
              ref={ref}
              className={cn(
                'z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
                className
              )}
              data-state={isOpen ? 'open' : 'closed'}
              data-side={side}
              {...props}
            >
              {children}
            </div>
          </div>
        )}
      </>
    );
  }
);

export { Tooltip, TooltipContent, TooltipTrigger };

------------------------------------------------------------
confirm-dialog.tsx

import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { CONFIRM_DIALOG_EVENT, ConfirmDialogOptions } from '@/hooks/use-confirm-dialog';
import { cn } from '@/lib/util';
import {
  AlertTriangleIcon,
  CheckCircle2Icon,
  HelpCircleIcon,
  InfoIcon,
} from 'lucide-react';
import { useEffect, useRef, useState } from 'react';

const ICON_COMPONENTS = {
  info: InfoIcon,
  question: HelpCircleIcon,
  warning: AlertTriangleIcon,
  check: CheckCircle2Icon,
};

const DEFAULT_OPTION_VALUE: ConfirmDialogOptions = {
  icon: 'info',
  title: '',
  message: '',
  actionLabel: 'OK',
  actionOnly: false,
  persistent: false,
  showInput: false,
  inputLabel: '',
  inputPlaceholder: '',
  inputRows: 1,
};

export default function ConfirmDialog() {
  const [isOpen, setIsOpen] = useState(false);
  const [options, setOptions] = useState<ConfirmDialogOptions>(DEFAULT_OPTION_VALUE);
  const [isPersistentAnimation, setIsPersistentAnimation] = useState(false);

  const refTextarea = useRef<HTMLTextAreaElement>(null);

  const IconComponent = ICON_COMPONENTS[options.icon];

  // hooksから呼ぶためにイベントリスナー登録
  useEffect(() => {
    const handleEvent = (event: CustomEvent<ConfirmDialogOptions>) => {
      setIsOpen(true);
      setOptions({ ...DEFAULT_OPTION_VALUE, ...event.detail });
    };
    document.addEventListener(CONFIRM_DIALOG_EVENT, handleEvent as EventListener);
    return () => {
      document.removeEventListener(CONFIRM_DIALOG_EVENT, handleEvent as EventListener);
    };
  }, []);

  const handleCloseDialog = () => {
    // アニメーションフラグ（閉じれないことを伝えるためにぶるっとする）
    if (options.persistent) {
      setIsPersistentAnimation(true);
      setTimeout(() => {
        setIsPersistentAnimation(false);
      }, 50);
      return;
    }
    handleClickCancel();
  };

  const handleClickAction = () => {
    setIsOpen(false);
    options.resolve?.({
      isAction: true,
      isCancel: false,
      text: refTextarea.current?.value || '',
    });
  };

  const handleClickCancel = () => {
    setIsOpen(false);
    options.resolve?.({
      isAction: false,
      isCancel: true,
      text: '',
    });
  };

  return (
    <Dialog open={isOpen}>
      <DialogContent
        className={cn(
          'w-[360px] sm:w-[400px] transition-transform ease-in-out [transition-duration:25ms]',
          isPersistentAnimation && 'scale-[1.02] transform'
        )}
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
      >
        <DialogHeader>
          <DialogTitle className="my-2 flex items-center">
            <IconComponent
              className={cn(
                'mr-3 min-w-fit',
                options.icon === 'warning' && 'text-destructive'
              )}
            />
            <p className="leading-6">{options.title}</p>
          </DialogTitle>
          {options.message && (
            <DialogDescription className="pt-2 text-left">
              {options.message}
            </DialogDescription>
          )}
        </DialogHeader>

        {options.showInput && (
          <div className="mb-4 grid w-full items-center gap-1.5">
            <p className="text-xs">{options.inputLabel}</p>
            <Textarea
              ref={refTextarea}
              className="min-h-4 resize-none"
              placeholder={options.inputPlaceholder}
              rows={options.inputRows}
            />
          </div>
        )}

        <DialogFooter className="flex justify-end gap-y-4 sm:gap-y-0">
          {!options.actionOnly && (
            <Button
              className="min-w-24 rounded-full"
              variant="ghost"
              onClick={handleClickCancel}
            >
              キャンセル
            </Button>
          )}
          <Button
            className="min-w-24 rounded-full"
            variant={options.icon === 'warning' ? 'destructive' : 'default'}
            onClick={handleClickAction}
          >
            {options.actionLabel}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
use-api-bookmark.ts

import { FETCH_BOOKMARKS_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { Bookmark, BookmarkPage, BookmarkRequest } from '@/types';

export const useApiBookmark = () => {
  const { fetcherWithAuth, mutationWithAuth } = useApi();

  const getBookmarkByBookId = async (bookId: string) => {
    try {
      const url = `/bookmarks/${bookId}`;
      const bookmarks = await fetcherWithAuth<Bookmark[]>(url);
      return bookmarks;
    } catch (error) {
      throw new Error('ブックマークの読み込みが失敗しました。' + error);
    }
  };

  const getBookmarkPage = async (page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/bookmarks?&page=${basePage}&maxResults=${FETCH_BOOKMARKS_MAX_RESULTS}`;
      const bookmarkPage = await fetcherWithAuth<BookmarkPage>(url);
      return bookmarkPage;
    } catch (error) {
      throw new Error('ブックマーク一覧の読み込みが失敗しました。' + error);
    }
  };

  const createBookmark = async (requestBody: BookmarkRequest) => {
    try {
      const url = `/bookmarks`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('ブックマークの作成に失敗しました。' + error);
    }
  };

  const updateBookmark = async (id: number, requestBody: BookmarkRequest) => {
    try {
      const url = `/bookmarks/${id}`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('ブックマークの更新に失敗しました。' + error);
    }
  };

  const deleteBookmark = async (id: number) => {
    try {
      const url = `/bookmarks/${id}`;
      const options: RequestInit = { method: 'DELETE' };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('ブックマークの削除に失敗しました。' + error);
    }
  };

  return {
    getBookmarkByBookId,
    getBookmarkPage,
    createBookmark,
    updateBookmark,
    deleteBookmark,
  };
};

------------------------------------------------------------
use-api-favorite.ts

import { FETCH_FAVORITES_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { Favorite, FavoriteInfo, FavoritePage, FavoriteRequest } from '@/types';

export const useApiFavorite = () => {
  const { fetcher, fetcherWithAuth, mutationWithAuth } = useApi();

  const getFavoriteByBookId = async (bookId: string) => {
    try {
      const url = `/favorites/${bookId}`;
      const favorite = await fetcherWithAuth<Favorite>(url);
      return favorite;
    } catch (error) {
      throw new Error('お気に入りの読み込みが失敗しました。' + error);
    }
  };

  const getFavoritePage = async (page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/favorites?&page=${basePage}&maxResults=${FETCH_FAVORITES_MAX_RESULTS}`;
      const favoritePage = await fetcherWithAuth<FavoritePage>(url);
      return favoritePage;
    } catch (error) {
      throw new Error('お気に入り一覧の読み込みが失敗しました。' + error);
    }
  };

  const getFavoriteInfo = async (bookId: string, userId: number | undefined) => {
    try {
      const query = userId ? `?userId=${userId}` : '';
      const url = `/books/${bookId}/favorites/info${query}`;
      const favoriteInfo = await fetcher<FavoriteInfo>(url);
      return favoriteInfo;
    } catch (error) {
      throw new Error('お気に入り情報の読み込みが失敗しました。' + error);
    }
  };

  const createFavorite = async (requestBody: FavoriteRequest) => {
    try {
      const url = `/favorites`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('お気に入りの作成に失敗しました。' + error);
    }
  };

  const deleteFavorite = async (bookId: string) => {
    try {
      const url = `/favorites/${bookId}`;
      const options: RequestInit = { method: 'DELETE' };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('お気に入りの削除に失敗しました。' + error);
    }
  };

  return {
    getFavoriteByBookId,
    getFavoritePage,
    getFavoriteInfo,
    createFavorite,
    deleteFavorite,
  };
};

------------------------------------------------------------
use-api-review.ts

import {
  FETCH_MY_REVIEWS_MAX_RESULTS,
  FETCH_REVIEWS_MAX_RESULTS,
} from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { ReviewPage, ReviewRequest, ReviewSummary, SelfReviewExists } from '@/types';

export const useApiReview = () => {
  const { fetcher, fetcherWithAuth, mutationWithAuth } = useApi();

  const getReviewPage = async (bookId: string, page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/books/${bookId}/reviews?&page=${basePage}&maxResults=${FETCH_REVIEWS_MAX_RESULTS}`;
      const reviewPage = await fetcher<ReviewPage>(url);
      return reviewPage;
    } catch (error) {
      throw new Error('レビュー一覧の読み込みが失敗しました。' + error);
    }
  };

  const getReviewSummary = async (bookId: string) => {
    try {
      const url = `/books/${bookId}/reviews/summary`;
      const reviewSummary = await fetcher<ReviewSummary>(url);
      return reviewSummary;
    } catch (error) {
      throw new Error('レビュー情報の読み込みが失敗しました。' + error);
    }
  };

  const checkSelfReviewExists = async (bookId: string) => {
    try {
      const url = `/reviews/self-review-exists/${bookId}`;
      const data = await fetcherWithAuth<SelfReviewExists>(url);
      return data.exists;
    } catch (error) {
      throw new Error('レビューの存在チェックに失敗しました。' + error);
    }
  };

  const getReviewPageByUser = async (page: number = 0) => {
    try {
      const basePage = page > 0 ? page - 1 : 0;
      const url = `/reviews?&page=${basePage}&maxResults=${FETCH_MY_REVIEWS_MAX_RESULTS}`;
      const reviewPage = await fetcherWithAuth<ReviewPage>(url);
      return reviewPage;
    } catch (error) {
      throw new Error('マイレビュー一覧の読み込みが失敗しました。' + error);
    }
  };

  const createReview = async (requestBody: ReviewRequest) => {
    try {
      const url = `/reviews`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('レビューの作成に失敗しました。' + error);
    }
  };

  const updateReview = async (id: number, requestBody: ReviewRequest) => {
    try {
      const url = `/reviews/${id}`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('レビューの更新に失敗しました。' + error);
    }
  };

  const deleteReview = async (id: number) => {
    try {
      const url = `/reviews/${id}`;
      const options: RequestInit = {
        method: 'DELETE',
      };
      await mutationWithAuth(url, options);
    } catch (error) {
      throw new Error('レビューの削除に失敗しました。' + error);
    }
  };

  return {
    getReviewPage,
    getReviewSummary,
    checkSelfReviewExists,
    getReviewPageByUser,
    createReview,
    updateReview,
    deleteReview,
  };
};

------------------------------------------------------------
use-confirm-dialog.ts

type IconType = 'info' | 'question' | 'warning' | 'check';

// 確認ダイアログの引数
export type ConfirmDialogOptions = {
  icon: IconType; // アイコンの種類（「'i'」「'?'」「'!'」「'c'」）
  title: string; // タイトル
  message?: string; // メッセージ
  actionLabel?: string; // アクションボタンの文字（デフォルト「OK」）
  actionOnly?: boolean; // 「キャンセル」ボタンをなくす
  persistent?: boolean; // 永続化するか（要素外クリック、ESCキーでも閉じないようにするか）
  showInput?: boolean; // 入力欄を表示するか
  inputLabel?: string; // 入力欄のラベル
  inputPlaceholder?: string; // 入力欄のプレースホルダー
  inputRows?: number; // 入力欄の行数
  resolve?: (value: ConfirmDialogResult) => void;
};

// 確認ダイアログの戻り値
export type ConfirmDialogResult = {
  isAction: boolean;
  isCancel: boolean;
  text: string;
};

export const CONFIRM_DIALOG_EVENT = 'CONFIRM_DIALOG_EVENT';

export const useConfirmDialog = () => {
  const confirmDialog = (options: ConfirmDialogOptions): Promise<ConfirmDialogResult> => {
    return new Promise((resolve) => {
      const event = new CustomEvent(CONFIRM_DIALOG_EVENT, {
        detail: { ...options, resolve },
      });
      document.dispatchEvent(event);
    });
  };
  return { confirmDialog };
};

------------------------------------------------------------
use-search-filters.ts

import { useSearchParams } from 'react-router-dom';

type ParamsType = {
  q?: string;
  genreIds?: string;
  condition?: string;
  page?: number;
};

export const useSearchFilters = () => {
  const [searchParams, setSearchParams] = useSearchParams();

  const q = searchParams.get('q') ?? '';
  const genreIds = searchParams.get('genreIds') ?? '';
  const condition = searchParams.get('condition') ?? '';
  const page = Number(searchParams.get('page') ?? '1');

  const updateQueryParams = (params: ParamsType) => {
    const newParams = new URLSearchParams(searchParams);

    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        newParams.set(key, value.toString());
      }
    });

    setSearchParams(newParams);
  };

  return { q, genreIds, condition, page, updateQueryParams };
};

------------------------------------------------------------
login

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { LoginRequest } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';

export default function Page() {
  const location = useLocation();
  const navigate = useNavigate();
  const { login, setUser } = useAuth();
  const { getCurrentUser } = useApiUser();
  const { toast } = useToast();

  const loginMutation = useMutation({
    mutationFn: (requestBody: LoginRequest) => login(requestBody),
    onSuccess: async () => {
      const user = await getCurrentUser();
      setUser(user);
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;

    const requestBody: LoginRequest = { email, password };
    loginMutation.mutate(requestBody, {
      onSuccess: () => {
        const pathname = location.state?.from?.pathname || '/';
        const query = location.state?.from?.search || '';
        navigate(pathname + query, { replace: true });
      },
      onError: () => {
        toast({
          title: 'ログインできませんでした',
          description: 'メールアドレスまたはパスワードが違います。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">ログイン</h1>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="email">
                メールアドレス
              </Label>
              <Input
                className="my-2 rounded-full"
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
              />
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                パスワード
              </Label>
              <PasswordInput
                className="my-2 rounded-full"
                id="password"
                name="password"
              />
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={loginMutation.isPending}
            >
              {loginMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                'ログイン'
              )}
            </Button>
          </form>

          <div className="mt-6 flex justify-center gap-x-1 text-xs">
            <p className="text-muted-foreground">アカウントをお持ちでない方はこちら</p>
            <Link to={'/signup'} className="text-primary hover:underline">
              新規登録
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
change-email

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { LoginRequest } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';

export default function Page() {
  const location = useLocation();
  const navigate = useNavigate();
  const { login, setUser } = useAuth();
  const { getCurrentUser } = useApiUser();
  const { toast } = useToast();

  const loginMutation = useMutation({
    mutationFn: (requestBody: LoginRequest) => login(requestBody),
    onSuccess: async () => {
      const user = await getCurrentUser();
      setUser(user);
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;

    const requestBody: LoginRequest = { email, password };
    loginMutation.mutate(requestBody, {
      onSuccess: () => {
        const pathname = location.state?.from?.pathname || '/';
        const query = location.state?.from?.search || '';
        navigate(pathname + query, { replace: true });
      },
      onError: () => {
        toast({
          title: 'ログインできませんでした',
          description: 'メールアドレスまたはパスワードが違います。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">ログイン</h1>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="email">
                メールアドレス
              </Label>
              <Input
                className="my-2 rounded-full"
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
              />
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                パスワード
              </Label>
              <PasswordInput
                className="my-2 rounded-full"
                id="password"
                name="password"
              />
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={loginMutation.isPending}
            >
              {loginMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                'ログイン'
              )}
            </Button>
          </form>

          <div className="mt-6 flex justify-center gap-x-1 text-xs">
            <p className="text-muted-foreground">アカウントをお持ちでない方はこちら</p>
            <Link to={'/signup'} className="text-primary hover:underline">
              新規登録
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
change-password

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/util';
import { ChangePassword } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React, { useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function Page() {
  const [currentPasswordErrorMessage, setCurrentPasswordErrorMessage] = useState('');
  const [newPasswordErrorMessage, setNewPasswordErrorMessage] = useState('');
  const [confirmPasswordErrorMessage, setConfirmPasswordErrorMessage] = useState('');

  const currentPasswordRef = useRef<HTMLInputElement | null>(null);
  const newPasswordRef = useRef<HTMLInputElement | null>(null);
  const confirmPasswordRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { changePassword } = useApiUser();
  const { toast } = useToast();

  const { confirmDialog } = useConfirmDialog();

  const updateMutation = useMutation({
    mutationFn: (requestBody: ChangePassword) => changePassword(requestBody),
    onSuccess: () => {
      navigate('/settings/profile');
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const currentPassword = form.get('current-password') as string;
    const newPassword = form.get('new-password') as string;
    const confirmPassword = form.get('confirm-password') as string;

    const isCurrentPasswrdValid = validateCurrentPassword();
    const isNewPasswrdValid = validateNewPassword();
    const isConfirmPasswrdValid = validateConfirmPassword();

    if (!isCurrentPasswrdValid || !isNewPasswrdValid || !isConfirmPasswrdValid) {
      return;
    }

    const { isCancel } = await confirmDialog({
      icon: 'question',
      title: '本当に変更しますか？',
      message: 'パスワードを変更します。',
    });
    if (isCancel) return;

    const requestBody: ChangePassword = {
      currentPassword,
      newPassword,
      confirmPassword,
    };
    updateMutation.mutate(requestBody, {
      onSuccess: () => {
        toast({ title: 'パスワードを変更しました' });
      },
      onError: () => {
        toast({
          title: 'パスワードを変更できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateCurrentPassword = () => {
    setCurrentPasswordErrorMessage('');
    const password = currentPasswordRef.current?.value as string;

    if (password === '') {
      setCurrentPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    return true;
  };

  const validateNewPassword = () => {
    setNewPasswordErrorMessage('');
    const password = newPasswordRef.current?.value as string;

    if (password === '') {
      setNewPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    if (password.length < 4) {
      setNewPasswordErrorMessage('パスワードは4文字以上で設定してください。');
      return false;
    }

    return true;
  };

  const validateConfirmPassword = () => {
    setConfirmPasswordErrorMessage('');
    const newPassword = newPasswordRef.current?.value as string;
    const confirmPassword = confirmPasswordRef.current?.value as string;

    if (newPassword !== confirmPassword) {
      setConfirmPasswordErrorMessage(
        '新しいパスワードと確認用パスワードが一致していません。'
      );
      return false;
    }

    return true;
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">パスワード変更</h1>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="current-password">
                現在のパスワード
              </Label>
              <PasswordInput
                ref={currentPasswordRef}
                className={cn(
                  'my-2 rounded-full',
                  currentPasswordErrorMessage && 'border-destructive'
                )}
                id="current-password"
                name="current-password"
              />
              {currentPasswordErrorMessage && (
                <p className="text-xs text-destructive">{currentPasswordErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="new-password">
                新しいパスワード
              </Label>
              <PasswordInput
                ref={newPasswordRef}
                className={cn(
                  'my-2 rounded-full',
                  newPasswordErrorMessage && 'border-destructive'
                )}
                id="new-password"
                name="new-password"
              />
              {newPasswordErrorMessage && (
                <p className="text-xs text-destructive">{newPasswordErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="confirm-password">
                新しいパスワード（確認用）
              </Label>
              <PasswordInput
                ref={confirmPasswordRef}
                className={cn(
                  'my-2 rounded-full',
                  confirmPasswordErrorMessage && 'border-destructive'
                )}
                id="confirm-password"
                name="confirm-password"
              />
              {confirmPasswordErrorMessage && (
                <p className="text-xs text-destructive">{confirmPasswordErrorMessage}</p>
              )}
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={updateMutation.isPending}
            >
              {updateMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '変更'
              )}
            </Button>

            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/settings/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
change-user-info

import Logo from '@/components/layout/logo';
import AvatarCarousel from '@/components/settings/avatar-carousel';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/util';
import { UpdateCurrentUser } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function Page() {
  const [nameErrorMessage, setNameErrorMessage] = useState('');

  const nameRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { updateCurrentUser } = useApiUser();
  const { toast } = useToast();

  const { user, setUser } = useAuth();

  const [avatarPath, setAvatarPath] = useState(user?.avatarPath || '');

  const updateMutation = useMutation({
    mutationFn: (requestBody: UpdateCurrentUser) => updateCurrentUser(requestBody),
    onSuccess: () => {
      navigate('/settings/profile');
    },
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    if (nameRef.current && user) {
      nameRef.current.value = user.name || '';
    }
  }, [user]);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const name = form.get('name') as string;

    const isNameValid = validateName();

    if (!isNameValid) {
      return;
    }

    const requestBody: UpdateCurrentUser = { name, avatarPath };
    updateMutation.mutate(requestBody, {
      onSuccess: () => {
        // 名前とアバターURLだけなので楽観的に更新しておく
        const newUser = user ? { ...user, name, avatarPath } : null;
        setUser(newUser);
        toast({ title: 'ユーザー情報を変更しました' });
      },
      onError: () => {
        toast({
          title: 'ユーザー情報を変更できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateName = () => {
    const name = nameRef.current?.value as string;
    setNameErrorMessage('');

    if (name === '') {
      setNameErrorMessage('ユーザー名は必須です。');
      return false;
    }

    return true;
  };

  return (
    <div className="my-6 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">ユーザー情報の編集</h1>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="name">
                ユーザー名
              </Label>
              <Input
                ref={nameRef}
                className={cn(
                  'my-2 rounded-full',
                  nameErrorMessage && 'border-destructive'
                )}
                id="name"
                name="name"
                autoComplete="off"
                spellCheck="false"
              />
              {nameErrorMessage && (
                <p className="text-xs text-destructive">{nameErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="name">
                アバター画像
              </Label>
              <AvatarCarousel value={avatarPath} onChange={setAvatarPath} />
            </div>

            <Button
              className="w-full rounded-full"
              type="submit"
              disabled={updateMutation.isPending}
            >
              {updateMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '変更'
              )}
            </Button>

            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/settings/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
signup

import Logo from '@/components/layout/logo';
import AvatarCarousel from '@/components/settings/avatar-carousel';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/util';
import { SignupRequest } from '@/types';
import { useMutation } from '@tanstack/react-query';
import { Loader2Icon } from 'lucide-react';
import { useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function Page() {
  const [emailErrorMessage, setEmailErrorMessage] = useState('');
  const [passwordErrorMessage, setPasswordErrorMessage] = useState('');
  const [nameErrorMessage, setNameErrorMessage] = useState('');

  const emailRef = useRef<HTMLInputElement | null>(null);
  const passwordRef = useRef<HTMLInputElement | null>(null);
  const nameRef = useRef<HTMLInputElement | null>(null);
  const [avatarPath, setAvatarPath] = useState('');

  const navigate = useNavigate();
  const { signup, setUser } = useAuth();
  const { getCurrentUser } = useApiUser();
  const { toast } = useToast();

  const signupMutation = useMutation({
    mutationFn: (requestBody: SignupRequest) => signup(requestBody),
    onSuccess: async () => {
      const user = await getCurrentUser();
      setUser(user);
      navigate('/');
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;
    const name = form.get('name') as string;

    const isEmailvalid = validateEmail();
    const isPasswordvalid = validatePassword();
    const isNamevalid = validateName();

    if (!isEmailvalid || !isPasswordvalid || !isNamevalid) {
      return;
    }

    const requestBody: SignupRequest = { email, password, name, avatarPath };
    signupMutation.mutate(requestBody, {
      onSuccess: () => {},
      onError: () => {
        toast({
          title: '新規登録できませんでした',
          description: '入力内容を確認してください。',
          variant: 'destructive',
          duration: 5000,
        });
      },
    });
  };

  const validateEmail = () => {
    setEmailErrorMessage('');

    const email = emailRef.current?.value as string;

    if (email === '') {
      setEmailErrorMessage('メールアドレスは必須です。');
      return false;
    }

    const emailRegex = /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(email)) {
      setEmailErrorMessage('無効なメールアドレスです。');
      return false;
    }

    return true;
  };

  const validatePassword = () => {
    setPasswordErrorMessage('');

    const password = passwordRef.current?.value as string;

    if (password === '') {
      setPasswordErrorMessage('パスワードは必須です。');
      return false;
    }

    if (password.length < 4) {
      setPasswordErrorMessage('パスワードは4文字以上で設定してください。');
      return false;
    }

    return true;
  };

  const validateName = () => {
    setNameErrorMessage('');

    const name = nameRef.current?.value as string;

    if (name === '') {
      setNameErrorMessage('ユーザー名は必須です。');
      return false;
    }

    return true;
  };

  return (
    <div className="my-3 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <h1 className="font-semibold">アカウントの作成</h1>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="email">
                メールアドレス
              </Label>
              <Input
                ref={emailRef}
                className={cn(
                  'my-2 rounded-full',
                  emailErrorMessage && 'border-destructive'
                )}
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
              />
              {emailErrorMessage && (
                <p className="text-xs text-destructive">{emailErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                パスワード
              </Label>
              <PasswordInput
                ref={passwordRef}
                className={cn(
                  'my-2 rounded-full',
                  passwordErrorMessage && 'border-destructive'
                )}
                id="password"
                name="password"
              />
              {passwordErrorMessage && (
                <p className="text-xs text-destructive">{passwordErrorMessage}</p>
              )}
            </div>

            <Separator className="mb-2 mt-6 bg-foreground/10" />

            <div>
              <Label className="text-xs" htmlFor="name">
                ユーザー名
              </Label>
              <Input
                ref={nameRef}
                className={cn(
                  'my-2 rounded-full',
                  nameErrorMessage && 'border-destructive'
                )}
                id="name"
                name="name"
                autoComplete="off"
                spellCheck="false"
              />
              {nameErrorMessage && (
                <p className="text-xs text-destructive">{nameErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="name">
                アバター画像
              </Label>
              <AvatarCarousel value={avatarPath} onChange={setAvatarPath} />
            </div>

            <Button
              className="mt-2 w-full rounded-full"
              type="submit"
              disabled={signupMutation.isPending}
            >
              {signupMutation.isPending ? (
                <Loader2Icon className="animate-spin" />
              ) : (
                '新規登録'
              )}
            </Button>
          </form>

          <div className="mt-6 flex justify-center gap-x-1 text-xs">
            <p className="text-muted-foreground">アカウントをお持ちですか？</p>
            <Link to={'/login'}>
              <p className="text-primary hover:underline">ログイン</p>
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
auth-provider.tsx

import { BOOKS_API_ENDPOINT } from '@/constants/constants';
import { AccessToken, ErrorResponse, LoginRequest, SignupRequest, User } from '@/types';
import { createContext, useEffect, useState } from 'react';

type ContextType = {
  accessToken: string | null;
  isLoading: boolean;
  user: User | null;
  setUser: (user: User | null) => void;
  login: (requestBody: LoginRequest) => Promise<void>;
  signup: (requestBody: SignupRequest) => Promise<void>;
  logout: () => Promise<void>;
  refreshAccessToken: () => Promise<string | null>;
};

const AuthContext = createContext<ContextType | undefined>(undefined);

const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [accessToken, setAccessToken] = useState<string | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const login = async (requestBody: LoginRequest) => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/login`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        const data = (await response.json()) as ErrorResponse;
        throw new Error(
          `[STATUS] ${response.status} [MESSAGE] ${data.message} [URL] ${url}`
        );
      }

      const data = (await response.json()) as AccessToken;
      setAccessToken(data.accessToken);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      throw new Error('ログインできませんでした。' + error);
    }
  };

  const signup = async (requestBody: SignupRequest) => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/signup`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        const data = (await response.json()) as ErrorResponse;
        throw new Error(
          `[STATUS] ${response.status} [MESSAGE] ${data.message} [URL] ${url}`
        );
      }

      const data = (await response.json()) as AccessToken;
      setAccessToken(data.accessToken);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      throw new Error('サインアップできませんでした。' + error);
    }
  };

  const logout = async () => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/logout`;
      const options: RequestInit = {
        method: 'POST',
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        const data = (await response.json()) as ErrorResponse;
        throw new Error(
          `[STATUS] ${response.status} [MESSAGE] ${data.message} [URL] ${url}`
        );
      }

      setAccessToken(null);
      setUser(null);
    } catch (error) {
      setAccessToken(null);
      setUser(null);
      throw new Error('ログアウトに失敗しました。' + error);
    }
  };

  const refreshAccessToken = async () => {
    const accessToken = await fetchAccessToken();
    setAccessToken(accessToken);
    if (!accessToken) {
      alert('セッションが切れたため、自動ログアウトしました。');
      setUser(null);
    }
    return accessToken;
  };

  const fetchAccessToken = async () => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/refresh-token`;
      const options: RequestInit = {
        method: 'POST',
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        throw new Error('Failed to refresh token');
      }

      const data = (await response.json()) as AccessToken;
      return data.accessToken;
    } catch {
      return null;
    }
  };

  useEffect(() => {
    // リロードするとメモリからアクセストークンが消えてしまうので
    // 初期読み込み時にリフレッシュトークンを使って再取得する
    const init = async () => {
      const accessToken = await fetchAccessToken();
      setAccessToken(accessToken);
      setIsLoading(false);
    };
    init();
  }, []);

  return (
    <AuthContext.Provider
      value={{
        accessToken,
        isLoading,
        user,
        setUser,
        login,
        signup,
        logout,
        refreshAccessToken,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export { AuthContext, AuthProvider };

------------------------------------------------------------
tsconfig.app.tsbuildinfo


------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------

