２７ファイル

------------------------------------------------------------
book-detail.tsx

import FavoriteCountIcon from '@/components/count-icon/favorite-count-icon';
import ReviewCountIcon from '@/components/count-icon/review-count-icon';
import GenreList from '@/components/genres/genre-list';
import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { useApiBook } from '@/hooks/api/use-api-book';
import { formatDateJP, formatIsbn, formatPrice } from '@/lib/util';
import { useSuspenseQuery } from '@tanstack/react-query';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
};

export default function BookDetail({ bookId }: Props) {
  const { getBookDetailsById } = useApiBook();

  const { data: book } = useSuspenseQuery({
    queryKey: ['getBookDetailsById', bookId],
    queryFn: () => getBookDetailsById(bookId),
  });

  return (
    <div className="flex flex-col justify-center p-3 pt-10 sm:p-6 lg:flex-row">
      <div className="flex flex-col items-center justify-center lg:w-1/2">
        <Link to={`/read/${bookId}/table-of-contents`} className="size-fit">
          <img
            className="h-[360px] rounded object-cover sm:h-[480px]"
            src={book.imageUrl}
            alt={book.title}
          />
        </Link>
        <div className="mt-2 flex flex-col items-center justify-around sm:w-[440px] sm:flex-row">
          <Rating rating={book.averageRating} readOnly />
          <div className="flex justify-center gap-x-2">
            <ReviewCountIcon reviewCount={book.reviewCount} />
            <FavoriteCountIcon bookId={bookId} showCount={true} />
          </div>
        </div>
        <div className="my-4 flex items-center">
          <Button className="w-44 rounded-full bg-transparent" variant="outline" asChild>
            <Link to={`/read/${bookId}/table-of-contents`}>目次を見る</Link>
          </Button>
        </div>
      </div>

      <div className="p-4 lg:w-1/2">
        <p className="text-3xl font-bold sm:text-4xl">{book.title}</p>

        <div className="my-4 flex w-full flex-wrap items-center justify-end gap-x-3">
          <p>著者</p>
          {book.authors.map((author) => (
            <p className="text-lg font-bold sm:text-2xl" key={author}>
              {author}
            </p>
          ))}
        </div>

        <GenreList genres={book.genres} variant="outline" />

        <div className="my-6 md:my-10">{book.description}</div>

        <div className="flex flex-col justify-between gap-y-4 lg:flex-row">
          <div className="flex flex-col gap-y-1 text-muted-foreground">
            <div className="flex">
              <p className="min-w-20">ISBN</p>
              <p>{formatIsbn(book.isbn)}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">出版社</p>
              <p>{book.publisher}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">発売日</p>
              <p className="tracking-wide">{formatDateJP(book.publishedDate)}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">ページ数</p>
              <p>{`${book.pageCount}ページ`}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">価格</p>
              <p>{formatPrice(book.price)}</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
book-read-content.tsx

import BookmarkCreateDialog from '@/components/bookmarks/bookmark-create-dialog';
import BookmarkUpdateDialog from '@/components/bookmarks/bookmark-update-dialog';
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useApiBookmark } from '@/hooks/api/use-api-bookmark';
import {
  getCurrentPageText,
  getPageLink,
  getPagePosition,
} from '@/lib/book-read-content';
import { cn } from '@/lib/util';
import { Bookmark, BookmarkRequest } from '@/types';
import { useMutation, useQueryClient, useSuspenseQueries } from '@tanstack/react-query';
import {
  BookmarkIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  TableOfContentsIcon,
} from 'lucide-react';
import { useState } from 'react';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
};

export default function BookReadContent({ bookId, chapterNumber, pageNumber }: Props) {
  const [isOpenBookmarkCreateDialog, setIsOpenBookmarkCreateDialog] = useState(false);
  const [isOpenBookmarkUpdateDialog, setIsOpenBookmarkUpdateDialog] = useState(false);

  const { getBookTableOfContents, getBookContentPage } = useApiBook();
  const { getBookmarkByBookId, createBookmark, updateBookmark, deleteBookmark } =
    useApiBookmark();

  const [{ data: bookTableOfContents }, { data: bookContentPage }, { data: bookmark }] =
    useSuspenseQueries({
      queries: [
        {
          queryKey: ['getBookTableOfContents', bookId],
          queryFn: () => getBookTableOfContents(bookId),
        },
        {
          queryKey: ['getBookContentPage', bookId, chapterNumber, pageNumber],
          queryFn: () => getBookContentPage(bookId, chapterNumber, pageNumber),
        },
        {
          queryKey: ['getBookmarkByBookId', bookId],
          queryFn: () => getBookmarkByBookId(bookId),
          select: (bookmarks: Bookmark[]) =>
            bookmarks.find(
              (bookmark) =>
                bookmark.bookId === bookId &&
                bookmark.chapterNumber === chapterNumber &&
                bookmark.pageNumber === pageNumber
            ),
        },
      ],
    });

  const queryClient = useQueryClient();

  const onSuccess = () => {
    queryClient.invalidateQueries({ queryKey: ['getBookmarkByBookId', bookId] });
  };

  const onError = (error: Error) => {
    console.error(error);
  };

  const createMutation = useMutation({
    mutationFn: (requestBody: BookmarkRequest) => createBookmark(requestBody),
    onSuccess,
    onError,
  });

  const updateMutation = useMutation({
    mutationFn: ({ id, requestBody }: { id: number; requestBody: BookmarkRequest }) =>
      updateBookmark(id, requestBody),
    onSuccess,
    onError,
  });

  const deleteMutation = useMutation({
    mutationFn: (bookmarkId: number) => deleteBookmark(bookmarkId),
    onSuccess,
    onError,
  });

  const handleClickCreate = () => {
    setIsOpenBookmarkCreateDialog(true);
  };

  const handleClickUpdate = () => {
    setIsOpenBookmarkUpdateDialog(true);
  };

  const currentPageText = getCurrentPageText(
    bookTableOfContents,
    chapterNumber,
    pageNumber
  );

  const { isFirstPage, isLastPage } = getPagePosition(
    bookTableOfContents,
    chapterNumber,
    pageNumber
  );

  const nextPageLink = getPageLink(
    bookTableOfContents,
    chapterNumber,
    pageNumber,
    'next'
  );

  const prevPageLink = getPageLink(
    bookTableOfContents,
    chapterNumber,
    pageNumber,
    'prev'
  );

  return (
    <div className="delay-0 duration-200 animate-in fade-in-0">
      <div className="flex flex-col gap-y-12 px-4 pb-6 pt-12 sm:px-20">
        <div>
          <p className="mb-2 text-xs text-muted-foreground sm:text-sm">{`第 ${bookContentPage.chapterNumber} 章`}</p>
          <div className="flex flex-wrap items-center">
            <p className="text-wrap text-xl font-bold sm:text-2xl">
              {bookContentPage.chapterTitle}
            </p>
            <p className="ml-4 mr-2 text-xs text-muted-foreground sm:text-sm">
              {currentPageText}
            </p>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  className="size-8 rounded-full"
                  variant="ghost"
                  size="icon"
                  aria-label="目次に戻る"
                  asChild
                >
                  <Link
                    to={`/read/${bookId}/table-of-contents`}
                    className="flex items-center gap-x-2"
                    aria-label="目次に戻る"
                  >
                    <TableOfContentsIcon className="size-4" />
                  </Link>
                </Button>
              </TooltipTrigger>
              <TooltipContent>目次に戻る</TooltipContent>
            </Tooltip>
            <Tooltip>
              <TooltipTrigger asChild>
                {bookmark ? (
                  <>
                    <Button
                      className={cn(
                        'rounded-full text-muted-foreground size-8',
                        bookmark && 'text-primary bg-transparent'
                      )}
                      variant="ghost"
                      size="icon"
                      aria-label="ブックマーク"
                      onClick={handleClickUpdate}
                    >
                      <BookmarkIcon
                        className="size-4"
                        style={{
                          fill: 'hsl(var(--primary))',
                        }}
                      />
                    </Button>
                    <BookmarkUpdateDialog
                      bookmark={bookmark}
                      isOpen={isOpenBookmarkUpdateDialog}
                      setIsOpen={setIsOpenBookmarkUpdateDialog}
                      updateMutation={updateMutation}
                      deleteMutation={deleteMutation}
                    />
                  </>
                ) : (
                  <>
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      aria-label="ブックマーク"
                      onClick={handleClickCreate}
                    >
                      <BookmarkIcon className="size-4" />
                    </Button>
                    <BookmarkCreateDialog
                      bookId={bookId}
                      chapterNumber={chapterNumber}
                      pageNumber={pageNumber}
                      isOpen={isOpenBookmarkCreateDialog}
                      setIsOpen={setIsOpenBookmarkCreateDialog}
                      createMutation={createMutation}
                    />
                  </>
                )}
              </TooltipTrigger>
              <TooltipContent>
                {bookmark
                  ? bookmark.note
                    ? `メモ「${bookmark.note}」`
                    : 'ブックマークからから削除'
                  : 'ブックマークに追加'}
              </TooltipContent>
            </Tooltip>
          </div>
        </div>
        <p className="whitespace-pre-wrap">{bookContentPage.content}</p>
      </div>
      <div className="flex justify-between px-0 py-6 sm:px-12">
        <Button
          className={cn(
            'flex items-center gap-x-2 rounded-full hover:bg-transparent',
            isFirstPage && 'pointer-events-none opacity-30'
          )}
          variant="ghost"
          asChild
        >
          <Link to={prevPageLink}>
            <ChevronLeftIcon />
            <span>前のページへ</span>
          </Link>
        </Button>
        <Button
          className={cn(
            'flex items-center gap-x-2 rounded-full hover:bg-transparent',
            isLastPage && 'pointer-events-none opacity-30'
          )}
          variant="ghost"
          asChild
        >
          <Link to={nextPageLink}>
            <span>次のページへ</span>
            <ChevronRightIcon />
          </Link>
        </Button>
      </div>
    </div>
  );
}

------------------------------------------------------------
book-table-of-contents.tsx

import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useAuth } from '@/hooks/use-auth';
import { cn } from '@/lib/util';
import { useSuspenseQueries } from '@tanstack/react-query';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
};

export default function BookTableOfContents({ bookId }: Props) {
  const { getBookDetailsById, getBookTableOfContents } = useApiBook();
  const { user } = useAuth();

  const [{ data: book }, { data: bookTableOfContents }] = useSuspenseQueries({
    queries: [
      {
        queryKey: ['getBookDetailsById', bookId],
        queryFn: () => getBookDetailsById(bookId),
      },
      {
        queryKey: ['getBookTableOfContents', bookId],
        queryFn: () => getBookTableOfContents(bookId),
      },
    ],
  });

  return (
    <div className="delay-0 duration-200 animate-in fade-in-0">
      <div className="flex flex-col gap-y-12 px-4 py-12 sm:px-20">
        <div className="flex w-full flex-col items-center gap-y-6 sm:items-start">
          <p className="text-3xl font-bold sm:text-5xl">{book.title}</p>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                className={cn(
                  'w-44 rounded-full bg-transparent',
                  (!user || !bookTableOfContents.chapters.length) &&
                    'pointer-events-none opacity-50'
                )}
                variant="outline"
                asChild
              >
                <Link to={`/read/${bookId}/chapter/1/page/1`}>最初から読む</Link>
              </Button>
            </TooltipTrigger>
            {!user && <TooltipContent>ログインしてこの本を読みましょう</TooltipContent>}
          </Tooltip>
        </div>

        {bookTableOfContents.chapters.length ? (
          <ul className="flex w-full flex-col gap-y-8">
            {bookTableOfContents.chapters.map((chapter) => (
              <li className="w-full text-center sm:text-left" key={chapter.chapterNumber}>
                <p className="text-xs text-muted-foreground sm:text-sm">{`第 ${chapter.chapterNumber} 章`}</p>
                <Link
                  to={`/read/${bookId}/chapter/${chapter.chapterNumber}/page/1`}
                  className={cn(
                    'font-semibold hover:text-primary text-base sm:text-xl',
                    !user && 'pointer-events-none'
                  )}
                >
                  {chapter.chapterTitle}
                </Link>
              </li>
            ))}
          </ul>
        ) : (
          <p className="text-center sm:text-start">目次がありません</p>
        )}
      </div>
    </div>
  );
}

------------------------------------------------------------
bookmark-create-dialog.tsx

import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/hooks/use-toast';
import { BookmarkCreateMutation, BookmarkRequest } from '@/types';
import React, { useEffect, useRef, useState } from 'react';

type Props = {
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  createMutation?: BookmarkCreateMutation;
};

export default function BookmarkCreateDialog({
  bookId,
  chapterNumber,
  pageNumber,
  isOpen,
  setIsOpen,
  createMutation,
}: Props) {
  const [note, setNote] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { toast } = useToast();

  useEffect(() => {
    if (isOpen) {
      setNote('');
    }
  }, [isOpen]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handleCreate = () => {
    const requestBody: BookmarkRequest = {
      bookId,
      chapterNumber,
      pageNumber,
      note,
    };
    createMutation?.mutate(requestBody, {
      onSuccess: () => {
        toast({ title: 'ブックマークを作成しました' });
        setIsOpen(false);
      },
      onError: () => {
        toast({
          title: 'ブックマークの作成に失敗しました',
          description: '管理者へ連絡してください。',
          variant: 'destructive',
          duration: 5000,
        });
        setIsOpen(false);
      },
    });
  };

  const handleCloseDialog = () => {
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
        onAnimationStart={handleAnimationStart}
      >
        <div>
          <p className="font-semibold leading-10">ブックマーク</p>
          <p className="text-xs text-muted-foreground sm:text-sm">
            このブックマークにメモを残せます。メモが未入力でもブックマーク登録できます。
          </p>
        </div>

        <Textarea
          ref={ref}
          spellCheck={false}
          value={note}
          onChange={(e) => setNote(e.currentTarget.value)}
        />

        <DialogFooter className="gap-y-4 sm:gap-y-0">
          <Button
            className="min-w-24 rounded-full"
            variant="ghost"
            onClick={handleCloseDialog}
          >
            キャンセル
          </Button>
          <Button className="min-w-24 rounded-full" onClick={handleCreate}>
            作成
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
bookmark-item.tsx

import BookmarkUpdateDialog from '@/components/bookmarks/bookmark-update-dialog';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { formatDateJP, formatTime } from '@/lib/util';
import {
  Bookmark,
  BookmarkCreateMutation,
  BookmarkDeleteMutation,
  BookmarkUpdateMutation,
} from '@/types';
import { BookmarkIcon, SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';
import { Link } from 'react-router-dom';

type Props = {
  bookmark: Bookmark;
  createMutation?: BookmarkCreateMutation;
  updateMutation?: BookmarkUpdateMutation;
  deleteMutation?: BookmarkDeleteMutation;
};

export default function BookmarkItem({
  bookmark,
  updateMutation,
  deleteMutation,
}: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const handleClickUpdate = () => {
    setIsOpen(true);
  };

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: '!',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除',
    });
    if (isCancel) return;

    deleteMutation?.mutate(bookmark.id, {
      onSuccess: () => {
        toast({ title: 'ブックマークを削除しました' });
      },
    });
  };

  return (
    <Card>
      <CardContent>
        <div className="flex gap-x-4 px-3 py-4">
          <div className="flex min-w-20 justify-center sm:min-w-24">
            <Link
              to={`/read/${bookmark.bookId}/chapter/${bookmark.chapterNumber}/page/${bookmark.pageNumber}`}
              className="size-fit"
            >
              <img
                className="h-24 rounded object-cover sm:h-28"
                src={bookmark.book.imageUrl}
                alt={bookmark.book.title}
              />
            </Link>
          </div>
          <div className="flex w-full flex-col justify-center">
            <div className="mb-2 flex flex-col items-start gap-x-4 sm:flex-row sm:items-center">
              <Link
                to={`/read/${bookmark.bookId}/chapter/${bookmark.chapterNumber}/page/${bookmark.pageNumber}`}
                className="size-fit"
              >
                <p className="text-base font-semibold hover:text-primary sm:text-xl">
                  {bookmark.book.title}
                </p>
              </Link>
              <div className="flex flex-wrap items-center">
                <div className="flex size-8 items-center justify-center">
                  <BookmarkIcon
                    className="size-4 text-primary"
                    style={{ fill: 'hsl(var(--primary))' }}
                  />
                </div>
                <p className="mr-2 whitespace-nowrap text-xs leading-8 tracking-wide text-muted-foreground sm:text-sm">
                  {formatDateJP(bookmark.updatedAt)} {formatTime(bookmark.updatedAt)}
                </p>
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを編集"
                  onClick={handleClickUpdate}
                >
                  <SquarePenIcon className="size-4" />
                </Button>
                <BookmarkUpdateDialog
                  bookmark={bookmark}
                  isOpen={isOpen}
                  setIsOpen={setIsOpen}
                  updateMutation={updateMutation}
                />
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを削除"
                  onClick={handleClickDelete}
                >
                  <Trash2Icon className="size-4" />
                </Button>
              </div>
            </div>
            <p className="mb-4 text-xs text-muted-foreground sm:text-sm">
              第 {bookmark.chapterNumber} 章 : {bookmark.chapterTitle}（
              {bookmark.pageNumber}ページ目）
            </p>
            <p className="text-muted-foreground">
              {bookmark.note && <span>{bookmark.note}</span>}
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
bookmark-update-dialog.tsx

import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import {
  Bookmark,
  BookmarkDeleteMutation,
  BookmarkRequest,
  BookmarkUpdateMutation,
} from '@/types';
import React, { useEffect, useRef, useState } from 'react';
import { useLocation } from 'react-router-dom';

type Props = {
  bookmark: Bookmark;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  updateMutation?: BookmarkUpdateMutation;
  deleteMutation?: BookmarkDeleteMutation;
};

export default function BookmarkUpdateDialog({
  bookmark,
  isOpen,
  setIsOpen,
  updateMutation,
  deleteMutation,
}: Props) {
  const [note, setNote] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const location = useLocation();

  const { confirmDialog } = useConfirmDialog();
  const { toast } = useToast();

  useEffect(() => {
    if (isOpen) {
      setNote(bookmark.note);
    }
  }, [isOpen, bookmark.note]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handleDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: '!',
      title: 'このブックマークを削除しますか？',
      message: 'ブックマークのメモも削除されます。',
    });
    if (isCancel) return;

    deleteMutation?.mutate(bookmark.id, {
      onSuccess: () => {
        toast({ title: 'ブックマークを削除しました' });
        setIsOpen(false);
      },
      onError: () => {
        toast({
          title: 'ブックマークの削除に失敗しました',
          description: '管理者へ連絡してください。',
          variant: 'destructive',
          duration: 5000,
        });
        setIsOpen(false);
      },
    });
  };

  const handleUpdate = () => {
    const requestBody: BookmarkRequest = {
      bookId: bookmark.bookId,
      chapterNumber: bookmark.chapterNumber,
      pageNumber: bookmark.pageNumber,
      note,
    };
    updateMutation?.mutate(
      { id: bookmark.id, requestBody },
      {
        onSuccess: () => {
          toast({ title: 'ブックマークのメモを更新しました' });
          setIsOpen(false);
        },
        onError: () => {
          toast({
            title: 'ブックマークのメモを更新に失敗しました',
            description: '管理者へ連絡してください。',
            variant: 'destructive',
            duration: 5000,
          });
          setIsOpen(false);
        },
      }
    );
  };

  const handleCloseDialog = () => {
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
        onAnimationStart={handleAnimationStart}
      >
        <div>
          <p className="font-semibold leading-10">ブックマーク</p>
          <p className="text-xs text-muted-foreground sm:text-sm">
            メモを編集できます。メモが未入力でもブックマーク登録は消えません。
          </p>
        </div>

        <Textarea
          ref={ref}
          spellCheck={false}
          value={note}
          onChange={(e) => setNote(e.currentTarget.value)}
        />

        <DialogFooter className="gap-y-4 sm:gap-y-0">
          <Button
            className="min-w-24 rounded-full"
            variant="ghost"
            onClick={handleCloseDialog}
          >
            キャンセル
          </Button>
          {location.pathname.includes('read') && (
            <Button
              className="min-w-24 rounded-full"
              variant="outline"
              onClick={handleDelete}
            >
              削除
            </Button>
          )}
          <Button className="min-w-24 rounded-full" onClick={handleUpdate}>
            更新
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
book-item.tsx

import AverageRatingIcon from '@/components/count-icon/average-rating-icon';
import ReviewCountIcon from '@/components/count-icon/review-count-icon';
import { Card, CardContent } from '@/components/ui/card';
import { formatDateJP } from '@/lib/util';
import { Book } from '@/types';
import { Link } from 'react-router-dom';

type Props = {
  book: Book;
};

export default function BookItem({ book }: Props) {
  return (
    <Card className="border-card-foreground/5 bg-card/70">
      <CardContent className="relative flex w-40 flex-col items-center px-3 pb-2 pt-4 sm:w-48 sm:px-4">
        <Link to={`/book/${book.id}`} className="size-fit">
          <img
            className="h-44 rounded object-cover sm:h-52"
            src={book.imageUrl}
            alt={book.title}
          />
        </Link>
        <Link
          to={`/book/${book.id}`}
          className="mt-1 flex h-8 w-full items-center justify-center text-xs hover:text-primary sm:h-10 sm:text-sm"
        >
          <p className="line-clamp-2 text-center">{book.title}</p>
        </Link>
        <div className="mt-1 flex w-full flex-col items-center gap-y-1">
          <p className="text-xs tracking-wide text-muted-foreground">
            {formatDateJP(book.publishedDate)}
          </p>
          <div className="flex gap-x-2">
            <AverageRatingIcon size="sm" averageRating={book.averageRating} />
            <ReviewCountIcon size="sm" reviewCount={book.reviewCount} />
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
favorite-count-icon.tsx

import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useApiFavorite } from '@/hooks/api/use-api-favorite';
import { useAuth } from '@/hooks/use-auth';
import { cn } from '@/lib/util';
import { FavoriteInfo, FavoriteRequest } from '@/types';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { HeartIcon } from 'lucide-react';

const BUTTON_SIZE = { sm: 'size-6', md: 'size-8' };
const ICON_SIZE = { sm: 'size-3', md: 'size-4' };
const TEXT_SIZE = { sm: 'text-xs', md: 'text-sm' };

type Props = {
  bookId: string;
  size?: 'sm' | 'md';
  showCount?: boolean;
};

export default function FavoriteCountIcon({
  bookId,
  size = 'md',
  showCount = false,
}: Props) {
  const { user } = useAuth();
  const { getFavoriteInfo, createFavorite, deleteFavorite } = useApiFavorite();

  const queryClient = useQueryClient();

  const queryKey = ['getFavoriteInfo', bookId, user?.id];
  const { data: favoriteInfo = { isFavorite: false, favoriteCount: 0 } } = useQuery({
    queryKey,
    queryFn: () => getFavoriteInfo(bookId, user?.id),
  });

  const {
    mutate: toggleMutation,
    variables,
    isPending,
  } = useMutation({
    mutationFn: async (newFavorite: FavoriteInfo) => {
      if (newFavorite.isFavorite) {
        const requestBody: FavoriteRequest = { bookId };
        await createFavorite(requestBody);
      } else {
        await deleteFavorite(bookId);
      }
    },
    onMutate: async (newFavoriteInfo: FavoriteInfo) => {
      await queryClient.cancelQueries({ queryKey });
      const previousFavoriteInfo = queryClient.getQueryData(queryKey);
      queryClient.setQueryData(queryKey, newFavoriteInfo);
      return { previousFavoriteInfo };
    },
    onSettled: (_newFavoriteInfo, error, _variables, context) => {
      if (error) {
        queryClient.setQueryData(queryKey, context?.previousFavoriteInfo);
      }
      queryClient.invalidateQueries({ queryKey });
    },
    onError: (error) => {
      console.error(error);
    },
  });

  const handleClick = () => {
    if (!user) return;

    const newFavoriteInfo: FavoriteInfo = {
      isFavorite: !favoriteInfo.isFavorite,
      favoriteCount: favoriteInfo.isFavorite
        ? favoriteInfo.favoriteCount - 1
        : favoriteInfo.favoriteCount + 1,
    };
    toggleMutation(newFavoriteInfo);
  };

  const optimisticData = isPending ? variables : favoriteInfo;

  return (
    <div className="flex items-center">
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className={cn(
              'rounded-full text-muted-foreground',
              BUTTON_SIZE[size],
              optimisticData?.isFavorite && 'text-primary bg-transparent'
            )}
            variant="ghost"
            size="icon"
            aria-label={
              optimisticData?.isFavorite ? 'お気に入りから削除' : 'お気に入りに追加'
            }
            onClick={handleClick}
          >
            <HeartIcon
              className={ICON_SIZE[size]}
              style={{
                fill: optimisticData?.isFavorite ? 'hsl(var(--primary))' : '',
              }}
            />
          </Button>
        </TooltipTrigger>
        {user ? (
          <TooltipContent>
            {optimisticData?.isFavorite ? 'お気に入りから削除' : 'お気に入りに追加'}
          </TooltipContent>
        ) : (
          <TooltipContent>
            ログインしてこの本を「お気に入り」に加えましょう
          </TooltipContent>
        )}
      </Tooltip>

      {showCount && (
        <p
          className={cn(
            'flex min-w-4 text-muted-foreground justify-center',
            TEXT_SIZE[size]
          )}
        >
          {optimisticData?.favoriteCount}
        </p>
      )}
    </div>
  );
}

------------------------------------------------------------
favorite-item.tsx

import FavoriteCountIcon from '@/components/count-icon/favorite-count-icon';
import { Card, CardContent } from '@/components/ui/card';
import { formatDateJP, formatTime } from '@/lib/util';
import { Favorite } from '@/types';
import { Link } from 'react-router-dom';

type Props = {
  favorite: Favorite;
};

export default function FavoriteItem({ favorite }: Props) {
  return (
    <Card>
      <CardContent>
        <div className="flex gap-x-4 px-3 py-4">
          <div className="flex min-w-20 justify-center sm:min-w-24">
            <Link to={`/book/${favorite.book.id}`} className="size-fit">
              <img
                className="h-24 rounded object-cover sm:h-28"
                src={favorite.book.imageUrl}
                alt={favorite.book.title}
              />
            </Link>
          </div>
          <div className="flex w-full flex-col justify-center">
            <div className="mb-2 flex flex-col items-start gap-x-4 sm:flex-row sm:items-center">
              <Link to={`/book/${favorite.book.id}`} className="size-fit">
                <p className="text-base font-semibold hover:text-primary sm:text-xl">
                  {favorite.book.title}
                </p>
              </Link>
              <div className="flex items-center">
                <FavoriteCountIcon bookId={favorite.bookId} />
                <p className="mr-2 whitespace-nowrap text-xs leading-8 tracking-wide text-muted-foreground sm:text-sm">
                  {formatDateJP(favorite.updatedAt)} {formatTime(favorite.updatedAt)}
                </p>
              </div>
            </div>
            <div className="mb-4 flex w-full flex-wrap items-center gap-x-3 text-muted-foreground">
              <p className="text-xs">著者</p>
              {favorite.book.authors.map((author) => (
                <p className="text-sm" key={author}>
                  {author}
                </p>
              ))}
            </div>
            <p className="text-muted-foreground">{favorite.book.description}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
footer.tsx

import Logo from '@/components/layout/logo';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/util';
import { FacebookIcon, InstagramIcon, TwitterIcon, YoutubeIcon } from 'lucide-react';

type Props = {
  className?: string;
};

export default function Footer({ className }: Props) {
  return (
    <footer className={cn('bg-card', className)}>
      <div className="mx-auto max-w-7xl px-3 sm:px-6">
        <div className="grid items-center justify-center py-2 sm:grid-cols-3">
          <div>
            <Button
              className="rounded-full"
              variant="ghost"
              size="icon"
              aria-label="Youtube"
            >
              <YoutubeIcon className="size-5" />
            </Button>
            <Button
              className="rounded-full"
              variant="ghost"
              size="icon"
              aria-label="Twitter"
            >
              <TwitterIcon className="size-5" />
            </Button>
            <Button
              className="rounded-full"
              variant="ghost"
              size="icon"
              aria-label="Instagram"
            >
              <InstagramIcon className="size-5" />
            </Button>
            <Button
              className="rounded-full"
              variant="ghost"
              size="icon"
              aria-label="Facebook"
            >
              <FacebookIcon className="size-5" />
            </Button>
          </div>
          <p className="grid h-7 place-items-center text-sm">© 2025 Xxxxx, Inc.</p>
          <div className="flex justify-center sm:justify-end">
            <Logo size="sm" />
          </div>
        </div>
      </div>
    </footer>
  );
}

------------------------------------------------------------
logo.tsx

import { LOGO_TITLE } from '@/constants/constants';
import { cn } from '@/lib/util';
import { Link } from 'react-router-dom';

type Props = {
  className?: string;
  size?: 'sm' | 'md' | 'lg';
  disableLink?: boolean;
  onClick?: () => void;
};

export default function Logo({
  className,
  size = 'md',
  disableLink = false,
  onClick,
}: Props) {
  const SIZE = {
    sm: 'text-xl',
    md: 'text-3xl',
    lg: 'text-5xl',
  };

  return (
    <h1 className={className}>
      <Link
        to="/"
        className={cn(
          "select-none whitespace-nowrap font-['Alfa_Slab_One'] tracking-tighter text-primary",
          'px-4 py-2 ',
          disableLink && 'cursor-default pointer-events-none',
          SIZE[size]
        )}
        aria-disabled={disableLink}
        onClick={onClick}
      >
        {LOGO_TITLE}
      </Link>
    </h1>
  );
}

------------------------------------------------------------
nav-list.tsx

import Logo from '@/components/layout/logo';
import MenuList from '@/components/layout/menu-list';
import { Button } from '@/components/ui/button';
import { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet';
import { useWindowSize } from '@/hooks/use-window-size';
import { MenuIcon } from 'lucide-react';
import { useState } from 'react';

export default function NavList() {
  const [isOpen, setIsOpen] = useState(false);

  const DEBOUNCED_DELAY = 100;
  const { width } = useWindowSize(DEBOUNCED_DELAY);

  const TABLET_WIDTH = 1024;
  if (isOpen && width >= TABLET_WIDTH) {
    setIsOpen(false);
  }

  return (
    <>
      <div className="hidden lg:flex lg:items-center lg:gap-x-8">
        <Logo />
        <MenuList />
      </div>

      <Sheet open={isOpen} onOpenChange={setIsOpen}>
        <SheetTrigger asChild>
          <Button
            className="rounded-full lg:hidden"
            variant="ghost"
            size="icon"
            aria-label="メニュー"
          >
            <MenuIcon className="size-5" />
          </Button>
        </SheetTrigger>
        <SheetContent className="w-fit p-8" side="left">
          <Logo className="mb-8" onClick={() => setIsOpen(false)} />
          <MenuList onClick={() => setIsOpen(false)} />
        </SheetContent>
      </Sheet>
    </>
  );
}

------------------------------------------------------------
theme-toggle-button.tsx

import { Button } from '@/components/ui/button';
import { MoonIcon, SunIcon } from 'lucide-react';
import { useEffect, useState } from 'react';

export default function ThemeToggleButton() {
  const [theme, setTheme] = useState('');

  useEffect(() => {
    const body = document.querySelector('body');
    if (body?.classList.contains('dark')) {
      setTheme('dark');
    } else {
      setTheme('light');
    }
  }, []);

  const handleClick = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
    const body = document.querySelector('body');
    body?.classList.toggle('light');
    body?.classList.toggle('dark');
  };

  return (
    <Button
      className="rounded-full"
      variant="ghost"
      size="icon"
      aria-label={theme === 'light' ? 'ダークモードに切り替え' : 'ライトモードに切り替え'}
      onClick={handleClick}
    >
      {theme === 'light' ? (
        <MoonIcon className="size-5" />
      ) : (
        <SunIcon className="size-5" />
      )}
    </Button>
  );
}

------------------------------------------------------------
user-icon-button.tsx

import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { MENU_LIST } from '@/constants/constants';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/util';
import { useMutation } from '@tanstack/react-query';
import { LogOutIcon } from 'lucide-react';
import { useEffect, useState } from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';

export default function UserIconButton() {
  const [isOpen, setIsOpen] = useState(false);

  const navigate = useNavigate();
  const location = useLocation();
  const pathname = location.pathname;

  const { accessToken, user, setUser, logout } = useAuth();
  const { getCurrentUser } = useApiUser();
  const { toast } = useToast();

  const logoutMutation = useMutation({
    mutationFn: () => logout(),
    onError: (error) => {
      console.error(error);
    },
  });

  useEffect(() => {
    const init = async () => {
      if (accessToken && !user) {
        const currentUser = await getCurrentUser();
        setUser(currentUser);
      }
    };
    init();
  }, [accessToken, getCurrentUser, setUser, user]);

  const handleClickLogout = async () => {
    logoutMutation.mutate(undefined, {
      onSuccess: () => {
        toast({ title: 'ログアウトしました' });
        setIsOpen(false);
        navigate('/');
      },
    });
  };

  const handleClickMenuItem = (href: string) => {
    navigate(href);
    setIsOpen(false);
  };

  if (!user)
    return (
      <Button className="rounded-full" variant="ghost" asChild>
        <Link to="/login" state={{ from: location }}>
          ログイン
        </Link>
      </Button>
    );

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger className="ml-2 flex items-center justify-center" asChild>
        <Button
          className="rounded-full"
          variant="ghost"
          size="icon"
          aria-label="アバター画像"
        >
          <Avatar>
            <AvatarImage
              className="bg-primary/50"
              src={user.avatarUrl}
              alt="avatar-image"
            />
            <AvatarFallback className="text-lg font-semibold">
              {user.name.slice(0, 1)}
            </AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-48 p-2" side="bottom" align="end">
        <DropdownMenuLabel>
          <div className="flex items-center gap-x-2">
            <Avatar className="size-8">
              <AvatarImage
                className="bg-primary/50"
                src={user.avatarUrl}
                alt="avatar-image"
              />
              <AvatarFallback className="font-semibold">
                {user.name.slice(0, 1)}
              </AvatarFallback>
            </Avatar>
            <div className="flex-1 overflow-hidden">
              <p className="truncate">{user.name}</p>
              <p className="truncate text-xs font-normal text-muted-foreground">
                {user.email}
              </p>
            </div>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        {MENU_LIST.map((item) => (
          <DropdownMenuItem
            className={cn(
              pathname !== '/' && item.href.includes(pathname) && 'text-primary'
            )}
            key={item.href}
            onClick={() => handleClickMenuItem(item.href)}
          >
            <item.icon className="mr-1" />
            {item.title}
          </DropdownMenuItem>
        ))}
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={handleClickLogout}>
          <LogOutIcon className="mr-1" />
          ログアウト
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

------------------------------------------------------------
my-review-item.tsx

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/reviews/review-update-dialog';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { formatDateJP, formatTime } from '@/lib/util';
import {
  Review,
  ReviewCreateMutation,
  ReviewDeleteMutation,
  ReviewUpdateMutation,
} from '@/types';
import { SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';
import { Link } from 'react-router-dom';

type Props = {
  review: Review;
  createMutation?: ReviewCreateMutation;
  updateMutation?: ReviewUpdateMutation;
  deleteMutation?: ReviewDeleteMutation;
};

export default function MyReviewItem({ review, updateMutation, deleteMutation }: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const handleClickUpdate = () => {
    setIsOpen(true);
  };

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: '!',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除',
    });
    if (isCancel) return;

    deleteMutation?.mutate(review.id, {
      onSuccess: () => {
        toast({ title: 'レビューを削除しました' });
      },
    });
  };

  return (
    <Card>
      <CardContent>
        <div className="flex gap-x-4 px-3 py-4">
          <div className="flex min-w-20 justify-center sm:min-w-24">
            <Link to={`/book/${review.book.id}`} className="size-fit">
              <img
                className="h-24 rounded object-cover sm:h-28"
                src={review.book.imageUrl}
                alt={review.book.title}
              />
            </Link>
          </div>
          <div className="flex w-full flex-col justify-center">
            <Link to={`/book/${review.book.id}`} className="size-fit">
              <p className="text-base font-semibold hover:text-primary sm:text-xl">
                {review.book.title}
              </p>
            </Link>
            <div className="mb-2 flex flex-col items-start sm:flex-row sm:items-center">
              <div className="mr-2">
                <Rating rating={review.rating} readOnly />
              </div>
              <div className="flex flex-wrap items-center">
                <p className="mr-2 whitespace-nowrap text-xs leading-8 tracking-wide text-muted-foreground sm:text-sm">
                  {formatDateJP(review.updatedAt)} {formatTime(review.updatedAt)}
                </p>
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを編集"
                  onClick={handleClickUpdate}
                >
                  <SquarePenIcon className="size-4" />
                </Button>
                <ReviewUpdateDialog
                  review={review}
                  isOpen={isOpen}
                  setIsOpen={setIsOpen}
                  updateMutation={updateMutation}
                />
                <Button
                  className="size-8 rounded-full text-muted-foreground"
                  variant="ghost"
                  size="icon"
                  aria-label="レビューを削除"
                  onClick={handleClickDelete}
                >
                  <Trash2Icon className="size-4" />
                </Button>
              </div>
            </div>
            <p className="text-muted-foreground">{review.comment}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

------------------------------------------------------------
review-create-dialog.tsx

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { ReviewCreateMutation, ReviewRequest } from '@/types';
import React, { useEffect, useRef, useState } from 'react';

type Props = {
  bookId: string;
  page: number;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  createMutation?: ReviewCreateMutation;
};

export default function ReviewCreateDialog({
  bookId,
  isOpen,
  setIsOpen,
  createMutation,
}: Props) {
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  useEffect(() => {
    if (isOpen) {
      setRating(0);
      setComment('');
    }
  }, [isOpen]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handleClickPost = async () => {
    if (rating === 0) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: 'このまま投稿しますか？',
        message: '星の数が「0」のままです。',
        actionLabel: '投稿',
      });
      if (isCancel) return;
    }

    const requestBody: ReviewRequest = { bookId, comment, rating };
    createMutation?.mutate(requestBody, {
      onSuccess: () => {
        toast({ title: 'レビューを投稿しました' });
        setIsOpen(false);
      },
      onError: () => {
        toast({
          title: 'レビュー投稿に失敗しました',
          description: '管理者へ連絡してください。',
          variant: 'destructive',
          duration: 5000,
        });
        setIsOpen(false);
      },
    });
  };

  const handleClickCancel = async () => {
    if (comment) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: 'キャンセルして閉じますか？',
        message: 'コメントはまだ投稿していません。',
        persistent: true,
      });
      if (isCancel) return;
    }
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleClickCancel}
        onPointerDownOutside={handleClickCancel}
        onAnimationStart={handleAnimationStart}
      >
        <div className="flex items-start justify-between">
          <div>
            <p className="font-semibold leading-10">レビュー</p>
            <p className="text-xs text-muted-foreground sm:text-sm">
              素敵な感想を伝えましょう！
            </p>
          </div>
          <div>
            <Rating rating={rating} onChange={setRating} />
            <p className="text-center text-xs text-muted-foreground sm:text-sm">
              星をクリックして決定
            </p>
          </div>
        </div>

        <Textarea
          ref={ref}
          spellCheck={false}
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />

        <DialogFooter className="gap-y-4 sm:gap-y-0">
          <Button
            className="min-w-24 rounded-full"
            variant="ghost"
            onClick={handleClickCancel}
          >
            キャンセル
          </Button>
          <Button
            className="min-w-24 rounded-full"
            disabled={comment === ''}
            onClick={handleClickPost}
          >
            投稿
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
review-item.tsx

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/reviews/review-update-dialog';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { useAuth } from '@/hooks/use-auth';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { formatDateJP, formatTime } from '@/lib/util';
import {
  Review,
  ReviewCreateMutation,
  ReviewDeleteMutation,
  ReviewUpdateMutation,
} from '@/types';
import { SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';

type Props = {
  review: Review;
  createMutation?: ReviewCreateMutation;
  updateMutation?: ReviewUpdateMutation;
  deleteMutation?: ReviewDeleteMutation;
};

export default function ReviewItem({ review, updateMutation, deleteMutation }: Props) {
  const [isOpen, setIsOpen] = useState(false);

  const { user } = useAuth();
  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const handleClickUpdate = () => {
    setIsOpen(true);
  };

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: '!',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除',
    });
    if (isCancel) return;

    deleteMutation?.mutate(review.id, {
      onSuccess: () => {
        toast({ title: 'レビューを削除しました' });
      },
    });
  };

  return (
    <div className="delay-0 duration-500 animate-in fade-in-0 slide-in-from-top-2 fill-mode-both">
      <div className="p-4">
        <div className="flex flex-col items-center justify-between sm:flex-row">
          <div className="flex w-full items-center gap-x-4">
            <Avatar className="size-16">
              <AvatarImage
                className="bg-primary/50"
                src={review.avatarUrl}
                alt="avatar-image"
              />
              <AvatarFallback className="font-semibold">
                {review.name.slice(0, 1)}
              </AvatarFallback>
            </Avatar>
            <div>
              <p className="-mb-1 text-lg font-semibold">{review.name}</p>
              <div className="flex items-center">
                <p className="whitespace-nowrap text-sm leading-8 tracking-wide text-muted-foreground">
                  {formatDateJP(review.updatedAt)} {formatTime(review.updatedAt)}
                </p>
                <div className="ml-2 flex w-16">
                  {user?.id === review.userId && (
                    <>
                      <Button
                        className="size-8 rounded-full text-muted-foreground"
                        variant="ghost"
                        size="icon"
                        aria-label="レビューを編集"
                        onClick={handleClickUpdate}
                      >
                        <SquarePenIcon className="size-4" />
                      </Button>
                      <ReviewUpdateDialog
                        review={review}
                        isOpen={isOpen}
                        setIsOpen={setIsOpen}
                        updateMutation={updateMutation}
                      />
                      <Button
                        className="size-8 rounded-full text-muted-foreground"
                        variant="ghost"
                        size="icon"
                        aria-label="レビューを削除"
                        onClick={handleClickDelete}
                      >
                        <Trash2Icon className="size-4" />
                      </Button>
                    </>
                  )}
                </div>
              </div>
            </div>
          </div>
          <Rating rating={review.rating} readOnly />
        </div>
        <p className="mt-2 text-muted-foreground sm:pl-20">{review.comment}</p>
      </div>
    </div>
  );
}

------------------------------------------------------------
review-update-dialog.tsx

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/hooks/use-toast';
import { Review, ReviewRequest, ReviewUpdateMutation } from '@/types';
import React, { useEffect, useRef, useState } from 'react';

type Props = {
  review: Review;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  updateMutation?: ReviewUpdateMutation;
};

export default function ReviewUpdateDialog({
  review,
  isOpen,
  setIsOpen,
  updateMutation,
}: Props) {
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { toast } = useToast();

  useEffect(() => {
    if (isOpen) {
      setRating(review.rating);
      setComment(review.comment);
    }
  }, [isOpen, review.comment, review.rating]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handleClickUpdate = () => {
    const requestBody: ReviewRequest = { bookId: review.bookId, comment, rating };
    updateMutation?.mutate(
      { id: review.id, requestBody },
      {
        onSuccess: () => {
          toast({ title: 'レビューを更新しました' });
          setIsOpen(false);
        },
        onError: () => {
          toast({
            title: 'レビューの更新に失敗しました',
            description: '管理者へ連絡してください。',
            variant: 'destructive',
            duration: 5000,
          });
          setIsOpen(false);
        },
      }
    );
  };

  const handleClickCancel = async () => {
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent
        className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
        onEscapeKeyDown={handleClickCancel}
        onPointerDownOutside={handleClickCancel}
        onAnimationStart={handleAnimationStart}
      >
        <div className="flex items-start justify-between">
          <div>
            <p className="font-semibold leading-10">レビュー</p>
            <p className="text-xs text-muted-foreground sm:text-sm">
              レビュー内容を編集できます。
            </p>
          </div>
          <div>
            <Rating rating={rating} onChange={setRating} />
            <p className="text-center text-xs text-muted-foreground sm:text-sm">
              星をクリックして決定
            </p>
          </div>
        </div>

        <Textarea
          ref={ref}
          spellCheck={false}
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />

        <DialogFooter className="gap-y-4 sm:gap-y-0">
          <Button
            className="min-w-24 rounded-full"
            variant="ghost"
            onClick={handleClickCancel}
          >
            キャンセル
          </Button>
          <Button
            className="min-w-24 rounded-full"
            disabled={comment === ''}
            onClick={handleClickUpdate}
          >
            更新
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

------------------------------------------------------------
avatar-carousel.tsx

import SwipeArea from '@/components/settings/swipe-area';
import { Avatar, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { AVATAR_URLS } from '@/constants/constants';
import { cn } from '@/lib/util';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { useRef, useState } from 'react';

type Props = {
  value: string;
  onChange: (avatarUrl: string) => void;
};

export default function AvatarCarousel({ value, onChange }: Props) {
  // 座標など調整用の値
  const itemWidth = 70;
  const frameWidth = 192;
  const paddingItem = 2;
  const marginLeft = Math.floor(frameWidth / 2) - Math.floor(itemWidth / 2);

  // 配列の最初と最後の切れ目部分にアイテムを追加しておく
  // 循環参照するときの見た目の調整のため
  const extendedAvatarUrls = [
    ...AVATAR_URLS.slice(-paddingItem),
    ...AVATAR_URLS,
    ...AVATAR_URLS.slice(0, paddingItem),
  ];

  // 引数のvalueが見つからなかった場合、findIndex()は-1を返すので、
  // Math.max()で最小でも0になるようにする
  const defaultIndex = Math.max(
    0,
    AVATAR_URLS.findIndex((avatarUrl) => avatarUrl === value)
  );

  // インデックス番号でカルーセルを制御
  // innerIndexは内部的なインデックスとして使用（スクロールアニメーション用）
  const [currentIndex, setCurrentIndex] = useState(defaultIndex);
  const [innerIndex, setInnerIndex] = useState(defaultIndex);

  const [isScrolling, setIsScrolling] = useState(false);
  const carouselRef = useRef<HTMLUListElement>(null);

  const handlePrev = () => {
    if (isScrolling) return;
    setIsScrolling(true);
    setInnerIndex(innerIndex - 1);

    const prevIndex = (currentIndex - 1 + AVATAR_URLS.length) % AVATAR_URLS.length;
    setCurrentIndex(prevIndex);
    onChange(AVATAR_URLS[prevIndex]);
  };

  const handleNext = () => {
    if (isScrolling) return;
    setIsScrolling(true);
    setInnerIndex(innerIndex + 1);

    const nextIndex = (currentIndex + 1) % AVATAR_URLS.length;
    setCurrentIndex(nextIndex);
    onChange(AVATAR_URLS[nextIndex]);
  };

  const handleTransitonEnd = () => {
    setIsScrolling(false);
    setInnerIndex(currentIndex);

    // 循環スクロールのために、先頭から終端などに座標を変化させるとスクロールの
    // ちらつきが発生してしまうので、切れ目の変化ではアニメーションをいったんOffにする
    if (currentIndex === 0 || currentIndex === AVATAR_URLS.length - 1) {
      setIsScrolling(true);
      carouselRef.current!.style.transitionProperty = 'none';
      setTimeout(() => {
        carouselRef.current!.style.transitionProperty = 'transform';
        setIsScrolling(false);
      }, 75);
    }
  };

  return (
    <div className="flex items-center justify-center">
      <Button
        className="rounded-full"
        type="button"
        variant="ghost"
        size="icon"
        aria-label="前へ"
        onClick={handlePrev}
      >
        <ChevronLeft className="size-4" />
      </Button>

      <div
        className="relative w-full select-none overflow-hidden"
        style={{ width: `${frameWidth}px` }}
      >
        <ul
          ref={carouselRef}
          className="flex transition-transform duration-200"
          style={{
            transform: `translateX(-${(innerIndex + paddingItem) * itemWidth}px)`,
            marginLeft: `${marginLeft}px`,
          }}
          onTransitionEnd={handleTransitonEnd}
        >
          {extendedAvatarUrls.map((avatarUrl, index) => (
            <li
              key={index}
              className={`flex shrink-0 items-center justify-center`}
              style={{ width: `${itemWidth}px` }}
            >
              <div className="relative flex h-24 items-center">
                <Avatar
                  className={cn(
                    'transition-all duration-200',
                    'size-12 opacity-25 scale-100',
                    avatarUrl === AVATAR_URLS[currentIndex] &&
                      'opacity-100 scale-150 outline-1 outline-offset-1 outline outline-primary'
                  )}
                >
                  <AvatarImage
                    className="bg-primary"
                    src={avatarUrl}
                    alt="avatar-image"
                    draggable={false}
                  />
                </Avatar>
              </div>
            </li>
          ))}
        </ul>
        <SwipeArea
          className="absolute left-0 top-0 h-24 w-full"
          onSwipeLeft={handleNext}
          onSwipeRight={handlePrev}
        />
      </div>

      <Button
        className="rounded-full"
        type="button"
        variant="ghost"
        size="icon"
        aria-label="次へ"
        onClick={handleNext}
      >
        <ChevronRight className="size-4" />
      </Button>
    </div>
  );
}

------------------------------------------------------------
password-input.tsx

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { EyeIcon, EyeOffIcon } from 'lucide-react';
import React, { useState } from 'react';

const PasswordInput = React.forwardRef<HTMLInputElement, React.ComponentProps<'input'>>(
  ({ className, ...props }, ref) => {
    const [isShownPassword, setIsShownPassword] = useState(false);

    return (
      <div className="relative">
        <Input
          ref={ref}
          className={className}
          type={isShownPassword ? 'text' : 'password'}
          {...props}
        />
        <Button
          className="absolute right-0 top-0 rounded-full hover:bg-transparent hover:text-foreground"
          variant="ghost"
          size="icon"
          aria-label={isShownPassword ? 'パスワードを非表示' : 'パスワードを表示'}
          type="button"
          onClick={() => setIsShownPassword(!isShownPassword)}
        >
          {isShownPassword ? (
            <EyeIcon className="size-4" />
          ) : (
            <EyeOffIcon className="size-4" />
          )}
        </Button>
      </div>
    );
  }
);

export default PasswordInput;

------------------------------------------------------------
confirm-dialog.tsx

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { ConfirmDialogOptions } from '@/hooks/use-confirm-dialog';
import {
  AlertTriangleIcon,
  CheckCircle2Icon,
  HelpCircleIcon,
  InfoIcon,
  LucideProps,
} from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { cn } from '@/lib/util';
import React, { useEffect, useRef, useState } from 'react';

type IconType = {
  [key: string]: {
    icon: React.ForwardRefExoticComponent<
      Omit<LucideProps, 'ref'> & React.RefAttributes<SVGSVGElement>
    >;
    variant: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost';
    color: string;
  };
};

const iconTypes: IconType = {
  ['']: { icon: InfoIcon, variant: 'default', color: '' },
  ['i']: { icon: InfoIcon, variant: 'default', color: '' },
  ['?']: { icon: HelpCircleIcon, variant: 'default', color: '' },
  ['!']: { icon: AlertTriangleIcon, variant: 'destructive', color: 'text-destructive' },
  ['c']: { icon: CheckCircle2Icon, variant: 'default', color: '' },
};

const defaultOptions: ConfirmDialogOptions = {
  icon: '',
  title: '',
  message: '',
  actionLabel: 'OK',
  actionOnly: false,
  persistent: false,
  showInput: false,
  inputLabel: '',
  inputPlaceholder: '',
  inputRows: 1,
};

export const CONFIRM_DIALOG_EVENT = 'CONFIRM_DIALOG_EVENT';

type SELECTED_BUTTON = 'action' | 'cancel' | undefined;

const ConfirmDialog = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [options, setOptions] = useState<ConfirmDialogOptions>(defaultOptions);
  const refTextarea = useRef<HTMLTextAreaElement | null>(null);
  const Icon = iconTypes[options.icon].icon || InfoIcon;

  // hooksから呼ぶためにイベントリスナー登録
  useEffect(() => {
    const handleEvent = (event: CustomEvent<ConfirmDialogOptions>) => {
      setIsOpen(true);
      setOptions({ ...defaultOptions, ...event.detail });
    };
    document.addEventListener(CONFIRM_DIALOG_EVENT, handleEvent as EventListener);
    return () => {
      document.removeEventListener(CONFIRM_DIALOG_EVENT, handleEvent as EventListener);
    };
  }, []);

  // アニメーションフラグ（閉じれないことを伝えるためにぶるっとする）
  const [isPersistentAnimation, setIsPersistentAnimation] = useState(false);

  // ダイアログを閉じる時のイベント
  const handleCloseDialog = () => {
    if (options.persistent) {
      setIsPersistentAnimation(true);
      setTimeout(() => {
        setIsPersistentAnimation(false);
      }, 50);
      return;
    }
    handleClickCancel();
  };

  // 押したボタンによって、戻り値（resolveの引数も変更する）
  const [selected, setSelected] = useState<SELECTED_BUTTON>();

  const handleClickAction = () => {
    setIsOpen(false);
    setSelected('action');
  };

  const handleClickCancel = () => {
    setIsOpen(false);
    setSelected('cancel');
  };

  const handleAnimationEnd = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      if (isOpen && options.showInput) {
        refTextarea.current?.focus();
      }
    } else if (e.animationName === 'exit') {
      switch (selected) {
        case 'action':
          options.resolve?.({
            isAction: true,
            isCancel: false,
            text: refTextarea.current?.value || '',
          });
          return;
        case 'cancel':
          options.resolve?.({
            isAction: false,
            isCancel: true,
            text: '',
          });
          return;
      }
    }
  };

  return (
    <Dialog open={isOpen}>
      <DialogContent
        className={cn(
          'w-[360px] sm:w-[400px] transition-transform ease-in-out [transition-duration:25ms]',
          isPersistentAnimation && 'scale-[1.02] transform'
        )}
        onEscapeKeyDown={handleCloseDialog}
        onPointerDownOutside={handleCloseDialog}
        onAnimationEnd={handleAnimationEnd}
      >
        <DialogHeader>
          <DialogTitle className="my-2 flex items-center">
            <Icon className={cn('mr-3 min-w-fit', iconTypes[options.icon].color)} />
            <p className=" leading-6">{options.title}</p>
          </DialogTitle>
          {options.message && (
            <DialogDescription className="pt-2 text-left">
              {options.message}
            </DialogDescription>
          )}
        </DialogHeader>

        {options.showInput && (
          <div className="mb-4 grid w-full items-center gap-1.5">
            <p className="text-xs">{options.inputLabel}</p>
            <Textarea
              ref={refTextarea}
              className="min-h-[16px] resize-none"
              placeholder={options.inputPlaceholder}
              rows={options.inputRows}
            />
          </div>
        )}

        <DialogFooter className="flex justify-end gap-y-4 sm:gap-y-0">
          {!options.actionOnly && (
            <Button
              className="min-w-24 rounded-full"
              variant="ghost"
              onClick={handleClickCancel}
            >
              キャンセル
            </Button>
          )}
          <Button
            className={cn('min-w-24 rounded-full')}
            variant={iconTypes[options.icon].variant || 'default'}
            onClick={handleClickAction}
          >
            {options.actionLabel}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export { ConfirmDialog };

------------------------------------------------------------
pagination.tsx

import { Button } from '@/components/ui/button';
import { createPageNumbers } from '@/lib/pagination';
import { cn } from '@/lib/util';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { HTMLAttributes } from 'react';

interface Props extends HTMLAttributes<HTMLDivElement> {
  total: number;
  page: number;
  onChangePage: (page: number) => void;
}

export default function Pagination({
  total,
  page,
  onChangePage,
  className,
  ...props
}: Props) {
  const pageNumbers = createPageNumbers(page, total);

  return (
    <div className={cn('flex', className)} {...props}>
      <Button
        className="size-8 rounded-full"
        variant="ghost"
        size="icon"
        aria-label="前のページへ"
        disabled={page <= 1}
        onClick={() => onChangePage(page - 1)}
      >
        <ChevronLeft className="size-5" />
      </Button>

      <ul className="flex">
        {pageNumbers.map((pageNumber, index) => (
          <li key={`${pageNumber}-${index}`}>
            {pageNumber === 0 ? (
              <div className="size-8 text-center">...</div>
            ) : (
              <Button
                className="size-8 rounded-full"
                variant={page === pageNumber ? 'secondary' : 'ghost'}
                size="icon"
                aria-label="ページ番号"
                onClick={() => {
                  if (page !== pageNumber) {
                    onChangePage(pageNumber);
                  }
                }}
              >
                {pageNumber}
              </Button>
            )}
          </li>
        ))}
      </ul>

      <Button
        className="size-8 rounded-full"
        variant="ghost"
        size="icon"
        aria-label="次のページへ"
        disabled={page >= total}
        onClick={() => onChangePage(page + 1)}
      >
        <ChevronRight className="size-5" />
      </Button>
    </div>
  );
}

------------------------------------------------------------
constants.ts

import {
  BookCopyIcon,
  BookmarkIcon,
  HeartIcon,
  MessageSquareIcon,
  SettingsIcon,
} from 'lucide-react';

// ロゴ
export const LOGO_TITLE = 'My Books';

// メニュー一覧
export const MENU_LIST = [
  {
    href: '/discover?genreIds=1&condition=SINGLE',
    title: 'ジャンル',
    icon: BookCopyIcon,
  },
  { href: '/favorites', title: 'お気に入り', icon: HeartIcon },
  { href: '/bookmarks', title: 'ブックマーク', icon: BookmarkIcon },
  { href: '/my-reviews', title: 'マイレビュー', icon: MessageSquareIcon },
  { href: '/settings/profile', title: '設定', icon: SettingsIcon },
];

// API Endpoits
export const BOOKS_API_ENDPOINT = 'https://vsv-emerald.skygroup.local/api/v1';
// export const BOOKS_API_ENDPOINT = 'https://localhost/api/v1';

export const AVATAR_BASE_URL = 'https://vsv-emerald.skygroup.local/images/avatars';
// export const AVATAR_BASE_URL = 'https://localhost/images/avatars';
export const AVATAR_URLS = [...Array(41)].map(
  (_, index) => `${AVATAR_BASE_URL}/avatar${String(index).padStart(2, '0')}.png`
);

export const FETCH_BOOKS_MAX_RESULTS = 20;
export const FETCH_REVIEWS_MAX_RESULTS = 3;

export const FETCH_FAVORITES_MAX_RESULTS = 5;
export const FETCH_MY_REVIEWS_MAX_RESULTS = 5;
export const FETCH_BOOKMARKS_MAX_RESULTS = 5;

------------------------------------------------------------
book-read-content.ts

import { BookTableOfContents } from '@/types';

// 「現在のページ/総ページ数」を表す文字列を返す
export const getCurrentPageText = (
  bookTableOfContents: BookTableOfContents,
  chapterNumber: number,
  pageNumber: number
) => {
  // 章番号が見つからなかった場合でも chapterIndex は少なくとも1にする
  const chapterIndex = Math.max(
    1,
    bookTableOfContents.chapters.findIndex(
      (chapter) => chapter.chapterNumber === chapterNumber
    )
  );

  const totalPage = bookTableOfContents.chapters[chapterIndex]?.pageNumbers.length ?? 1;
  return `${pageNumber}/${totalPage}`;
};

// 現在のページが最初か最後かを判定する
export const getPagePosition = (
  bookTableOfContents: BookTableOfContents,
  chapterNumber: number,
  pageNumber: number
) => {
  const isFirstPage = chapterNumber === 1 && pageNumber === 1;
  const isLastPage =
    chapterNumber === bookTableOfContents.chapters.length &&
    pageNumber ===
      bookTableOfContents.chapters.find(
        (chapter) => chapter.chapterNumber === chapterNumber
      )?.pageNumbers.length;

  return { isFirstPage, isLastPage };
};

// 指定方向（次 or 前）のページのリンク先を返す
export const getPageLink = (
  bookTableOfContents: BookTableOfContents,
  chapterNumber: number,
  pageNumber: number,
  direction: 'next' | 'prev'
) => {
  const chapterIndex = bookTableOfContents.chapters.findIndex(
    (chapter) => chapter.chapterNumber === chapterNumber
  );

  if (chapterIndex === -1) {
    return `/read/${bookTableOfContents.bookId}/chapter/${chapterNumber}/page/${pageNumber}`;
  }

  const totalPages = bookTableOfContents.chapters[chapterIndex]?.pageNumbers.length ?? 1;
  const isMovingForward = direction === 'next';

  const isLastPage = pageNumber >= totalPages;
  const isFirstPage = pageNumber <= 1;
  const isLastChapter = chapterIndex >= bookTableOfContents.chapters.length - 1;
  const isFirstChapter = chapterIndex <= 0;

  let newChapterNumber = chapterNumber;
  let newPageNumber = pageNumber;

  if (isMovingForward) {
    if (isLastPage) {
      // 最終章の最後のページなら、それ以上進めない
      if (isLastChapter) {
        newPageNumber = totalPages; // 現在の最後のページのまま
      } else {
        // 次のチャプターの最初のページへ
        newChapterNumber = chapterNumber + 1;
        newPageNumber = 1;
      }
    } else {
      newPageNumber = pageNumber + 1;
    }
  } else {
    if (isFirstPage) {
      // 最初の章の最初のページなら、それ以上戻れない
      if (isFirstChapter) {
        newPageNumber = 1; // 現在の最初のページのまま
      } else {
        // 前のチャプターの最後のページへ
        newChapterNumber = chapterNumber - 1;
        newPageNumber = bookTableOfContents.chapters[chapterIndex - 1].pageNumbers.length;
      }
    } else {
      newPageNumber = pageNumber - 1;
    }
  }

  return `/read/${bookTableOfContents.bookId}/chapter/${newChapterNumber}/page/${newPageNumber}`;
};

------------------------------------------------------------
index.css

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  html {
    font-family: 'Inter', 'Noto Sans JP', system-ui, sans-serif;
  }

  /* スクロールバー */
  body ::-webkit-scrollbar-track {
    cursor: default;
    background-color: hsl(var(--muted));
  }
  body ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  body ::-webkit-scrollbar-thumb {
    cursor: default;
    border-radius: 8px;
    background-color: hsl(var(--foreground) / 0.2);
  }
  body ::-webkit-scrollbar-thumb:hover {
    background-color: hsl(var(--foreground) / 0.3);
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/*
カラーテーマは以下のページからコピペ
https://ui.jln.dev/
*/

@layer base {
  :root {
    --background: 112 100% 97%;
    --foreground: 60 2% 30%;
    --muted: 112 12% 90%;
    --muted-foreground: 112 12% 30%;
    --popover: 112 100% 94%;
    --popover-foreground: 60 2% 20%;
    --card: 112 100% 95%;
    --card-foreground: 60 2% 25%;
    --border: 112 90% 92%;
    --input: 112 90% 89%;
    --primary: 123 43% 39%;
    --primary-foreground: 0 0% 100%;
    --secondary: 123 30% 75%;
    --secondary-foreground: 123 30% 15%;
    --accent: 112 100% 82%;
    --accent-foreground: 112 100% 2%;
    --destructive: 2 96% 27%;
    --destructive-foreground: 2 96% 87%;

    --ring: 155 58% 29%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 200 19% 18%;
    --foreground: 0 0% 96%;
    --muted: 200 12% 22%;
    --muted-foreground: 200 12% 72%;
    --popover: 200 19% 15%;
    --popover-foreground: 0 0% 100%;
    --card: 200 19% 16%;
    --card-foreground: 0 0% 100%;
    --border: 200 9% 23%;
    --input: 200 9% 26%;
    --primary: 123 49% 59%;
    --primary-foreground: 0 0% 0%;
    --secondary: 123 30% 25%;
    --secondary-foreground: 123 30% 85%;
    --accent: 200 19% 33%;
    --accent-foreground: 200 19% 93%;
    --destructive: 4 91% 59%;
    --destructive-foreground: 0 0% 100%;
    --ring: 123 49% 59%;
  }
}

------------------------------------------------------------
index.html

<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="本の探索サイトへようこそ。多様なコレクションから、新しい知識を発見しましょう。厳選された書籍で、あなたの次の読書を見つけてください。知識の旅に一緒に出かけましょう。"
    />
    <title>My Books</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Noto+Sans+JP:wght@100..900&display=swap"
      rel="stylesheet"
    />
  </head>
  <body class="dark">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

------------------------------------------------------------
vite.config.ts

import react from '@vitejs/plugin-react-swc';
import path from 'path';
import { defineConfig } from 'vite';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],

  // エイリアス設定
  // https://zenn.dev/yuji6523/articles/react-absolute-path
  // shadcn/uiのviteの設定も参考
  // https://ui.shadcn.com/docs/installation/vite
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});

------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------

