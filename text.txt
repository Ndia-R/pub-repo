３９ファイル

------------------------------------------------------------
book-detail

import CountIconSkeleton from '@/components/count-icon/count-icon-skeleton';
import FavoriteCountIcon from '@/components/count-icon/favorite-count-icon';
import ReviewCountIcon from '@/components/count-icon/review-count-icon';
import GenreList from '@/components/genre-list/genre-list';
import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { useApiBook } from '@/hooks/api/use-api-book';
import { formatDateJP, formatIsbn, formatPrice } from '@/lib/util';
import { useSuspenseQuery } from '@tanstack/react-query';
import { Suspense } from 'react';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
};

export default function BookDetail({ bookId }: Props) {
  const { getBookDetailsById } = useApiBook();

  const { data: book } = useSuspenseQuery({
    queryKey: ['getBookDetailsById', bookId],
    queryFn: () => getBookDetailsById(bookId),
  });

  return (
    <div className="flex flex-col justify-center p-3 pt-10 sm:p-6 lg:flex-row">
      <div className="flex flex-col items-center justify-center lg:w-1/2">
        <Link to={`/read/${bookId}/table-of-contents`}>
          <img
            className="h-[360px] rounded object-cover sm:h-[480px]"
            src={book.imageUrl}
            alt={book.title}
          />
        </Link>
        <div className="mt-2 flex flex-col items-center justify-around sm:w-[440px] sm:flex-row">
          <div className="flex justify-center gap-x-2">
            <Suspense fallback={<CountIconSkeleton />}>
              <FavoriteCountIcon bookId={bookId} />
            </Suspense>
            <ReviewCountIcon reviewCount={book.reviewCount} />
          </div>
          <Rating rating={book.averageRating} readOnly />
        </div>
        <div className="my-4 flex items-center">
          <Button className="w-44 rounded-full bg-transparent" variant="outline" asChild>
            <Link to={`/read/${bookId}/table-of-contents`}>目次を見る</Link>
          </Button>
        </div>
      </div>

      <div className="p-4 lg:w-1/2">
        <p className="text-3xl font-bold sm:text-4xl">{book.title}</p>

        <div className="my-4 flex w-full flex-wrap items-center justify-end gap-x-3">
          <p>著者</p>
          {book.authors.map((author) => (
            <p className="text-lg font-bold sm:text-2xl" key={author}>
              {author}
            </p>
          ))}
        </div>
        <GenreList className="gap-2" genres={book.genres} variant="outline" />

        <div className="my-6 md:my-10">{book.description}</div>

        <div className="flex flex-col justify-between gap-y-4 lg:flex-row">
          <div className="flex flex-col gap-y-1 text-muted-foreground">
            <div className="flex">
              <p className="min-w-20">ISBN</p>
              <p>{formatIsbn(book.isbn)}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">出版社</p>
              <p>{book.publisher}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">発売日</p>
              <p className="tracking-wide">{formatDateJP(book.publishedDate)}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">ページ数</p>
              <p>{`${book.pageCount}ページ`}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">価格</p>
              <p>{formatPrice(book.price)}</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
book-list-by-genre-id

import BookList from '@/components/book-list/book-list';
import BookPagination from '@/components/book-list/book-pagination';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useSuspenseQuery } from '@tanstack/react-query';

type Props = {
  genreId: string;
  page: number;
};

export default function BookListByGenreId({ genreId, page }: Props) {
  const { getBookPageByGenreId } = useApiBook();

  const { data: paginatedBook } = useSuspenseQuery({
    queryKey: ['getBookPageByGenreId', genreId, page],
    queryFn: () => getBookPageByGenreId(genreId, page - 1),
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <BookPagination totalPages={paginatedBook.totalPages} />
      <BookList books={paginatedBook.books} />
      <BookPagination totalPages={paginatedBook.totalPages} />
    </div>
  );
}

------------------------------------------------------------
book-list-by-query

import BookList from '@/components/book-list/book-list';
import BookPagination from '@/components/book-list/book-pagination';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useSuspenseQuery } from '@tanstack/react-query';

type Props = {
  query: string;
  page: number;
};

export default function BookListByQuery({ query, page }: Props) {
  const { getBookPageByQuery } = useApiBook();

  const { data: paginatedBook } = useSuspenseQuery({
    queryKey: ['getBookPageByQuery', query, page],
    queryFn: () => getBookPageByQuery(query, page - 1),
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <BookPagination totalPages={paginatedBook.totalPages} />
      <BookList books={paginatedBook.books} />
      <BookPagination totalPages={paginatedBook.totalPages} />
    </div>
  );
}

------------------------------------------------------------
book-list-favorites

import BookList from '@/components/book-list/book-list';
import BookPagination from '@/components/book-list/book-pagination';
import { useApiFavorite } from '@/hooks/api/use-api-favorite';
import { useSuspenseQuery } from '@tanstack/react-query';

type Props = {
  page: number;
};

export default function BookListFavorites({ page }: Props) {
  const { getFavoritePage } = useApiFavorite();

  const { data: bookPage } = useSuspenseQuery({
    queryKey: ['getFavoritePage', page],
    queryFn: () => getFavoritePage(page - 1),
  });

  return (
    <div className="flex flex-col gap-y-4 pb-4">
      <BookPagination totalPages={bookPage.totalPages} />
      <BookList books={bookPage.favorites.map((favorite) => favorite.book)} />
      <BookPagination totalPages={bookPage.totalPages} />
    </div>
  );
}

------------------------------------------------------------
book-list-new-releases

import BookList from '@/components/book-list/book-list';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useSuspenseQuery } from '@tanstack/react-query';

export default function BookListNewReleases() {
  const { getNewBooks } = useApiBook();

  const { data: books } = useSuspenseQuery({
    queryKey: ['getNewBooks'],
    queryFn: () => getNewBooks(),
  });

  return (
    <div className="pb-4">
      <BookList books={books} />
    </div>
  );
}

------------------------------------------------------------
book-pagination

import Pagination from '@/components/pagination';
import { useEffect, useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

type Props = {
  totalPages: number;
};

export default function BookPagination({ totalPages }: Props) {
  const location = useLocation();
  const navigate = useNavigate();

  const [page, setPage] = useState(1);

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const page = Number(params.get('page') ?? '1');
    setPage(page);
  }, [location.search]);

  const handleChange = (page: number) => {
    setPage(page);
    const params = new URLSearchParams(location.search);
    params.set('page', page.toString());
    navigate(`${location.pathname}?${params.toString()}`, { replace: true });
  };

  return (
    <div className="flex justify-center">
      {totalPages > 1 && (
        <Pagination total={totalPages} page={page} onChangePage={handleChange} />
      )}
    </div>
  );
}

------------------------------------------------------------
book-read

import { useApiBook } from '@/hooks/api/use-api-book';
import { useSuspenseQueries } from '@tanstack/react-query';
import { BookmarkIcon } from 'lucide-react';

type Props = {
  bookId: string;
  chapterNumber: number;
  pageNumber: number;
};

export default function BookRead({ bookId, chapterNumber, pageNumber }: Props) {
  const { getBookDetailsById, getBookTableOfContents, getBookContentPage } = useApiBook();

  const [{ data: book }, { data: bookTableOfContents }, { data: bookContentPage }] =
    useSuspenseQueries({
      queries: [
        {
          queryKey: ['getBookDetailsById', bookId],
          queryFn: () => getBookDetailsById(bookId),
        },
        {
          queryKey: ['getBookTableOfContents', bookId],
          queryFn: () => getBookTableOfContents(bookId),
        },
        {
          queryKey: ['getBookContentPage', bookId, chapterNumber, pageNumber],
          queryFn: () => getBookContentPage(bookId, chapterNumber, pageNumber),
        },
      ],
    });

  const totalPage = bookTableOfContents.chapters.find(
    (chapter) => chapter.chapterNumber === chapterNumber
  )?.pageNumbers.length;
  const pageTitle = `（${pageNumber}/${totalPage}）`;

  return (
    <>
      <div className="fixed left-0 top-0 -z-10 flex h-screen w-full justify-center">
        <img
          className="w-full max-w-7xl object-cover opacity-5"
          src={book.imageUrl}
          alt="bg-image"
        />
      </div>
      <div className="flex flex-col gap-y-12 px-4 py-12 sm:px-20">
        <div className="flex items-center gap-x-2">
          <p className="text-xl font-bold sm:text-2xl">
            {bookContentPage.chapterTitle}
            <span className="text-sm text-muted-foreground sm:text-base">
              {pageTitle}
            </span>
            <BookmarkIcon className="inline size-4" />
          </p>
        </div>
        <p className="whitespace-pre-wrap">{bookContentPage.content}</p>
      </div>
    </>
  );
}

------------------------------------------------------------
book-table-of-contents

import { Button } from '@/components/ui/button';
import { useApiBook } from '@/hooks/api/use-api-book';
import { useSuspenseQueries } from '@tanstack/react-query';
import { Link } from 'react-router-dom';

type Props = {
  bookId: string;
};

export default function BookTableOfContents({ bookId }: Props) {
  const { getBookDetailsById, getBookTableOfContents } = useApiBook();

  const [{ data: book }, { data: bookTableOfContents }] = useSuspenseQueries({
    queries: [
      {
        queryKey: ['getBookDetailsById', bookId],
        queryFn: () => getBookDetailsById(bookId),
      },
      {
        queryKey: ['getBookTableOfContents', bookId],
        queryFn: () => getBookTableOfContents(bookId),
      },
    ],
  });

  console.log(bookTableOfContents);
  return (
    <>
      <div className="fixed left-0 top-0 -z-10 flex h-screen w-full justify-center">
        <img
          className="w-full max-w-7xl object-cover opacity-5"
          src={book.imageUrl}
          alt="bg-image"
        />
      </div>
      <div className="flex flex-col gap-y-12 px-4 py-12 sm:px-20">
        <div className="flex w-full flex-col items-center gap-y-4 sm:items-start">
          <p className="text-3xl font-bold sm:text-5xl">{book.title}</p>
          <Button className="w-44 rounded-full bg-transparent" variant="outline" asChild>
            <Link to={`/read/${bookId}/table-of-contents`}>最初から読む</Link>
          </Button>
        </div>
        <ul className="flex w-full flex-col items-center gap-y-8 text-base sm:items-start sm:text-xl">
          {bookTableOfContents.chapters.map((chapter, index) => (
            <li key={chapter.chapterNumber}>
              <p className="text-center text-xs text-muted-foreground/50 sm:text-left sm:text-sm">{`chapter ${index + 1}`}</p>
              <Link
                className="hover:text-primary"
                to={`/read/${bookId}/chapter/${chapter.chapterNumber}/page/1`}
              >
                {chapter.chapterTitle}
              </Link>
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

------------------------------------------------------------
favorite-count-icon

import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useApiFavorite } from '@/hooks/api/use-api-favorite';
import { useAuth } from '@/hooks/context/use-auth';
import { createFavorite, deleteFavorite } from '@/lib/action';
import { cn } from '@/lib/util';
import { FavoriteInfo, FavoriteRequest } from '@/types';
import { useMutation, useQueryClient, useSuspenseQuery } from '@tanstack/react-query';
import { HeartIcon } from 'lucide-react';

const BUTTON_SIZE = { sm: 'size-6', md: 'size-8' };
const ICON_SIZE = { sm: 'size-3', md: 'size-4' };
const TEXT_SIZE = { sm: 'text-xs', md: 'text-sm' };

type Props = {
  bookId: string;
  size?: 'sm' | 'md';
};

export default function FavoriteCountIcon({ bookId, size = 'md' }: Props) {
  const { user } = useAuth();
  const { getFavoriteInfo } = useApiFavorite();

  const queryClient = useQueryClient();

  const queryKey = ['getFavoriteInfo', bookId, user?.id];
  const { data: favoriteInfo } = useSuspenseQuery({
    queryKey,
    queryFn: () => getFavoriteInfo(bookId, user?.id),
  });

  const { mutate, variables, isPending } = useMutation({
    mutationFn: async (newFavorite: FavoriteInfo) => {
      if (newFavorite.isFavorite) {
        const requestBody: FavoriteRequest = { bookId };
        await createFavorite(requestBody);
      } else {
        await deleteFavorite(bookId);
      }
    },
    onMutate: async (newFavoriteInfo: FavoriteInfo) => {
      await queryClient.cancelQueries({ queryKey });
      const previousFavoriteInfo = queryClient.getQueryData(queryKey);
      queryClient.setQueryData(queryKey, newFavoriteInfo);
      return { previousFavoriteInfo };
    },
    onSettled: (_newFavoriteInfo, error, _variables, context) => {
      if (error) {
        queryClient.setQueryData(queryKey, context?.previousFavoriteInfo);
      }
      queryClient.invalidateQueries({ queryKey });
    },
  });

  const handleClick = () => {
    if (!user) return;

    const newFavoriteInfo: FavoriteInfo = {
      isFavorite: !favoriteInfo.isFavorite,
      favoriteCount: favoriteInfo.isFavorite
        ? favoriteInfo.favoriteCount - 1
        : favoriteInfo.favoriteCount + 1,
    };
    mutate(newFavoriteInfo);
  };

  const optimisticData = isPending ? variables : favoriteInfo;

  return (
    <div className="flex items-center">
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className={cn(
              'rounded-full text-muted-foreground',
              BUTTON_SIZE[size],
              optimisticData?.isFavorite && 'text-primary bg-transparent'
            )}
            variant="ghost"
            size="icon"
            onClick={handleClick}
          >
            <HeartIcon
              className={ICON_SIZE[size]}
              style={{
                fill: optimisticData?.isFavorite ? 'hsl(var(--primary))' : '',
              }}
            />
          </Button>
        </TooltipTrigger>
        {user ? (
          <TooltipContent>
            {optimisticData?.isFavorite ? 'お気に入りから削除' : 'お気に入りに追加'}
          </TooltipContent>
        ) : (
          <TooltipContent>
            ログインしてこの本を「お気に入り」に加えましょう
          </TooltipContent>
        )}
      </Tooltip>

      <p
        className={cn(
          'flex min-w-4 text-muted-foreground justify-center',
          TEXT_SIZE[size]
        )}
      >
        {optimisticData?.favoriteCount}
      </p>
    </div>
  );
}

------------------------------------------------------------
genre-list-selector

import { Button } from '@/components/ui/button';
import { useApiGenre } from '@/hooks/api/use-api-genre';
import { cn } from '@/lib/util';
import { useSuspenseQuery } from '@tanstack/react-query';
import { CheckIcon } from 'lucide-react';

type Props = {
  activeIds: number[];
  onClick: (genreId: number) => void;
};

export default function GenreListSelector({ activeIds, onClick }: Props) {
  const { getGenres } = useApiGenre();

  const { data: genres } = useSuspenseQuery({
    queryKey: ['getGenres'],
    queryFn: () => getGenres(),
  });

  return (
    <ul className="flex flex-wrap">
      {genres.map((genre) => {
        const isActive = activeIds.includes(genre.id);
        return (
          <li key={genre.id}>
            <Button
              className={cn(
                'rounded-full m-1 text-muted-foreground text-xs sm:text-sm',
                isActive && 'text-foreground'
              )}
              variant={isActive ? 'secondary' : 'ghost'}
              size="sm"
              onClick={() => onClick(genre.id)}
            >
              {isActive && <CheckIcon className="mr-1 size-4" strokeWidth={4} />}
              {genre.name}
            </Button>
          </li>
        );
      })}
    </ul>
  );
}

------------------------------------------------------------
genre-list-top-page

import GenreList from '@/components/genre-list/genre-list';
import { useApiGenre } from '@/hooks/api/use-api-genre';
import { useSuspenseQuery } from '@tanstack/react-query';

export default function GenreListTopPage() {
  const { getGenres } = useApiGenre();

  const { data: genres } = useSuspenseQuery({
    queryKey: ['getGenres'],
    queryFn: () => getGenres(),
  });
  return (
    <>
      <GenreList genres={genres} variant="ghost" />
    </>
  );
}

------------------------------------------------------------
login-button

import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { MENU_LIST } from '@/constants/constants';
import { useAuth } from '@/hooks/context/use-auth';
import { LogOutIcon } from 'lucide-react';
import { useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

export default function LoginButton() {
  const { user, logout } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();

  const [isOpen, setIsOpen] = useState(false);

  const handleClickLogin = () => {
    if (!user) {
      navigate('/login', { state: { from: location } });
    }
  };

  const handleClickLogout = async () => {
    await logout();
    setIsOpen(false);
    navigate('/');
  };

  const handleClickItem = (href: string) => {
    navigate(href);
    setIsOpen(false);
  };

  return (
    <>
      {user ? (
        <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
          <DropdownMenuTrigger className="ml-2 flex items-center justify-center" asChild>
            <Button className="rounded-full" variant="ghost" size="icon">
              <Avatar>
                <AvatarImage
                  className="bg-primary/50"
                  src={user.avatarUrl}
                  alt="avatar-image"
                />
                <AvatarFallback className="text-lg font-semibold">
                  {user.name.slice(0, 1)}
                </AvatarFallback>
              </Avatar>
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent className="w-48 p-2" side="bottom" align="end">
            <DropdownMenuLabel>
              <div className="flex items-center gap-x-2">
                <Avatar className="size-8">
                  <AvatarImage
                    className="bg-primary/50"
                    src={user.avatarUrl}
                    alt="avatar-image"
                  />
                  <AvatarFallback className="font-semibold">
                    {user.name.slice(0, 1)}
                  </AvatarFallback>
                </Avatar>
                <div className="flex-1 overflow-hidden">
                  <p className="truncate">{user.name}</p>
                  <p className="truncate text-xs font-normal text-muted-foreground">
                    {user.email}
                  </p>
                </div>
              </div>
            </DropdownMenuLabel>
            <DropdownMenuSeparator />
            {MENU_LIST.map((item) => (
              <DropdownMenuItem
                onClick={() => handleClickItem(item.href)}
                key={item.href}
              >
                <item.icon className="mr-1" />
                {item.title}
              </DropdownMenuItem>
            ))}
            <DropdownMenuSeparator />
            <DropdownMenuItem onClick={handleClickLogout}>
              <LogOutIcon className="mr-1" />
              ログアウト
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      ) : (
        <Button className="rounded-full" variant="ghost" onClick={handleClickLogin}>
          ログイン
        </Button>
      )}
    </>
  );
}

------------------------------------------------------------
review-item

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/review-list/review-update-dialog';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { useAuth } from '@/hooks/context/use-auth';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { deleteReview } from '@/lib/action';
import { formatDateJP, formatTime } from '@/lib/util';
import { Review } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { SquarePenIcon, Trash2Icon } from 'lucide-react';
import { useState } from 'react';

type Props = {
  review: Review;
  bookId: string;
  queryKey: unknown[];
};

export default function ReviewItem({ review, bookId, queryKey }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const { user } = useAuth();
  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const queryClient = useQueryClient();
  const { mutate } = useMutation({
    mutationFn: (id: number) => deleteReview(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
      queryClient.invalidateQueries({ queryKey: ['getBookDetailsById', bookId] });
    },
  });

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: '!',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除する',
    });
    if (isCancel) return;

    mutate(review.id, {
      onSuccess: () => {
        toast({ description: 'レビューを削除しました' });
      },
    });
  };

  return (
    <div className="p-4">
      <div className="flex flex-col items-center justify-between sm:flex-row">
        <div className="flex w-full items-center gap-x-4">
          <Avatar className="size-16">
            <AvatarImage
              className="bg-primary/50"
              src={review.avatarUrl}
              alt="avatar-image"
            />
            <AvatarFallback className="font-semibold">
              {review.name.slice(0, 1)}
            </AvatarFallback>
          </Avatar>
          <div>
            <p className="-mb-1 text-lg font-semibold">{review.name}</p>
            <div className="flex items-center">
              <p className="whitespace-nowrap text-sm leading-8 tracking-wide text-muted-foreground">
                {formatDateJP(review.updatedAt)} {formatTime(review.updatedAt)}
              </p>
              <div className="ml-2 flex w-16">
                {user?.id === review.userId && (
                  <>
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      onClick={() => user && setIsOpen(true)}
                    >
                      <SquarePenIcon className="size-4" />
                    </Button>
                    <ReviewUpdateDialog
                      bookId={bookId}
                      review={review}
                      queryKey={queryKey}
                      isOpen={isOpen}
                      setIsOpen={setIsOpen}
                    />
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      onClick={handleClickDelete}
                    >
                      <Trash2Icon className="size-4" />
                    </Button>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
        <Rating rating={review.rating} readOnly />
      </div>
      <p className="mt-2 text-muted-foreground sm:pl-20">{review.comment}</p>
    </div>
  );
}

------------------------------------------------------------
review-list

import Pagination from '@/components/pagination';
import ReviewCreateDialog from '@/components/review-list/review-create-dialog';
import ReviewItem from '@/components/review-list/review-item';
import { Button } from '@/components/ui/button';
import { Separator } from '@/components/ui/separator';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useApiRevew } from '@/hooks/api/use-api-review';
import { useAuth } from '@/hooks/context/use-auth';
import { useSuspenseQuery } from '@tanstack/react-query';
import { useState } from 'react';

type Props = {
  bookId: string;
};

export default function ReviewList({ bookId }: Props) {
  const [page, setPage] = useState(1);
  const [isOpen, setIsOpen] = useState(false);

  const { user } = useAuth();
  const { getReviewPage, checkMyReviewExists } = useApiRevew();

  const queryKey = ['ReviewList', 'checkMyReviewExists', bookId, page];
  const {
    data: [paginatedReview, reviewExists],
  } = useSuspenseQuery({
    queryKey,
    queryFn: () =>
      Promise.all([
        getReviewPage(bookId, page - 1),
        user ? checkMyReviewExists(bookId) : false,
      ]),
  });

  return (
    <div className="mx-auto w-full lg:w-3/4">
      <div className="flex flex-col-reverse items-center justify-end gap-y-4 sm:flex-row sm:gap-x-4 sm:px-6">
        <p>レビュー {paginatedReview.totalItems} 件</p>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              className="w-44 rounded-full bg-transparent"
              variant="outline"
              disabled={reviewExists}
              onClick={() => user && setIsOpen(true)}
            >
              {reviewExists ? 'レビュー済み' : 'レビューする'}
            </Button>
          </TooltipTrigger>
          {!user && (
            <TooltipContent>
              ログインしてこの本の「レビュー」を書きましょう
            </TooltipContent>
          )}
        </Tooltip>
        <ReviewCreateDialog
          bookId={bookId}
          queryKey={queryKey}
          isOpen={isOpen}
          setIsOpen={setIsOpen}
        />
      </div>

      <ul className="flex flex-col p-3 sm:p-6">
        {paginatedReview.reviews.map((review) => (
          <li key={review.userId}>
            <Separator className="bg-foreground/10" />
            <ReviewItem review={review} bookId={bookId} queryKey={queryKey} />
          </li>
        ))}
      </ul>

      <div className="mb-4 flex justify-center">
        {paginatedReview.totalPages > 1 && (
          <Pagination
            total={paginatedReview.totalPages}
            page={page}
            onChangePage={setPage}
          />
        )}
      </div>
    </div>
  );
}


------------------------------------------------------------
profile-counts

import CountUpNumber from '@/components/count-up-number';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useSuspenseQuery } from '@tanstack/react-query';

export default function ProfileCounts() {
  const { getProfileCounts } = useApiUser();

  const { data: profileCounts } = useSuspenseQuery({
    queryKey: ['getProfileCounts'],
    queryFn: () => getProfileCounts(),
  });

  return (
    <div className="flex justify-between pt-8">
      <div className="delay-0 duration-500 animate-in fade-in-0 slide-in-from-bottom-10 fill-mode-both">
        <div className="w-24 text-center">
          <p className="text-xl font-bold">
            <CountUpNumber end={profileCounts.favoriteCount} delay={300} />
          </p>
          <p className="text-sm">お気に入り</p>
        </div>
      </div>
      <div className="delay-100 duration-500 animate-in fade-in-0 slide-in-from-bottom-10 fill-mode-both">
        <div className="w-24 text-center">
          <p className="text-xl font-bold">
            <CountUpNumber end={profileCounts.bookmarkCount} delay={400} />
          </p>
          <p className="text-sm">ブックマーク</p>
        </div>
      </div>
      <div className="delay-200 duration-500 animate-in fade-in-0 slide-in-from-bottom-10 fill-mode-both">
        <div className="w-24 text-center">
          <p className="text-xl font-bold">
            <CountUpNumber end={profileCounts.reviewCount} delay={500} />
          </p>
          <p className="text-sm">レビュー</p>
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
pagination

import { Button } from '@/components/ui/button';
import { cn } from '@/lib/util';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { HTMLAttributes } from 'react';

const createPageNumbers = (page: number, total: number) => {
  const pages = [];
  const maxPages = 7;

  if (page <= 4) {
    for (let i = 1; i <= Math.min(5, total); i++) {
      pages.push(i);
    }
    if (total > 5) {
      pages.push(0, total);
    }
  } else if (page >= total - 3) {
    pages.push(1, 0);
    for (let i = total - 4; i <= total; i++) {
      pages.push(i);
    }
  } else {
    pages.push(1, 0);
    for (let i = page - 1; i <= page + 1; i++) {
      pages.push(i);
    }
    pages.push(0, total);
  }

  return pages.slice(0, maxPages);
};

interface Props extends HTMLAttributes<HTMLDivElement> {
  total: number;
  page: number;
  onChangePage: (page: number) => void;
}

export default function Pagination({
  total,
  page,
  onChangePage,
  className,
  ...props
}: Props) {
  const pageNumbers = createPageNumbers(page, total);

  return (
    <div className={cn('flex', className)} {...props}>
      <Button
        className="size-8 rounded-full"
        variant="ghost"
        size="icon"
        disabled={page <= 1}
        onClick={() => onChangePage(page - 1)}
      >
        <ChevronLeft className="size-5" />
      </Button>

      <ul className="flex">
        {pageNumbers.map((pageNumber, index) => (
          <li key={`${pageNumber}-${index}`}>
            {pageNumber === 0 ? (
              <div className="size-8 text-center">...</div>
            ) : (
              <Button
                className="size-8 rounded-full"
                variant={page === pageNumber ? 'secondary' : 'ghost'}
                size="icon"
                onClick={() => {
                  if (page !== pageNumber) {
                    onChangePage(pageNumber);
                  }
                }}
              >
                {pageNumber}
              </Button>
            )}
          </li>
        ))}
      </ul>

      <Button
        className="size-8 rounded-full"
        variant="ghost"
        size="icon"
        disabled={page >= total}
        onClick={() => onChangePage(page + 1)}
      >
        <ChevronRight className="size-5" />
      </Button>
    </div>
  );
}

------------------------------------------------------------
hooks/api

use-api-book

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import {
  Book,
  BookContentPage,
  BookDetails,
  BookPage,
  BookTableOfContents,
} from '@/types';

export const useApiBook = () => {
  const { fetcher, fetcherWithAuth } = useApi();

  const getBookDetailsById = async (bookId: string) => {
    try {
      const url = `/books/${bookId}`;
      const book = await fetcher<BookDetails>(url);
      return book;
    } catch {
      throw new Error('書籍情報の読み込みが失敗しました。');
    }
  };

  const getBookPageByQuery = async (q: string, page: number = 0) => {
    try {
      const url = `/books/search?q=${q}&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
      const bookPage = await fetcher<BookPage>(url);
      return bookPage;
    } catch {
      throw new Error('書籍検索が失敗しました。');
    }
  };

  const getBookPageByGenreId = async (genreIdsQuery: string, page: number = 0) => {
    try {
      // 「|」はそのまま渡すとエラーになるので、URLエンコードする
      const encodedParams = genreIdsQuery.replace(/\|/g, encodeURIComponent('|'));

      const url = `/books/discover?genreId=${encodedParams}&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
      const bookPage = await fetcher<BookPage>(url);
      return bookPage;
    } catch {
      throw new Error('ジャンル検索が失敗しました。');
    }
  };

  const getNewBooks = async () => {
    try {
      const url = `/books/new-books`;
      const books = await fetcher<Book[]>(url);
      return books;
    } catch {
      throw new Error('ニューリリース一覧の読み込みが失敗しました。');
    }
  };

  const getBookTableOfContents = async (bookId: string) => {
    try {
      const url = `/books/${bookId}/table-of-contents`;
      const bookTableOfContents = await fetcher<BookTableOfContents>(url);
      return bookTableOfContents;
    } catch {
      throw new Error('書籍の目次の読み込みが失敗しました。');
    }
  };

  const getBookContentPage = async (
    bookId: string,
    chapterNumber: number,
    pageNumber: number
  ) => {
    try {
      const url = `/books/${bookId}/chapters/${chapterNumber}/pages/${pageNumber}`;
      const bookContentPage = await fetcherWithAuth<BookContentPage>(url);
      return bookContentPage;
    } catch (err) {
      throw new Error('書籍のページ情報の読み込みが失敗しました。' + err);
    }
  };

  return {
    getBookDetailsById,
    getBookPageByQuery,
    getBookPageByGenreId,
    getNewBooks,
    getBookTableOfContents,
    getBookContentPage,
  };
};

------------------------------------------------------------
use-api-bookmark

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { Bookmark, BookmarkPage, BookmarkRequest } from '@/types';

export const useApiBookmark = () => {
  const { fetcherWithAuth, mutationWithAuth } = useApi();

  const getBookmarkByBookId = async (bookId: string) => {
    try {
      const url = `/bookmarks/${bookId}`;
      const bookmarks = await fetcherWithAuth<Bookmark[]>(url);
      return bookmarks;
    } catch {
      throw new Error('ブックマークの読み込みが失敗しました。');
    }
  };

  const getBookmarkPage = async (page: number = 0) => {
    try {
      const url = `/bookmarks?&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
      const bookmarkPage = await fetcherWithAuth<BookmarkPage>(url);
      return bookmarkPage;
    } catch {
      throw new Error('ブックマーク一覧の読み込みが失敗しました。');
    }
  };

  const createBookmark = async (reqestBody: BookmarkRequest) => {
    try {
      const url = `/bookmarks`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(reqestBody),
      };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  const updateBookmark = async (id: number, reqestBody: BookmarkRequest) => {
    try {
      const url = `/bookmarks/${id}`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(reqestBody),
      };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  const deleteBookmark = async (id: number) => {
    try {
      const url = `/bookmarks/${id}`;
      const options: RequestInit = { method: 'DELETE' };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  return {
    getBookmarkByBookId,
    getBookmarkPage,
    createBookmark,
    updateBookmark,
    deleteBookmark,
  };
};

------------------------------------------------------------
use-api-favorite

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { sleep } from '@/lib/util';
import { Favorite, FavoriteInfo, FavoritePage, FavoriteRequest } from '@/types';

export const useApiFavorite = () => {
  const { fetcher, fetcherWithAuth, mutationWithAuth } = useApi();

  const getFavoriteByBookId = async (bookId: string) => {
    try {
      const url = `/favorites/${bookId}`;
      const favorite = await fetcherWithAuth<Favorite>(url);
      return favorite;
    } catch {
      throw new Error('お気に入りの読み込みが失敗しました。');
    }
  };

  const getFavoritePage = async (page: number = 0) => {
    try {
      const url = `/favorites?&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
      const favoritePage = await fetcherWithAuth<FavoritePage>(url);
      return favoritePage;
    } catch {
      throw new Error('お気に入り一覧の読み込みが失敗しました。');
    }
  };

  const getFavoriteInfo = async (bookId: string, userId: number | undefined) => {
    await sleep(2000);
    try {
      const query = userId ? `?userId=${userId}` : '';
      const url = `/books/${bookId}/favorites/info${query}`;
      const favoriteInfo = await fetcher<FavoriteInfo>(url);
      return favoriteInfo;
    } catch {
      throw new Error('お気に入り情報の読み込みが失敗しました。');
    }
  };

  const createFavorite = async (reqestBody: FavoriteRequest) => {
    try {
      const url = `/favorites`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(reqestBody),
      };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  const deleteFavorite = async (bookId: string) => {
    try {
      const url = `/favorites/${bookId}`;
      const options: RequestInit = { method: 'DELETE' };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  return {
    getFavoriteByBookId,
    getFavoritePage,
    getFavoriteInfo,
    createFavorite,
    deleteFavorite,
  };
};

------------------------------------------------------------
use-api-genre

import { useApi } from '@/hooks/api/use-api';
import { sleep } from '@/lib/util';
import { Genre } from '@/types';

export const useApiGenre = () => {
  const { fetcher } = useApi();

  const getGenres = async () => {
    await sleep(2000);
    try {
      const url = `/genres`;
      const genres = await fetcher<Genre[]>(url);
      return genres;
    } catch {
      throw new Error('ジャンル一覧の読み込みが失敗しました。');
    }
  };

  return { getGenres };
};

------------------------------------------------------------
use-api-review

import { FETCH_REVIEWS_MAX_RESULTS } from '@/constants/constants';
import { useApi } from '@/hooks/api/use-api';
import { sleep } from '@/lib/util';
import { Review, ReviewPage, ReviewRequest, ReviewSummary } from '@/types';

export const useApiRevew = () => {
  const { fetcher, fetcherWithAuth, mutationWithAuth } = useApi();

  const getReviewPage = async (bookId: string, page: number = 0) => {
    await sleep(2000);

    try {
      const url = `/books/${bookId}/reviews?&page=${page}&maxResults=${FETCH_REVIEWS_MAX_RESULTS}`;
      const reviewPage = await fetcher<ReviewPage>(url);
      return reviewPage;
    } catch {
      throw new Error('レビュー一覧の読み込みが失敗しました。');
    }
  };

  const getReviewSummary = async (bookId: string) => {
    await sleep(2000);

    try {
      const url = `/books/${bookId}/reviews/summary`;
      const reviewSummary = await fetcher<ReviewSummary>(url);
      return reviewSummary;
    } catch {
      throw new Error('レビュー情報の読み込みが失敗しました。');
    }
  };

  const checkMyReviewExists = async (bookId: string) => {
    try {
      const url = `/reviews/${bookId}`;
      await fetcherWithAuth<Review>(url);
      return true;
    } catch {
      return false;
    }
  };

  const createReview = async (reqestBody: ReviewRequest) => {
    try {
      const url = `/reviews`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(reqestBody),
      };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  const updateReview = async (id: number, reqestBody: ReviewRequest) => {
    try {
      const url = `/reviews/${id}`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(reqestBody),
      };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  const deleteReview = async (id: number) => {
    try {
      const url = `/reviews/${id}`;
      const options: RequestInit = {
        method: 'DELETE',
      };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  return {
    getReviewPage,
    getReviewSummary,
    checkMyReviewExists,
    createReview,
    updateReview,
    deleteReview,
  };
};

------------------------------------------------------------
use-api-token

import { useApi } from '@/hooks/api/use-api';

export const useApiToken = () => {
  const { mutationWithAuth } = useApi();

  const validateToken = async () => {
    try {
      const url = `/validate-token`;
      const options: RequestInit = {
        method: 'POST',
      };
      await mutationWithAuth(url, options);
      return true;
    } catch {
      return false;
    }
  };

  return { validateToken };
};

------------------------------------------------------------
use-api-user

import { useApi } from '@/hooks/api/use-api';
import {
  ChangeEmail,
  ChangePassword,
  CheckUsernameExists,
  ProfileCounts,
  UpdateCurrentUser,
  User,
} from '@/types';

export const useApiUser = () => {
  const { fetcher, fetcherWithAuth, mutationWithAuth } = useApi();

  const getCurrentUser = async () => {
    try {
      const url = `/me`;
      const user = await fetcherWithAuth<User>(url);
      return user;
    } catch {
      return null;
    }
  };

  const getProfileCounts = async () => {
    try {
      const url = `/me/profile-counts`;
      const profieleCounts = await fetcherWithAuth<ProfileCounts>(url);
      return profieleCounts;
    } catch (err) {
      throw new Error('ユーザーのプロフィール情報の読み込みが失敗しました。' + err);
    }
  };

  const checkUsernameExists = async (name: string) => {
    try {
      const url = `/users/exists?name=${name}`;
      const data = await fetcher<CheckUsernameExists>(url);
      if (!data) return false;
      return data.exists;
    } catch {
      return false; // エラーの場合「存在しない」とするのはどうかと思うけどいったんfalse
    }
  };

  const updateCurrentUser = async (requestBody: UpdateCurrentUser) => {
    try {
      const url = `/me`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  const changePassword = async (requestBody: ChangePassword) => {
    try {
      const url = `/me/password`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  const changeEmail = async (requestBody: ChangeEmail) => {
    try {
      const url = `/me/email`;
      const options: RequestInit = {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      };
      await mutationWithAuth(url, options);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  return {
    getCurrentUser,
    getProfileCounts,
    checkUsernameExists,
    updateCurrentUser,
    changePassword,
    changeEmail,
  };
};

------------------------------------------------------------
use-api

import { BOOKS_API_ENDPOINT } from '@/constants/constants';
import { useAuth } from '@/hooks/context/use-auth';

export const useApi = () => {
  const { accessToken, refreshAccessToken } = useAuth();

  const fetcher = async <T>(url: string, options: RequestInit = {}) => {
    const response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, options);
    if (!response.ok) {
      throw new Error(`失敗しました。URL: ${url} ステータス: ${response.status}`);
    }

    return response.json() as Promise<T>;
  };

  const fetcherWithAuth = async <T>(url: string, options: RequestInit = {}) => {
    let response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${accessToken}`,
      },
    });

    if (response.status === 401) {
      await refreshAccessToken();
      response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
        ...options,
        headers: {
          ...options.headers,
          Authorization: `Bearer ${accessToken}`,
        },
      });
    }
    if (!response.ok) {
      throw new Error(`失敗しました。URL: ${url} ステータス: ${response.status}`);
    }

    return response.json() as Promise<T>;
  };

  const mutation = async (url: string, options: RequestInit = {}) => {
    const response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, options);
    if (!response.ok) {
      throw new Error(`失敗しました。URL: ${url} ステータス: ${response.status}`);
    }
  };

  const mutationWithAuth = async (url: string, options: RequestInit = {}) => {
    let response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${accessToken}`,
      },
    });

    if (response.status === 401) {
      await refreshAccessToken();
      response = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
        ...options,
        headers: {
          ...options.headers,
          Authorization: `Bearer ${accessToken}`,
        },
      });
    }
    if (!response.ok) {
      throw new Error(`失敗しました。URL: ${url} ステータス: ${response.status}`);
    }
  };

  return { fetcher, fetcherWithAuth, mutation, mutationWithAuth };
};

------------------------------------------------------------
hooks/context

use-auth

import { AuthContext } from '@/stores/auth-provider';
import { useContext } from 'react';

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within an AuthProvider');
  return context;
};

------------------------------------------------------------
lib/data/auth

auth

import { BOOKS_API_ENDPOINT } from '@/constants/constants';
import {
  AccessToken,
  CustomError,
  LoginRequest,
  LoginResponse,
  SignupRequest,
} from '@/types';

const ACCESS_TOKEN_KEY = 'accessToken';
const getAccessToken = () => localStorage.getItem(ACCESS_TOKEN_KEY);
const setAccessToken = (token: string) => localStorage.setItem(ACCESS_TOKEN_KEY, token);
const clearAccessToken = () => localStorage.removeItem(ACCESS_TOKEN_KEY);

export const login = async ({ email, password }: LoginRequest) => {
  const url = '/login';
  const options: RequestInit = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
    credentials: 'include',
  };

  const res = await fetch(`${BOOKS_API_ENDPOINT}${url}`, options);
  if (!res.ok) {
    const data = await res.json();
    console.error(`status:${data.status} message:${data.messages.join()}`);
    return false;
  }

  const loginResponse = (await res.json()) as LoginResponse;
  setAccessToken(loginResponse.accessToken);
  return true;
};

export const signup = async ({ name, email, password }: SignupRequest) => {
  const url = '/signup';
  const options: RequestInit = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, email, password }),
  };

  const res = await fetch(`${BOOKS_API_ENDPOINT}${url}`, options);
  if (!res.ok) {
    const data = await res.json();
    console.error(`status:${data.status} message:${data.messages.join()}`);
    return false;
  }

  await login({ email, password });
  return true;
};

export const logout = async () => {
  const url = '/logout';
  const options: RequestInit = {
    method: 'POST',
    credentials: 'include',
  };

  const res = await fetch(`${BOOKS_API_ENDPOINT}${url}`, options);
  if (!res.ok) {
    return false;
  }

  clearAccessToken();
  return true;
};

export const fetchJsonWithAuth = async <T>(
  url: string,
  options: RequestInit = {}
): Promise<T> => {
  const accessToken = getAccessToken();
  let res = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
    ...options,
    headers: {
      ...options.headers,
      Authorization: `Bearer ${accessToken}`,
    },
  });

  if (res.status === 401) {
    const newAccessToken = await refreshAccessToken();
    if (!newAccessToken) {
      clearAccessToken();
      const error: CustomError = new Error(
        `リフレッシュトークンの有効期限が切れました。URL: ${url}`
      );
      error.code = 'REFRESH_TOKEN_EXPIRED';
      throw error;
    }

    setAccessToken(newAccessToken);
    res = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${newAccessToken}`,
      },
    });
  }

  if (!res.ok) {
    throw new Error(`失敗しました。URL: ${url} ステータス: ${res.status}`);
  }
  return res.json();
};

export const fetchActionWithAuth = async (url: string, options?: RequestInit) => {
  const token = getAccessToken();
  let res = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
    ...options,
    headers: {
      ...options?.headers,
      Authorization: `Bearer ${token}`,
    },
  });

  if (res.status === 401) {
    const newToken = await refreshAccessToken();
    if (!newToken) {
      clearAccessToken();
      const error: CustomError = new Error(
        `リフレッシュトークンの有効期限が切れました。URL: ${url}`
      );
      error.code = 'REFRESH_TOKEN_EXPIRED';
      throw error;
    }

    setAccessToken(newToken);
    res = await fetch(`${BOOKS_API_ENDPOINT}${url}`, {
      ...options,
      headers: {
        ...options?.headers,
        Authorization: `Bearer ${newToken}`,
      },
    });
  }

  if (!res.ok) {
    throw new Error(`失敗しました。URL: ${url} ステータス: ${res.status}`);
  }
  return null;
};

export const refreshAccessToken = async () => {
  try {
    const options: RequestInit = {
      method: 'POST',
      credentials: 'include',
    };
    const res = await fetch(`${BOOKS_API_ENDPOINT}/refresh-token`, options);
    const AccessToken = (await res.json()) as AccessToken;
    return AccessToken.accessToken;
  } catch (e) {
    console.error(e);
    return null;
  }
};

export const validateToken = async () => {
  try {
    const url = `/validate-token`;
    const options = { method: 'POST' };
    await fetchActionWithAuth(url, options);
    return true;
  } catch (e) {
    // リフレッシュトークンが無効な場合はnull返却
    if ((e as CustomError).code) return null;
    return false;
  }
};


------------------------------------------------------------
login/page

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useAuth } from '@/hooks/context/use-auth';
import { useToast } from '@/hooks/use-toast';
import { Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';

export default function Page() {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const emailRef = useRef<HTMLInputElement | null>(null);

  const location = useLocation();
  const navigate = useNavigate();
  const { login } = useAuth();
  const { toast } = useToast();

  useEffect(() => {
    emailRef.current?.focus();
  }, []);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;

    setIsSubmitting(true);
    const isSuccess = await login({ email, password });
    if (!isSuccess) {
      setIsSubmitting(false);
      toast({
        title: 'ログインできませんでした',
        description: 'メールアドレスまたはパスワードが違います',
        variant: 'destructive',
        duration: 5000,
      });
      return;
    }

    setIsSubmitting(false);

    const pathname = location.state?.from?.pathname || '/';
    const query = location.state?.from?.search || '';
    navigate(pathname + query, { replace: true });
  };

  return (
    <div className="my-3 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">ログイン</p>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="email">
                メールアドレス
              </Label>
              <Input
                ref={emailRef}
                className="my-2 rounded-full"
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
              />
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                パスワード
              </Label>
              <PasswordInput
                className="my-2 rounded-full"
                id="password"
                name="password"
              />
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={isSubmitting}
            >
              {isSubmitting ? <Loader2Icon className="animate-spin" /> : 'ログイン'}
            </Button>
          </form>

          <div className="mt-6 flex justify-center gap-x-1 text-xs">
            <p className="text-muted-foreground">アカウントをお持ちでない方はこちら</p>
            <Link to={'/signup'}>
              <p className="text-primary hover:underline">新規登録</p>
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
change-email

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/context/use-auth';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/util';
import { Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function Page() {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const [emailErrorMessage, setEmailErrorMessage] = useState('');
  const [passwordErrorMessage, setPasswordErrorMessage] = useState('');

  const emailRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { user, logout } = useAuth();
  const { changeEmail } = useApiUser();
  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  useEffect(() => {
    emailRef.current?.focus();
  }, []);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const email = form.get('email') as string;
    const password = form.get('password') as string;

    if (!(email && password)) {
      if (email === '') setEmailErrorMessage('メールアドレスは必須です。');
      if (password === '') setPasswordErrorMessage('パスワードは必須です。');
      return;
    }

    const { isCancel } = await confirmDialog({
      icon: '?',
      title: '本当に変更しますか？',
      message: 'メールアドレス変更後、一度ログアウトします。',
    });
    if (isCancel) return;

    setIsSubmitting(true);
    const isSuccess = await changeEmail({ email, password });
    if (!isSuccess) {
      setIsSubmitting(false);
      toast({
        title: 'メールアドレスを変更できませんでした',
        description: '入力内容を確認してください',
        variant: 'destructive',
        duration: 5000,
      });
      return;
    }

    toast({ title: 'メールアドレスを変更し、ログアウトしました', duration: 5000 });

    await logout();
    setIsSubmitting(false);

    navigate('/login');
  };

  const handleCheckEmail = () => {
    setEmailErrorMessage('');

    if (!emailRef.current?.value) return;

    const emailRegex = /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(emailRef.current.value)) {
      setEmailErrorMessage('無効なメールアドレスです。');
    }
  };

  return (
    <div className="my-3 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">メールアドレス変更</p>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="name">
                現在のメールアドレス
              </Label>
              <p className="my-2 rounded-full border border-transparent px-3 py-2 text-sm">
                {user?.email}
              </p>
            </div>

            <div>
              <Label className="text-xs" htmlFor="name">
                新しいメールアドレス
              </Label>
              <Input
                ref={emailRef}
                className={cn(
                  'my-2 rounded-full',
                  emailErrorMessage && 'border-destructive'
                )}
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
                onBlur={handleCheckEmail}
              />
              {emailErrorMessage && (
                <p className="text-xs text-destructive">{emailErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                現在のパスワード
              </Label>
              <PasswordInput
                className={cn(
                  'my-2 rounded-full',
                  passwordErrorMessage && 'border-destructive'
                )}
                id="password"
                name="password"
              />
              {passwordErrorMessage && (
                <p className="text-xs text-destructive">{passwordErrorMessage}</p>
              )}
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={isSubmitting}
            >
              {isSubmitting ? <Loader2Icon className="animate-spin" /> : '変更'}
            </Button>
            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/settings/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}


------------------------------------------------------------
change-password

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useToast } from '@/hooks/use-toast';
import { Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function Page() {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const currentPasswordRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { changePassword } = useApiUser();
  const { toast } = useToast();

  useEffect(() => {
    currentPasswordRef.current?.focus();
  }, []);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const currentPassword = form.get('current-password') as string;
    const newPassword = form.get('new-password') as string;
    const confirmNewPassword = form.get('confirm-new-password') as string;

    setIsSubmitting(true);
    const isSuccess = await changePassword({
      currentPassword,
      newPassword,
      confirmNewPassword,
    });
    if (!isSuccess) {
      setIsSubmitting(false);
      toast({
        title: 'パスワードを変更できませんでした',
        description: '入力内容を確認してください',
        variant: 'destructive',
        duration: 5000,
      });
      return;
    }

    toast({ title: 'パスワードを変更しました' });
    setIsSubmitting(false);

    navigate('/settings/profile');
  };

  return (
    <div className="my-3 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">パスワード変更</p>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="current-password">
                現在のパスワード
              </Label>
              <PasswordInput
                ref={currentPasswordRef}
                className="my-2 rounded-full"
                id="current-password"
                name="current-password"
              />
            </div>

            <div>
              <Label className="text-xs" htmlFor="new-password">
                新しいパスワード
              </Label>
              <PasswordInput
                className="my-2 rounded-full"
                id="new-password"
                name="new-password"
              />
            </div>

            <div>
              <Label className="text-xs" htmlFor="confirm-new-password">
                新しいパスワード（確認用）
              </Label>
              <PasswordInput
                className="my-2 rounded-full"
                id="confirm-new-password"
                name="confirm-new-password"
              />
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={isSubmitting}
            >
              {isSubmitting ? <Loader2Icon className="animate-spin" /> : '変更'}
            </Button>
            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/settings/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
change-user-info

import Logo from '@/components/layout/logo';
import AvatarCarousel from '@/components/settings/avatar-carousel';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { AVATER_IMAGE_MAX_COIUNT, AVATER_IMAGE_URL } from '@/constants/constants';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/context/use-auth';
import { useToast } from '@/hooks/use-toast';
import { CircleHelpIcon, Loader2Icon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

const AVATARS = Array.from({ length: AVATER_IMAGE_MAX_COIUNT }, (_, index) => ({
  index,
  avatarUrl: `${AVATER_IMAGE_URL}/avatar${String(index).padStart(2, '0')}.png`,
}));

export default function Page() {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const [nameErrorMessage, setNameErrorMessage] = useState('');

  const [defaultAvatar, setDefaultAvatar] = useState<number | undefined>(undefined);
  const nameRef = useRef<HTMLInputElement | null>(null);
  const avatarUrlRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { user, setUser } = useAuth();
  const { getCurrentUser, checkUsernameExists, updateCurrentUser } = useApiUser();
  const { toast } = useToast();

  useEffect(() => {
    const initUserInfo = async () => {
      if (nameRef.current && avatarUrlRef.current && user) {
        nameRef.current.focus();
        nameRef.current.value = user.name || '';
        avatarUrlRef.current.value = user.avatarUrl;

        const index =
          AVATARS.find((avatar) => avatar.avatarUrl === user.avatarUrl)?.index || 0;

        setDefaultAvatar(index);
      }
    };
    initUserInfo();
  }, [user]);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const name = form.get('name') as string;
    const avatarUrl = form.get('avatar-url') as string;

    if (name === '') {
      setNameErrorMessage('ユーザー名は必須です。');
      return;
    }

    if (user?.name !== name && (await checkUsernameExists(name))) {
      setNameErrorMessage('そのユーザー名はすでに使われています。');
      return;
    }

    setIsSubmitting(true);
    const isSuccess = await updateCurrentUser({
      name,
      avatarUrl,
    });
    if (!isSuccess) {
      setIsSubmitting(false);
      toast({
        title: 'ユーザー情報を変更できませんでした',
        description: '入力内容を確認してください',
        variant: 'destructive',
        duration: 5000,
      });
      return;
    }

    toast({ title: 'ユーザー情報を変更しました' });

    setUser(await getCurrentUser());
    setIsSubmitting(false);

    navigate('/settings/profile');
  };

  const handleSelectedAvatar = (selectedIndex: number) => {
    if (avatarUrlRef.current) {
      avatarUrlRef.current.value = AVATARS[selectedIndex].avatarUrl;
    }
  };

  return (
    <div className="my-3 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">ユーザー情報の編集</p>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="name">
                ユーザー名
              </Label>
              <Input
                ref={nameRef}
                className="my-2 rounded-full"
                id="name"
                name="name"
                autoComplete="off"
                spellCheck="false"
              />
              <p className="h-4 text-xs text-destructive">{nameErrorMessage}</p>
            </div>

            <div className="mb-4">
              <div className="flex items-center gap-x-1">
                <Label className="text-xs" htmlFor="name">
                  アバター画像
                </Label>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <CircleHelpIcon className="size-4" />
                  </TooltipTrigger>
                  <TooltipContent>チェックマークは現在のアバターです</TooltipContent>
                </Tooltip>
              </div>
              <div className="flex justify-center">
                <AvatarCarousel
                  items={AVATARS}
                  itemWidth={80}
                  frameWidth={220}
                  defaultSelected={defaultAvatar}
                  onSelected={handleSelectedAvatar}
                />
              </div>
              <input
                ref={avatarUrlRef}
                className="w-[400px] text-black"
                type="text"
                name="avatar-url"
                hidden
              />
            </div>

            <Button className="w-full rounded-full" type="submit" disabled={isSubmitting}>
              {isSubmitting ? <Loader2Icon className="animate-spin" /> : '変更'}
            </Button>
            <Button
              className="w-full rounded-full bg-transparent"
              type="button"
              variant="outline"
              asChild
            >
              <Link to="/settings/profile">キャンセル</Link>
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
profile

import Logo from '@/components/layout/logo';
import ProfileCounts from '@/components/settings/profile-counts';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { useAuth } from '@/hooks/context/use-auth';
import ErrorElement from '@/routes/error-element';
import { KeyRoundIcon, MailIcon, UserRoundIcon } from 'lucide-react';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { Link } from 'react-router-dom';

export default function Page() {
  const { user } = useAuth();

  if (!user) return null;

  return (
    <div className="my-3 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">プロフィール</p>

      <Card className="w-80 overflow-hidden rounded-3xl sm:w-96">
        <CardHeader className="h-80 w-full bg-gradient-to-tr from-secondary to-primary">
          <div className="flex flex-col items-center pt-8">
            <Avatar className="mb-4 size-24">
              <AvatarImage
                className="bg-primary"
                src={user.avatarUrl}
                alt="avatar-image"
              />
              <AvatarFallback className="bg-primary text-5xl font-semibold">
                {user.name.slice(0, 1)}
              </AvatarFallback>
            </Avatar>
            <p className="text-xl font-semibold">{user.name}</p>
            <p className="text-sm">{user.email}</p>
          </div>

          <ErrorBoundary fallback={<ErrorElement />}>
            <Suspense fallback={null}>
              <ProfileCounts />
            </Suspense>
          </ErrorBoundary>
        </CardHeader>

        <CardContent className="relative p-6">
          <ul>
            <li className="flex items-center p-2">
              <UserRoundIcon className="mr-4" />
              <p>ユーザー情報</p>
              <div className="flex-1"></div>
              <Button className="rounded-full bg-transparent" variant="outline" asChild>
                <Link to="/settings/change-user-info">変更</Link>
              </Button>
            </li>
            <li className="flex items-center p-2">
              <MailIcon className="mr-4" />
              <p>メールアドレス</p>
              <div className="flex-1"></div>
              <Button className="rounded-full bg-transparent" variant="outline" asChild>
                <Link to="/settings/change-email">変更</Link>
              </Button>
            </li>
            <li className="flex items-center p-2">
              <KeyRoundIcon className="mr-4" />
              <p>パスワード</p>
              <div className="flex-1"></div>
              <Button className="rounded-full bg-transparent" variant="outline" asChild>
                <Link to="/settings/change-password">変更</Link>
              </Button>
            </li>
          </ul>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
signup

import Logo from '@/components/layout/logo';
import PasswordInput from '@/components/settings/password-input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useApiUser } from '@/hooks/api/use-api-user';
import { useAuth } from '@/hooks/context/use-auth';
import { useToast } from '@/hooks/use-toast';
import { cn } from '@/lib/util';
import { Loader2Icon } from 'lucide-react';
import { useEffect, useRef, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export default function Page() {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const [nameErrorMessage, setNameErrorMessage] = useState('');
  const [emailErrorMessage, setEmailErrorMessage] = useState('');
  const [passwordErrorMessage, setPasswordErrorMessage] = useState('');

  const nameRef = useRef<HTMLInputElement | null>(null);
  const emailRef = useRef<HTMLInputElement | null>(null);
  const passwordRef = useRef<HTMLInputElement | null>(null);

  const navigate = useNavigate();
  const { signup, setUser } = useAuth();
  const { getCurrentUser, checkUsernameExists } = useApiUser();
  const { toast } = useToast();

  useEffect(() => {
    nameRef.current?.focus();
  }, []);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    const form = new FormData(e.currentTarget);
    const name = form.get('name') as string;
    const email = form.get('email') as string;
    const password = form.get('password') as string;

    if (!(name && email && password)) {
      if (name === '') setNameErrorMessage('ユーザー名は必須です。');
      if (email === '') setEmailErrorMessage('メールアドレスは必須です。');
      if (password === '') setPasswordErrorMessage('パスワードは必須です。');
      return;
    }

    setIsSubmitting(true);
    const isSuccess = await signup({ name, email, password });
    if (!isSuccess) {
      setIsSubmitting(false);
      toast({
        title: '新規登録できませんでした',
        description: '入力内容を確認してください',
        variant: 'destructive',
        duration: 5000,
      });
      return;
    }

    setUser(await getCurrentUser());
    setIsSubmitting(false);

    navigate('/');
  };

  const handleCheckName = async () => {
    setNameErrorMessage('');

    if (!nameRef.current?.value) return;

    if (await checkUsernameExists(nameRef.current.value)) {
      setNameErrorMessage('そのユーザー名はすでに使われています。');
    }
  };

  const handleCheckEmail = () => {
    setEmailErrorMessage('');

    if (!emailRef.current?.value) return;

    const emailRegex = /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(emailRef.current.value)) {
      setEmailErrorMessage('無効なメールアドレスです。');
    }
  };

  const handleCheckPassword = () => {
    setPasswordErrorMessage('');

    if (!passwordRef.current?.value) return;

    if (passwordRef.current.value.length < 4) {
      setPasswordErrorMessage('パスワードは4文字以上で設定してください。');
    }
  };

  return (
    <div className="my-3 flex flex-col place-items-center gap-y-3 sm:my-16">
      <Logo size="lg" disableLink />
      <p className="font-semibold">アカウントの作成</p>
      <Card className="w-80 rounded-3xl sm:w-96">
        <CardContent className="p-6 sm:px-10">
          <form className="flex w-full flex-col gap-y-4" onSubmit={handleSubmit}>
            <div>
              <Label className="text-xs" htmlFor="name">
                ユーザー名
              </Label>
              <Input
                ref={nameRef}
                className={cn(
                  'my-2 rounded-full',
                  nameErrorMessage && 'border-destructive'
                )}
                id="name"
                name="name"
                autoComplete="off"
                spellCheck="false"
                onBlur={handleCheckName}
              />
              {nameErrorMessage && (
                <p className="text-xs text-destructive">{nameErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="email">
                メールアドレス
              </Label>
              <Input
                ref={emailRef}
                className={cn(
                  'my-2 rounded-full',
                  emailErrorMessage && 'border-destructive'
                )}
                id="email"
                name="email"
                autoComplete="off"
                spellCheck="false"
                onBlur={handleCheckEmail}
              />
              {emailErrorMessage && (
                <p className="text-xs text-destructive">{emailErrorMessage}</p>
              )}
            </div>

            <div>
              <Label className="text-xs" htmlFor="password">
                パスワード
              </Label>
              <PasswordInput
                ref={passwordRef}
                className={cn(
                  'my-2 rounded-full',
                  passwordErrorMessage && 'border-destructive'
                )}
                id="password"
                name="password"
                onBlur={handleCheckPassword}
              />
              {passwordErrorMessage && (
                <p className="text-xs text-destructive">{passwordErrorMessage}</p>
              )}
            </div>

            <Button
              className="mt-6 w-full rounded-full"
              type="submit"
              disabled={isSubmitting}
            >
              {isSubmitting ? <Loader2Icon className="animate-spin" /> : '新規登録'}
            </Button>
          </form>

          <div className="mt-6 flex justify-center gap-x-1 text-xs">
            <p className="text-muted-foreground">アカウントをお持ちですか？</p>
            <Link to={'/login'}>
              <p className="text-primary hover:underline">ログイン</p>
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

------------------------------------------------------------
protected-route

import { useApiToken } from '@/hooks/api/use-api-token';
import { useAuth } from '@/hooks/context/use-auth';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useEffect, useState } from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';

export const ProtectedRoute = () => {
  const location = useLocation();
  const { logout } = useAuth();
  const { validateToken } = useApiToken();
  const { confirmDialog } = useConfirmDialog();

  const [isAuthenticated, setIsAuthenticated] = useState<null | boolean>(null);

  useEffect(() => {
    const checkAuthentication = async () => {
      const isValid = await validateToken();
      console.log(isValid);

      if (isValid) {
        setIsAuthenticated(true);
      } else {
        logout();
        setIsAuthenticated(false);
        await confirmDialog({
          icon: 'i',
          title: 'ログアウトしました',
          message:
            'ログインしてから一定時間が経過したため、自動でログアウトしました。再度ログインしてください。',
          actionLabel: 'ログイン画面へ',
          actionOnly: true,
          persistent: true,
        });
      }
    };
    checkAuthentication();
  }, [logout, location, confirmDialog, validateToken]);

  if (isAuthenticated === null) {
    return null;
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <Outlet />;
};

------------------------------------------------------------
stores/auth-provider

import { BOOKS_API_ENDPOINT } from '@/constants/constants';
import { AccessToken, LoginRequest, LoginResponse, SignupRequest, User } from '@/types';
import { createContext, useEffect, useState } from 'react';

type ContextType = {
  accessToken: string | null;
  user: User | null;
  setUser: (user: User | null) => void;
  login: (loginRequest: LoginRequest) => Promise<boolean>;
  signup: (signupRequest: SignupRequest) => Promise<boolean>;
  logout: () => Promise<void>;
  refreshAccessToken: () => Promise<void>;
};

const AuthContext = createContext<ContextType | undefined>(undefined);

const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [accessToken, setAccessToken] = useState<string | null>(null);
  const [user, setUser] = useState<User | null>(null);

  const login = async ({ email, password }: LoginRequest) => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/login`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
        credentials: 'include',
      };

      const response = await fetch(url, options);
      const loginResponse = (await response.json()) as LoginResponse;

      setUser(loginResponse.user);
      setAccessToken(loginResponse.accessToken);
      return true;
    } catch (error) {
      console.error('Failed login:', error);
      setUser(null);
      setAccessToken(null);
      return false;
    }
  };

  const signup = async ({ name, email, password }: SignupRequest) => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/signup`;
      const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, email, password }),
      };

      await fetch(url, options);
      await login({ email, password });

      return true;
    } catch (error) {
      console.error('Failed signup:', error);
      setAccessToken(null);
      return false;
    }
  };

  const logout = async () => {
    const url = `${BOOKS_API_ENDPOINT}/logout`;
    const options: RequestInit = {
      method: 'POST',
      credentials: 'include',
    };

    await fetch(url, options);
    setUser(null);
    setAccessToken(null);
  };

  const refreshAccessToken = async () => {
    try {
      const url = `${BOOKS_API_ENDPOINT}/refresh-token`;
      const options: RequestInit = {
        method: 'POST',
        credentials: 'include',
      };

      const response = await fetch(url, options);
      if (!response.ok) {
        throw new Error();
      }
      const data = (await response.json()) as AccessToken;

      setAccessToken(data.accessToken);
    } catch {
      setUser(null);
      setAccessToken(null);
    }
  };

  useEffect(() => {
    refreshAccessToken();
  }, []);

  return (
    <AuthContext.Provider
      value={{
        accessToken,
        user,
        setUser,
        login,
        signup,
        logout,
        refreshAccessToken,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export { AuthContext, AuthProvider };


------------------------------------------------------------
types/auth

import { User } from '@/types/user';

export type LoginRequest = {
  email: string;
  password: string;
};

export interface LoginResponse {
  accessToken: string;
  user: User;
}

export interface SignupRequest {
  name: string;
  email: string;
  password: string;
}

export interface AccessToken {
  accessToken: string;
}

export interface CustomError extends Error {
  code?: string;
}

------------------------------------------------------------
error-response

export interface ErrorResponse {
  messages: string[];
  status: string;
}

------------------------------------------------------------
main

import { router } from '@/routes/route';
import { AuthProvider } from '@/stores/auth-provider';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { RouterProvider } from 'react-router-dom';
import './index.css';

const queryClient = new QueryClient();

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <RouterProvider router={router} />
      </AuthProvider>
    </QueryClientProvider>
  </StrictMode>
);

------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------


