------------------------------------------------------------
init.sql

http→https

------------------------------------------------------------
SecurityConfig

package com.example.my_books_backend.config;

import java.util.Arrays;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
    private final AuthTokenFilter authTokenFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable());

        http.cors(cors -> cors.configurationSource(corsConfigurationSource()));

        http.sessionManagement(
                session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        http.authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/api/v1/login", "/api/v1/signup", "/api/v1/refresh-token", "/api/v1/validate-token",
                        "/api/v1/logout")
                .permitAll().requestMatchers("/api/v1/books/**", "/api/v1/genres/**").permitAll()
                .requestMatchers("/v3/api-docs/**", "/swagger-ui/**", "/swagger-ui.html")
                .permitAll().anyRequest().authenticated());

        http.addFilterBefore(authTokenFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("https://localhost:5173"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}

------------------------------------------------------------
AuthController

package com.example.my_books_backend.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import com.example.my_books_backend.dto.auth.LoginRequest;
import com.example.my_books_backend.dto.auth.LoginResponse;
import com.example.my_books_backend.dto.auth.SignupRequest;
import com.example.my_books_backend.dto.auth.AccessTokenResponse;
import com.example.my_books_backend.dto.user.UserResponse;
import com.example.my_books_backend.service.AuthService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class AuthController {
    private final AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@Valid @RequestBody LoginRequest request,
            HttpServletResponse response) {
        LoginResponse loginResponse = authService.login(request, response);
        return ResponseEntity.ok(loginResponse);
    }

    @PostMapping("/signup")
    public ResponseEntity<UserResponse> signup(@Valid @RequestBody SignupRequest request) {
        UserResponse userResponse = authService.signup(request);
        return ResponseEntity.ok(userResponse);
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<AccessTokenResponse> refreshToken(HttpServletRequest request) {
        AccessTokenResponse accessTokenResponse = authService.refreshAccessToken(request);
        return ResponseEntity.ok(accessTokenResponse);
    }

    @PostMapping("/validate-token")
    public ResponseEntity<Void> validateToken(HttpServletRequest request) {
        authService.validateToken(request);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/logout")
    public ResponseEntity<String> logout(HttpServletRequest request, HttpServletResponse response) {
        authService.logout(request, response);
        return ResponseEntity.ok("ログアウトしました。");
    }
}

------------------------------------------------------------
AuthService

package com.example.my_books_backend.service;

import java.util.List;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Service;
import com.example.my_books_backend.dto.auth.LoginRequest;
import com.example.my_books_backend.dto.auth.LoginResponse;
import com.example.my_books_backend.dto.auth.SignupRequest;
import com.example.my_books_backend.dto.auth.AccessTokenResponse;
import com.example.my_books_backend.dto.user.CreateUserRequest;
import com.example.my_books_backend.dto.user.UserResponse;
import com.example.my_books_backend.entity.User;
import com.example.my_books_backend.exception.ConflictException;
import com.example.my_books_backend.exception.UnauthorizedException;
import com.example.my_books_backend.exception.ValidationException;
import com.example.my_books_backend.repository.UserRepository;
import com.example.my_books_backend.service.impl.UserDetailsServiceImpl;
import com.example.my_books_backend.util.JwtUtil;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AuthService {
    private final AuthenticationManager authenticationManager;
    private final UserRepository userRepository;
    private final UserService userService;
    private final UserDetailsServiceImpl userDetailsService;
    private final JwtUtil jwtUtil;

    public LoginResponse login(LoginRequest request, HttpServletResponse response) {
        Authentication authentication;
        try {
            authentication =
                    authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(
                            request.getEmail(), request.getPassword()));
        } catch (AuthenticationException e) {
            throw new UnauthorizedException("ログインに失敗しました。メールアドレスまたはパスワードが無効です。");
        }

        SecurityContextHolder.getContext().setAuthentication(authentication);
        User user = (User) authentication.getPrincipal();

        String accessToken = jwtUtil.generateAccessToken(user);
        String refreshToken = jwtUtil.generateRefreshToken(user);

        Cookie refreshTokenCookie = jwtUtil.createRefreshTokenCookie(refreshToken);
        response.addCookie(refreshTokenCookie);

        String name = user.getName();
        List<String> roles = user.getRoles().stream().map(role -> role.getName()).toList();

        return new LoginResponse(accessToken, name, roles);
    }

    public UserResponse signup(SignupRequest request) {
        String email = request.getEmail();
        String password = request.getPassword();
        String confirmPassword = request.getConfirmPassword();

        if (!password.equals(confirmPassword)) {
            throw new ValidationException("パスワードと確認用パスワードが一致していません。");
        }

        if (userRepository.existsByEmail(email)) {
            throw new ConflictException("サインアップに失敗しました。このメールアドレスは既に登録されています。: " + email);
        }

        CreateUserRequest createUserRequest = new CreateUserRequest();
        createUserRequest.setEmail(email);
        createUserRequest.setPassword(password);

        return userService.createUser(createUserRequest);
    }

    public AccessTokenResponse refreshAccessToken(HttpServletRequest request) {
        String refreshToken = jwtUtil.getRefreshTokenFromCookie(request);

        if (refreshToken == null || !jwtUtil.validateToken(refreshToken)
                || jwtUtil.isTokenInvalid(refreshToken)) {
            throw new UnauthorizedException("トークンが無効です。");
        }

        String email = jwtUtil.getSubjectFromToken(refreshToken);
        User user = (User) userDetailsService.loadUserByUsername(email);

        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
        SecurityContextHolder.getContext().setAuthentication(authentication);

        String accessToken = jwtUtil.generateAccessToken(user);
        return new AccessTokenResponse(accessToken);
    }

    public void validateToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken == null || !bearerToken.startsWith("Bearer ")) {
            throw new UnauthorizedException("トークンが無効です。");
        }
        String accessToken = bearerToken.substring(7);
        if (!jwtUtil.validateToken(accessToken)) {
            throw new UnauthorizedException("トークンが無効です。");
        }
    }

    public void logout(HttpServletRequest request, HttpServletResponse response) {
        String refreshToken = jwtUtil.getRefreshTokenFromCookie(request);

        if (refreshToken != null) {
            jwtUtil.addInvalidatedTokens(refreshToken);

            Cookie cookie = jwtUtil.getInvalidateRefreshTokenCookie();
            response.addCookie(cookie);
        }
    }
}

------------------------------------------------------------
JwtUtil

package com.example.my_books_backend.util;

import java.security.Key;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.stream.Collectors;
import javax.crypto.SecretKey;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import com.example.my_books_backend.entity.Role;
import com.example.my_books_backend.entity.User;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;

@Component
public class JwtUtil {
    private static final Logger logger = LoggerFactory.getLogger(JwtUtil.class);

    @Value("${spring.app.jwtSecret}")
    private String secret;

    @Value("${spring.app.jwtAccessExpiration}")
    private int accessExpiration;

    @Value("${spring.app.jwtRefreshExpiration}")
    private int refreshExpiration;

    private static final String REFRESH_TOKEN_KEY = "refreshToken";

    // リフレッシュトークンの失効リスト（jtiをキー、トークンの有効期限（エポックタイム）を値とする）
    private Map<String, Long> invalidatedTokens = new ConcurrentHashMap<>();

    // アクセストークン生成
    public String generateAccessToken(User user) {
        String email = user.getEmail();
        String username = user.getName();
        String roles = user.getRoles().stream().map(Role::getName).collect(Collectors.joining(","));

        return Jwts.builder().subject(email).claim("username", username).claim("roles", roles)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + accessExpiration * 1000))
                .signWith(key()).compact();
    }

    // リフレッシュトークン生成
    public String generateRefreshToken(User user) {
        String email = user.getEmail();
        String jti = UUID.randomUUID().toString(); // 一意のトークンID（失効リストで使用）

        return Jwts.builder().subject(email).id(jti).issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + refreshExpiration * 1000))
                .signWith(key()).compact();
    }

    // リフレッシュトークンからCookieを作成
    public Cookie createRefreshTokenCookie(String refreshToken) {
        Cookie cookie = new Cookie(REFRESH_TOKEN_KEY, refreshToken);
        cookie.setHttpOnly(true);
        cookie.setPath("/");
        cookie.setAttribute("SameSite", "None");
        cookie.setSecure(true);
        cookie.setMaxAge(refreshExpiration);
        return cookie;
    }

    // リフレッシュトークンを失効リストに追加
    public void addInvalidatedTokens(String refreshToken) {
        String jti = getJtiFromToken(refreshToken);
        Long expiryTime = getExpiryTimeFromToken(refreshToken).getTime();
        invalidatedTokens.put(jti, expiryTime);
    }

    // リフレッシュトークンが失効リストに含まれているか
    public boolean isTokenInvalid(String refreshToken) {
        String jti = getJtiFromToken(refreshToken);
        Long expiryTime = invalidatedTokens.get(jti);
        if (expiryTime == null) {
            return false;
        }

        // 現在時刻が有効期限を過ぎている場合も無効
        return System.currentTimeMillis() > expiryTime;
    }

    // リフレッシュトークン失効リストの定期クリーンアップ
    @Scheduled(cron = "${spring.app.deleteInvalidRefreshTokens.schedule.cron}", zone = "Asia/Tokyo")
    public void cleanupInvalidatedTokens() {
        long currentTime = System.currentTimeMillis();
        invalidatedTokens.entrySet().removeIf(entry -> entry.getValue() < currentTime);
        logger.info("リフレッシュトークン失効リストをクリーンアップしました。");
    }

    // リフレッシュトークンを無効にしたCookieを取得
    public Cookie getInvalidateRefreshTokenCookie() {
        Cookie cookie = new Cookie(REFRESH_TOKEN_KEY, "");
        cookie.setHttpOnly(true);
        cookie.setPath("/");
        cookie.setAttribute("SameSite", "None");
        cookie.setSecure(true);
        cookie.setMaxAge(0); // すぐに削除
        return cookie;
    }

    // リフレッシュトークンをCookieから取得
    public String getRefreshTokenFromCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();

        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (REFRESH_TOKEN_KEY.equals(cookie.getName())) {
                    return cookie.getValue();
                }
            }
        }
        return null;
    }

    // トークンの検証
    public boolean validateToken(String token) {
        try {
            Jwts.parser().verifyWith((SecretKey) key()).build().parseSignedClaims(token);
            return true;
        } catch (MalformedJwtException e) {
            logger.error("無効な JWTトークン: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("JWTトークンの有効期限が切れています: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("JWTトークンはサポートされていません: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("JWTクレーム文字列が空です: {}", e.getMessage());
        }
        return false;
    }

    // トークンからサブジェクトを取得
    public String getSubjectFromToken(String token) {
        return getClaimFromToken(token, claims -> claims.getSubject());
    }

    // トークンからJTIを取得
    public String getJtiFromToken(String token) {
        return getClaimFromToken(token, claims -> claims.getId());
    }

    // トークンから有効期限を取得
    public Date getExpiryTimeFromToken(String token) {
        return getClaimFromToken(token, claims -> claims.getExpiration());
    }

    // トークンのロールを取得
    public List<String> getRolesFromToken(String token) {
        return getClaimFromToken(token, claims -> {
            String rolesString = claims.get("roles", String.class);
            return rolesString != null ? Arrays.asList(rolesString.split(","))
                    : Collections.emptyList();
        });
    }

    // 秘密鍵の生成
    private Key key() {
        byte[] keyBytes = Decoders.BASE64.decode(secret);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    // 汎用的なクレーム取得メソッド
    private <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }

    // すべてのクレームを取得
    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parser().verifyWith((SecretKey) key()).build().parseSignedClaims(token)
                .getPayload();
    }
}

// ---------------------------------------------------------------------------
// JWT秘密鍵
// @Value("${spring.app.jwtSecret}")
// private String secret;
//
// 以下のようなプログラムで生成した値を環境変数に設定
// import java.security.SecureRandom;
// import java.util.Base64;
//
// public class JwtSecretGenerator {
// public static void main(String[] args) {
// // 256ビット（32バイト）のランダムな秘密鍵を生成
// byte[] keyBytes = new byte[32];
// new SecureRandom().nextBytes(keyBytes);
//
// // Base64エンコード
// String base64EncodedSecret = Base64.getEncoder().encodeToString(keyBytes);
//
// System.out.println("生成されたBase64エンコード秘密鍵:");
// System.out.println(base64EncodedSecret);
// }
// }

------------------------------------------------------------
application

spring.application.name=my-books-backend

spring.jpa.properties.hibernate.hbm2dll.create_namespaces=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.open-in-view=false

# X-Forwarded-Protoヘッダーを使用して元のプロトコルを認識する
# （リバースプロキシ元がHTTPS通信ならHTTPS通信と認識するため）
server.forward-headers-strategy = native

# DB
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}

# JWT
spring.app.jwtSecret=${SPRING_APP_JWT_SECRET}
# spring.app.jwtAccessExpiration=${SPRING_APP_JWT_ACCESS_EXPIRATION}
# spring.app.jwtRefreshExpiration=${SPRING_APP_JWT_REFRESH_EXPIRATION}
spring.app.jwtAccessExpiration=60
spring.app.jwtRefreshExpiration=180

# リフレッシュトークン失効リストのクリーンアップタイミング（毎日、0時0分0秒）
spring.app.deleteInvalidRefreshTokens.schedule.cron=0 0 0 * * *

# ユーザーのデフォルトアバター
spring.app.defaultAvatarUrl="https://localhost/images/avatars/avatar00.png"
------------------------------------------------------------
