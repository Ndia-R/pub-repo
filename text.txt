８ファイル

------------------------------------------------------------
book-detail

import FavoriteButton from '@/components/favorite-button';
import GenreList from '@/components/genre-list/genre-list';
import MyListButton from '@/components/my-list-button';
import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useUser } from '@/hooks/use-user';
import { getBookDetailById, getGenres } from '@/lib/data';
import { formatDateJP, formatIsbn, priceToString } from '@/lib/util';
import { useSuspenseQueries } from '@tanstack/react-query';

type Props = {
  bookId: string;
};

export default function BookDetail({ bookId }: Props) {
  const [{ data: bookDetail }, { data: genres }] = useSuspenseQueries({
    queries: [
      {
        queryKey: ['getBookDetailById', bookId],
        queryFn: () => getBookDetailById(bookId),
      },
      {
        queryKey: ['getGenres'],
        queryFn: () => getGenres(),
      },
    ],
  });

  const { user } = useUser();

  return (
    <div className="flex flex-col justify-center p-3 pt-10 sm:p-6 lg:flex-row">
      <div className="flex flex-col items-center justify-center lg:w-1/2">
        <img
          className="h-[360px] rounded object-cover sm:h-[480px]"
          src={bookDetail.imageUrl}
          alt={bookDetail.title}
        />
        <div className="mt-2 flex flex-col items-center sm:w-[440px]">
          <div className="flex items-center gap-x-2">
            <Rating rating={bookDetail.rating} readOnly />
            <p className="text-sm text-muted-foreground">{`( ${bookDetail.reviewCount} )`}</p>
          </div>

          <div className="flex justify-center">
            <div className="flex items-center gap-x-1">
              <Tooltip>
                <TooltipTrigger asChild>
                  <MyListButton />
                </TooltipTrigger>
                {user ? (
                  <TooltipContent>マイリストに追加</TooltipContent>
                ) : (
                  <TooltipContent>
                    ログインしてこの本を「マイリスト」に加えましょう
                  </TooltipContent>
                )}
              </Tooltip>
              <p className="flex min-w-6 text-sm text-muted-foreground">
                {bookDetail.myListCount}
              </p>
            </div>
            <FavoriteButton bookId={bookId} animation={true} />
          </div>
        </div>

        <div className="my-4 flex items-center">
          <Button className="w-48 rounded-full" size="lg">
            読む
          </Button>
        </div>
      </div>

      <div className="p-4 lg:w-1/2">
        <p className="text-3xl font-bold sm:text-4xl">{bookDetail.title}</p>

        <div className="my-4 flex w-full flex-wrap items-center justify-end gap-x-3">
          <p>著者</p>
          {bookDetail.authors.map((author) => (
            <p className="text-lg font-bold sm:text-2xl" key={author}>
              {author}
            </p>
          ))}
        </div>

        <GenreList
          className="gap-2"
          genres={genres}
          filterList={bookDetail.genreIds}
          variant="outline"
        />

        <div className="my-6 md:my-10">{bookDetail.description}</div>

        <div className="flex flex-col justify-between gap-y-4 lg:flex-row">
          <div className="flex flex-col gap-y-1 text-muted-foreground">
            <div className="flex">
              <p className="min-w-20">ISBN</p>
              <p>{formatIsbn(bookDetail.isbn)}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">出版社</p>
              <p>{bookDetail.publisher}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">発売日</p>
              <p className="tracking-wide">{formatDateJP(bookDetail.publishedDate)}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">ページ数</p>
              <p>{`${bookDetail.pageCount}ページ`}</p>
            </div>
            <div className="flex">
              <p className="min-w-20">価格</p>
              <p>{priceToString(bookDetail.price)}</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

------------------------------------------------------------
review-create-dialog

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { useUser } from '@/hooks/use-user';
import { createReview } from '@/lib/action';
import { ReviewRequest } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import React, { useEffect, useRef, useState } from 'react';

type Props = {
  bookId: string;
  reviewExists: boolean;
  queryKey: unknown[];
};

export default function ReviewCreateDialog({ bookId, reviewExists, queryKey }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { toast } = useToast();
  const { user } = useUser();
  const { confirmDialog } = useConfirmDialog();

  const queryClient = useQueryClient();
  const { mutate } = useMutation({
    mutationFn: (reqestBody: ReviewRequest) => createReview(reqestBody),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  useEffect(() => {
    if (isOpen) {
      setRating(0);
      setComment('');
    }
  }, [isOpen]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handlePost = async () => {
    if (rating === 0) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: 'このまま投稿しますか？',
        message: '星の数が「0」のままです。',
        actionLabel: '投稿する',
      });
      if (isCancel) return;
    }

    mutate(
      { comment, rating, bookId },
      {
        onSuccess: () => {
          toast({ description: 'レビューを投稿しました' });
          setIsOpen(false);
        },
        onError: () => {
          toast({
            title: 'レビュー投稿に失敗しました',
            description: '管理者へ連絡してください',
            variant: 'destructive',
            duration: 5000,
          });
          setIsOpen(false);
        },
      }
    );
  };

  const handleCloseDialog = async () => {
    if (comment) {
      const { isCancel } = await confirmDialog({
        icon: '?',
        title: '本当に閉じますか？',
        message: 'コメントはまだ投稿していません。',
        actionLabel: '閉じる',
        persistent: true,
      });
      if (isCancel) return;
    }
    setIsOpen(false);
  };

  return (
    <>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className="w-44 rounded-full bg-transparent"
            variant="outline"
            disabled={reviewExists}
            onClick={() => user && setIsOpen(true)}
          >
            {reviewExists ? 'レビュー済み' : 'レビューする'}
          </Button>
        </TooltipTrigger>
        {!user && (
          <TooltipContent>ログインしてこの本の「レビュー」を書きましょう</TooltipContent>
        )}
      </Tooltip>

      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogContent
          className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
          onEscapeKeyDown={handleCloseDialog}
          onPointerDownOutside={handleCloseDialog}
          onAnimationStart={handleAnimationStart}
        >
          <div className="flex items-start justify-between">
            <div>
              <p className="font-semibold leading-10">レビュー</p>
              <p className="text-xs text-muted-foreground sm:text-sm">
                素敵な感想を伝えましょう！
              </p>
            </div>
            <div>
              <Rating rating={rating} onChange={setRating} />
              <p className="text-center text-xs text-muted-foreground sm:text-sm">
                星をクリックして決定
              </p>
            </div>
          </div>

          <Textarea
            ref={ref}
            spellCheck={false}
            value={comment}
            onChange={(e) => setComment(e.currentTarget.value)}
          />

          <DialogFooter>
            <Button className="rounded-full" variant="ghost" onClick={handleCloseDialog}>
              閉じる
            </Button>
            <Button
              className="rounded-full"
              disabled={comment === '' ? true : false}
              onClick={handlePost}
            >
              投稿する
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}

------------------------------------------------------------
review-item

import Rating from '@/components/rating';
import ReviewUpdateDialog from '@/components/review-list/review-update-dialog';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { useConfirmDialog } from '@/hooks/use-confirm-dialog';
import { useToast } from '@/hooks/use-toast';
import { useUser } from '@/hooks/use-user';
import { deleteReview } from '@/lib/action';
import { formatDateJP, formatTime } from '@/lib/util';
import { Review } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Trash2Icon } from 'lucide-react';

type Props = {
  review: Review;
  bookId: string;
  queryKey: unknown[];
};

export default function ReviewItem({ review, bookId, queryKey }: Props) {
  const { user } = useUser();
  const { toast } = useToast();
  const { confirmDialog } = useConfirmDialog();

  const queryClient = useQueryClient();
  const { mutate } = useMutation({
    mutationFn: (bookId: string) => deleteReview(bookId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  const handleClickDelete = async () => {
    const { isCancel } = await confirmDialog({
      icon: '!',
      title: '削除しますか？',
      message: '削除すると元に戻りません。',
      actionLabel: '削除する',
    });
    if (isCancel) return;

    mutate(bookId, {
      onSuccess: () => {
        toast({ description: 'レビューを削除しました' });
      },
    });
  };

  return (
    <div className="p-4">
      <div className="flex flex-col items-center justify-between sm:flex-row">
        <div className="flex w-full items-center gap-x-4">
          <Avatar className="size-16">
            <AvatarImage
              className="bg-primary/50"
              src={review.user.avatarUrl}
              alt="avatar-image"
            />
            <AvatarFallback className="font-semibold">
              {review.user.name.slice(0, 1)}
            </AvatarFallback>
          </Avatar>
          <div>
            <p className="-mb-1 text-lg font-semibold">{review.user.name}</p>
            <div className="flex items-center">
              <p className="text-sm leading-8 tracking-wide text-muted-foreground whitespace-nowrap">
                {formatDateJP(review.updatedAt)} {formatTime(review.updatedAt)}
              </p>
              <div className="ml-2 flex w-16">
                {user?.id === review.user.id && (
                  <>
                    <ReviewUpdateDialog
                      bookId={bookId}
                      review={review}
                      queryKey={queryKey}
                    />
                    <Button
                      className="size-8 rounded-full text-muted-foreground"
                      variant="ghost"
                      size="icon"
                      onClick={handleClickDelete}
                    >
                      <Trash2Icon className="size-4" />
                    </Button>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
        <Rating rating={review.rating} readOnly />
      </div>
      <p className="mt-2 text-muted-foreground sm:pl-20">{review.comment}</p>
    </div>
  );
}

------------------------------------------------------------
review-update-dialog

import Rating from '@/components/rating';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogFooter } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { Tooltip, TooltipTrigger } from '@/components/ui/tooltip';
import { useToast } from '@/hooks/use-toast';
import { useUser } from '@/hooks/use-user';
import { updateReview } from '@/lib/action';
import { Review, ReviewRequest } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { SquarePenIcon } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';

type Props = {
  bookId: string;
  review: Review;
  queryKey: unknown[];
};

export default function ReviewUpdateDialog({ bookId, review, queryKey }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const [rating, setRating] = useState(0);
  const [comment, setComment] = useState('');

  const ref = useRef<HTMLTextAreaElement | null>(null);

  const { toast } = useToast();
  const { user } = useUser();

  const queryClient = useQueryClient();
  const { mutate } = useMutation({
    mutationFn: (reqestBody: ReviewRequest) => updateReview(reqestBody),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  useEffect(() => {
    if (isOpen) {
      setRating(review.rating);
      setComment(review.comment);
    }
  }, [isOpen, review.comment, review.rating]);

  const handleAnimationStart = (e: React.AnimationEvent) => {
    if (e.animationName === 'enter') {
      ref.current?.focus();
    }
  };

  const handlePost = async () => {
    mutate(
      { comment, rating, bookId },
      {
        onSuccess: () => {
          toast({ description: 'レビューを投稿しました' });
          setIsOpen(false);
        },
        onError: () => {
          toast({
            title: 'レビュー投稿に失敗しました',
            description: '管理者へ連絡してください',
            variant: 'destructive',
            duration: 5000,
          });
          setIsOpen(false);
        },
      }
    );
  };

  const handleCloseDialog = async () => {
    setIsOpen(false);
  };

  return (
    <>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className="size-8 rounded-full text-muted-foreground"
            variant="ghost"
            size="icon"
            onClick={() => user && setIsOpen(true)}
          >
            <SquarePenIcon className="size-4" />
          </Button>
        </TooltipTrigger>
      </Tooltip>

      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogContent
          className="w-3/4 min-w-[360px] max-w-[600px] p-4 sm:p-6"
          onEscapeKeyDown={handleCloseDialog}
          onPointerDownOutside={handleCloseDialog}
          onAnimationStart={handleAnimationStart}
        >
          <div className="flex items-start justify-between">
            <div>
              <p className="font-semibold leading-10">レビュー</p>
              <p className="text-xs text-muted-foreground sm:text-sm">
                素敵な感想を伝えましょう！
              </p>
            </div>
            <div>
              <Rating rating={rating} onChange={setRating} />
              <p className="text-center text-xs text-muted-foreground sm:text-sm">
                星をクリックして決定
              </p>
            </div>
          </div>

          <Textarea
            ref={ref}
            spellCheck={false}
            value={comment}
            onChange={(e) => setComment(e.currentTarget.value)}
          />

          <DialogFooter>
            <Button className="rounded-full" variant="ghost" onClick={handleCloseDialog}>
              閉じる
            </Button>
            <Button
              className="rounded-full"
              disabled={comment === '' ? true : false}
              onClick={handlePost}
            >
              投稿する
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}

------------------------------------------------------------
favorite-button

import CountUpNumber from '@/components/count-up-number';
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useUser } from '@/hooks/use-user';
import { addFavorite, removeFavorite } from '@/lib/action';
import { getFavoriteInfo, getFavoriteInfoWithAuth } from '@/lib/data';
import { cn } from '@/lib/util';
import { FavoriteInfo } from '@/types';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { HeartIcon } from 'lucide-react';

const BUTTON_SIZE = { sm: 'size-6', md: 'size-8' };
const ICON_SIZE = { sm: 'size-3', md: 'size-4' };
const TEXT_SIZE = { sm: 'text-xs', md: 'text-sm' };

type Props = {
  bookId: string;
  size?: 'sm' | 'md';
  animation?: boolean;
};

export default function FavoriteButton({
  bookId,
  size = 'md',
  animation = false,
}: Props) {
  const { user } = useUser();
  const queryClient = useQueryClient();

  const queryKey = ['getFavoriteInfo', bookId];
  const { data: favoriteInfo } = useQuery({
    queryKey,
    queryFn: () => (user ? getFavoriteInfoWithAuth(bookId) : getFavoriteInfo(bookId)),
  });

  const { mutate, variables, isPending } = useMutation({
    mutationFn: async (newFavoriteInfo: FavoriteInfo) => {
      if (newFavoriteInfo.isFavorite) {
        await addFavorite(bookId);
      } else {
        await removeFavorite(bookId);
      }
    },
    onMutate: async (newFavoriteInfo: FavoriteInfo) => {
      await queryClient.cancelQueries({ queryKey });
      const previousFavoriteInfo = queryClient.getQueryData(queryKey);
      queryClient.setQueryData(queryKey, newFavoriteInfo);
      return { previousFavoriteInfo };
    },
    onSettled: (_newFavoriteInfo, error, _variables, context) => {
      if (error) {
        queryClient.setQueryData(queryKey, context?.previousFavoriteInfo);
      }
      queryClient.invalidateQueries({ queryKey });
    },
  });

  const handleClick = () => {
    if (!user || !favoriteInfo) return;

    const newFavoriteInfo: FavoriteInfo = {
      ...favoriteInfo,
      isFavorite: !favoriteInfo.isFavorite,
      favoriteCount: favoriteInfo.isFavorite
        ? favoriteInfo.favoriteCount - 1
        : favoriteInfo.favoriteCount + 1,
    };
    mutate(newFavoriteInfo);
  };

  const optimisticData = isPending ? variables : favoriteInfo;

  return (
    <div className="flex items-center gap-x-0">
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            className={cn(
              'rounded-full text-muted-foreground',
              BUTTON_SIZE[size],
              optimisticData?.isFavorite && 'text-primary bg-transparent'
            )}
            variant="ghost"
            size="icon"
            onClick={handleClick}
          >
            <HeartIcon
              className={ICON_SIZE[size]}
              style={{
                fill: optimisticData?.isFavorite ? 'hsl(var(--primary))' : '',
              }}
            />
          </Button>
        </TooltipTrigger>
        {user ? (
          <TooltipContent>
            {optimisticData?.isFavorite ? 'お気に入りから削除' : 'お気に入りに追加'}
          </TooltipContent>
        ) : (
          <TooltipContent>
            ログインしてこの本を「お気に入り」に加えましょう
          </TooltipContent>
        )}
      </Tooltip>

      <p className={cn('flex min-w-6 text-muted-foreground', TEXT_SIZE[size])}>
        {animation ? (
          <CountUpNumber end={optimisticData?.favoriteCount || 0} />
        ) : (
          optimisticData?.favoriteCount
        )}
      </p>
    </div>
  );
}

------------------------------------------------------------
favorite

import { FETCH_BOOKS_MAX_RESULTS } from '@/constants/constants';
import { fetchJsonWithAuth } from '@/lib/auth';
import { fetchJson } from '@/lib/data';
import { FavoriteInfo, PaginatedBook } from '@/types';

export const getFavorites = async (page: number = 0) => {
  try {
    const url = `/favorites?&page=${page}&maxResults=${FETCH_BOOKS_MAX_RESULTS}`;
    const paginatedBook = await fetchJsonWithAuth<PaginatedBook>(url);
    return paginatedBook;
  } catch {
    throw new Error('お気に入り一覧の読み込みが失敗しました。');
  }
};

export const getFavoriteInfo = async (bookId: string) => {
  try {
    const url = `/favorites/${bookId}/info`;
    const favoriteInfo = await fetchJson<FavoriteInfo>(url);
    return favoriteInfo;
  } catch {
    throw new Error('お気に入り情報の読み込みが失敗しました。');
  }
};

export const getFavoriteInfoWithAuth = async (bookId: string) => {
  try {
    const url = `/favorites/${bookId}/info`;
    const favoriteInfo = await fetchJsonWithAuth<FavoriteInfo>(url);
    return favoriteInfo;
  } catch {
    throw new Error('お気に入り情報の読み込みが失敗しました。');
  }
};

------------------------------------------------------------
favorite

export interface FavoriteInfo {
  bookId: string;
  isFavorite: boolean;
  favoriteCount: number;
}

------------------------------------------------------------
------------------------------------------------------------
